<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Storm Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Noto Sans', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 14px 16px;
            border-radius: 10px;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 240ms ease, opacity 240ms ease;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        #stats { top: 12px; left: 12px; width: 200px; }
        #controls { bottom: 12px; left: 12px; font-size: 11px; width: 200px; }
        #info { bottom: 12px; right: 12px; font-size: 12px; width: 160px; text-align: center; }
        #toggle-gui {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            backdrop-filter: blur(8px);
            transition: all 180ms ease;
            z-index: 100;
        }
        #toggle-gui:hover { background: rgba(0, 0, 0, 0.9); transform: translateY(-1px); }
        .stat-value { color: #6cf; font-weight: 600; }
        .hidden { display: none !important; }
        .title { color: #6cf; font-weight: 600; margin-bottom: 10px; }
        .top-right-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 110;
        }
        #pause-btn, #fp-toggle, #reset-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            backdrop-filter: blur(8px);
            transition: all 180ms ease;
        }
        #pause-btn:hover, #fp-toggle:hover, #reset-btn:hover { 
            background: rgba(0, 0, 0, 0.9); 
            transform: translateY(-1px);
        }
        #fp-toggle.active { background: rgba(108, 204, 255, 0.15); color: #6cf; border-color: rgba(108,204,255,0.2); }

        #graphics {
            position: absolute;
            right: 12px;
            top: 120px;
            width: 220px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 14px 16px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .gfx-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }
        .gfx-label { color: #ddd; font-size: 11px; }
        .gfx-row input[type="checkbox"] { cursor: pointer; }
        .gfx-row input[type="range"], .gfx-row select {
            flex: 1;
            padding: 4px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.06);
            font-size: 11px;
        }
        .gfx-row select { cursor: pointer; }

        body.ui-collapsed .ui-panel { transform: translateY(10px) scale(0.985); opacity: 0; pointer-events: none; }
        body.ui-collapsed #graphics { display: none; }

        #reopen-controls { display: none; }
        body.ui-collapsed #reopen-controls {
            display: block;
            position: absolute;
            left: 12px;
            bottom: 12px;
            padding: 8px 10px;
            border-radius: 8px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 150;
            cursor: pointer;
            font-size: 12px;
        }

        .joy-zone {
            position: absolute;
            width: 120px;
            height: 120px;
            z-index: 60;
            touch-action: none;
            opacity: 0.0001;
        }
        #joy-look { right: 12px; bottom: 12px; }
        #joy-move { left: 12px; bottom: 12px; }

        #forward-btn {
            position: absolute;
            right: 16px;
            bottom: 140px;
            width: 72px;
            height: 44px;
            border-radius: 8px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 120;
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 180ms ease;
        }
        #forward-btn:hover { background: rgba(0,0,0,0.9); transform: translateY(-1px); }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="stats" class="ui-panel">
        <div class="title">‚ö° Storm Dynamics</div>
        <div>FPS: <span class="stat-value" id="fps">0</span></div>
        <div>Raindrops: <span class="stat-value" id="particles">0</span></div>
        <div>Clouds: <span class="stat-value" id="clouds">0</span></div>
        <div>Charge: <span class="stat-value" id="charge">0</span>%</div>
        <div>Strikes: <span class="stat-value" id="strikes">0</span></div>
        <div>Wind: <span class="stat-value" id="wind">0</span> m/s</div>
        <div>CPU Cores: <span class="stat-value" id="cpu">‚Äî</span></div>
        <div>GPU: <span class="stat-value" id="gpu">‚Äî</span></div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.12); font-size: 11px; color: #aaa;">
            <div>‚Ä¢ Clouds form over water</div>
            <div>‚Ä¢ Evaporation & condensation</div>
            <div>‚Ä¢ Wind-driven cloud movement</div>
            <div>‚Ä¢ Dynamic precipitation</div>
            <div>‚Ä¢ Branching lightning</div>
        </div>
    </div>
    <div id="controls" class="ui-panel">
        <div style="color: #ccc; margin-bottom: 8px; font-weight: bold;">Controls</div>
        <div style="color: #aaa; font-size: 11px;">
            <div>üñ±Ô∏è <strong>Mouse Drag</strong> - Rotate camera (orbit) / Look (FP)</div>
            <div>üñ≤Ô∏è <strong>Mouse Wheel</strong> - Zoom (orbit)</div>
            <div>üëÜ <strong>Touch Drag</strong> - Rotate</div>
            <div>ü§è <strong>Pinch</strong> - Zoom in/out</div>
            <div>‚å®Ô∏è <strong>H Key</strong> - Hide/Show GUI</div>
            <div style="margin-top:6px;">WASD - Move (FP), Shift - Run</div>
        </div>
    </div>
    <div id="graphics" class="ui-panel">
        <div style="color:#6cf; font-weight:600; margin-bottom:10px; font-size:12px;">‚öôÔ∏è Graphics</div>
        <div class="gfx-row">
            <label class="gfx-label">Shadows</label>
            <input id="shadow-toggle" type="checkbox" checked />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Rainshafts</label>
            <input id="rainshaft-toggle" type="checkbox" checked />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Lightning</label>
            <input id="lightning-toggle" type="checkbox" checked />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Particles</label>
            <input id="particle-range" type="range" min="200" max="3000" step="100" value="300" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Clouds</label>
            <input id="cloud-range" type="range" min="10" max="200" step="10" value="50" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Evaporation</label>
            <input id="evap-range" type="range" min="0.2" max="2.0" step="0.1" value="1" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Pixel Ratio</label>
            <input id="px-range" type="range" min="0.5" max="2" step="0.1" value="1" />
        </div>
    </div>
    <div id="info" class="ui-panel">
        <div style="color: #6cf; font-weight: bold;">Storm Simulator v5.0</div>
        <div style="color: #888;">Physically Based Weather</div>
    </div>
    <div class="top-right-controls">
        <button id="toggle-gui">üëÅÔ∏è Hide UI</button>
        <button id="pause-btn">‚è∏ Pause</button>
        <button id="reset-btn" style="background: rgba(0,0,0,0.75); color:white; border:1px solid rgba(255,255,255,0.08); padding:8px 12px; border-radius:10px; cursor:pointer; font-family:'Courier New', monospace; font-size:13px; backdrop-filter: blur(6px);">üîÑ Reset</button>
        <button id="fp-toggle" style="background: rgba(0,0,0,0.75); color:white; border:1px solid rgba(255,255,255,0.08); padding:8px 12px; border-radius:10px; cursor:pointer; font-family:'Courier New', monospace; font-size:13px; backdrop-filter: blur(6px);">FP Mode</button>
    </div>

    <!-- Forward hold button (mobile/touch friendly) -->
    <button id="forward-btn" title="Hold to move forward" style="position: absolute; right: 16px; bottom: 140px; width: 72px; height: 44px; border-radius: 10px; background: rgba(0,0,0,0.75); color: white; border:1px solid rgba(255,255,255,0.08); z-index: 120; font-family:'Courier New', monospace; font-size:13px;">Forward</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global state
        const AppState = {
            scene: null,
            camera: null,
            renderer: null,
            showGui: true,
            windField: null,
            cloudSystem: null,
            rainSystem: null,
            lightningSystem: null,
            evaporationSystem: null,
            waterBodies: [],
            paused: false,
            firstPerson: false,
            cameraControls: {
                isDrag: false,
                prevMouse: { x: 0, y: 0 },
                rotation: { yaw: 0, pitch: 0, theta: 0, phi: Math.PI / 5.5 },
                distance: 70,
                maxDistance: 800,
                move: { forward: 0, right: 0 },
                speed: 0.5,
                runMultiplier: 2.0,
                shake: { intensity: 0, duration: 0, frequency: 20, time: 0, targetOffset: { x: 0, y: 0, z: 0 } }
            }
        };

        // Graphics settings defaults
        const Graphics = {
            shadows: true,
            rainshafts: true,
            lightning: true,
            particleDetail: 300,
            cloudDetail: 50,
            pixelRatio: 1,
            volumetric: true,
            volumetricDensity: 0.45,
            volumetricResolution: 12,
            cloudRenderMode: 'volumetric',
            evapMultiplier: 1   // <- evaporation multiplier
        };

        // environmental helper: temperature (¬∞C) and humidity (0..1) estimate at position
        function sampleEnvironment(x, z, altitude = 12) {
            // simple lapse rate: 15¬∞C at sea level, -6.5¬∞C per km
            // include day/night infrared offset (DayNight.tempOffset applied globally)
            const baseSeaTemp = 15 + (window.DayNight ? (window.DayNight.tempOffset || 0) : 0);
            const temp = baseSeaTemp - (altitude / 1000) * 6.5;
            // humidity base: higher near water bodies, falloff with distance
            let h = 0.25; // background humidity
            for (const w of AppState.waterBodies || []) {
                const dist = Math.sqrt((x - w.x) ** 2 + (z - w.y) ** 2);
                const influence = Math.max(0, 1 - dist / (w.r * 2.5));
                h = Math.max(h, 0.6 * influence + 0.25);
            }
            // add small stochastic / diurnal variation based on position to avoid uniformity
            // humidity slightly decreases when hotter (day) and increases at night when cooler
            const diurnalHumidityAdj = window.DayNight ? -0.06 * Math.max(0, window.DayNight.dayStrength) + 0.04 * Math.max(0, 1 - window.DayNight.dayStrength) : 0;
            h = Math.min(1, h + Math.sin((x + z) * 0.007) * 0.05 + diurnalHumidityAdj + (Math.random() - 0.5) * 0.03);
            return { temperature: temp, humidity: h };
        }

        function createTerrain() {
            const geo = new THREE.PlaneGeometry(800, 800, 160, 160);
            const pos = geo.attributes.position.array;
            const col = new Float32Array(pos.length);

            AppState.waterBodies = [
                { x: 0, y: 0, r: 90, d: -2.5 },
                { x: -160, y: 120, r: 70, d: -1.8 },
                { x: 200, y: -140, r: 80, d: -2.0 }
            ];

            for (let i = 0; i < pos.length; i += 3) {
                const x = pos[i];
                const y = pos[i + 1];
                let z = Math.sin(x * 0.02) * Math.cos(y * 0.03) * 2;
                let isWater = false;

                for (const w of AppState.waterBodies) {
                    const dist = Math.sqrt((x - w.x) ** 2 + (y - w.y) ** 2);
                    if (dist < w.r) {
                        z += w.d * (1 - dist / w.r);
                        isWater = true;
                        break;
                    }
                }

                pos[i + 2] = z;
                col[i] = isWater ? 0.2 : 0.4;
                col[i + 1] = isWater ? 0.4 : 0.6;
                col[i + 2] = isWater ? 0.7 : 0.3;
            }

            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.8,
                metalness: 0.2
            }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            AppState.scene.add(ground);
        }

        // Day / Night & Infrared radiation system
        window.DayNight = {
            time: 0, // milliseconds
            dayLength: 120000, // full cycle in ms (2 minutes)
            tempAmplitude: 6, // degrees swing from night to day
            tempOffset: 0, // applied to base sea level in sampleEnvironment
            phase: 0, // 0..1 where 0=midnight, 0.5=noon
            dayStrength: 1, // 0..1 where 1=full day, 0=night
            update(deltaMs) {
                this.time = (this.time + deltaMs) % this.dayLength;
                this.phase = (this.time / this.dayLength);
                // dayStrength follows a smooth curve: peak at 0.5 (noon)
                const angle = this.phase * Math.PI * 2;
                // dayStrength ranges 0..1 (sun elevation proxy)
                this.dayStrength = Math.max(0, Math.sin(angle) * 0.5 + 0.5);
                // infrared temperature offset: warmer during day, cooler at night
                this.tempOffset = Math.cos(angle) * this.tempAmplitude * 0.5 + (this.dayStrength - 0.5) * this.tempAmplitude * 0.5;
            }
        };

        // update scene lighting & fog based on day/night
        function applyDayNightToScene() {
            const d = window.DayNight || { dayStrength: 1 };
            // ambient tint: warmer in day, cooler at night
            const amb = AppState.scene.getObjectByProperty && AppState.scene.children.find(o=>o && o.type==='AmbientLight');
            if (amb && amb.color) {
                // lerp from cool night to warm day
                const dayCol = new THREE.Color(0xffffff);
                const nightCol = new THREE.Color(0x7f89a0);
                amb.color.copy(nightCol).lerp(dayCol, d.dayStrength * 0.95 + 0.05);
                amb.intensity = 0.6 + d.dayStrength * 0.9;
            }
            // directional main sun (first directional light added)
            const sun = AppState.scene.children.find(o => o && o.isDirectionalLight);
            if (sun) {
                sun.intensity = 0.6 + d.dayStrength * 1.6;
                // change sun color slightly (warmer toward dusk)
                const daySun = new THREE.Color(0xfff0d6);
                const nightSun = new THREE.Color(0xaac6ff);
                sun.color.copy(nightSun).lerp(daySun, Math.max(0, d.dayStrength));
                // move sun angle over time for subtle slope
                const ang = window.DayNight.phase * Math.PI * 2;
                const radius = 100;
                sun.position.set(Math.cos(ang) * radius * 0.9, 40 + Math.sin(ang) * 40, Math.sin(ang) * radius * 0.9);
            }
            // background/fog shifts slightly
            const dayBG = new THREE.Color(0x8fb9d6);
            const nightBG = new THREE.Color(0x243a52);
            AppState.scene.background.copy(nightBG).lerp(dayBG, Math.max(0.08, window.DayNight.dayStrength));
            AppState.scene.fog.color.copy(AppState.scene.background);
        }

        class EvaporationSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 500;
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.maxParticles * 3);
                this.sizes = new Float32Array(this.maxParticles);
                this.opacities = new Float32Array(this.maxParticles);
                
                for (let i = 0; i < this.maxParticles; i++) {
                    this.particles.push({ active: false, life: 0 });
                    this.positions[i * 3] = 0;
                    this.positions[i * 3 + 1] = -100;
                    this.positions[i * 3 + 2] = 0;
                    this.sizes[i] = 0;
                    this.opacities[i] = 0;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.opacities, 1));
                
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Multi-layer gradient for wispy vapor
                const grad1 = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                grad1.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                grad1.addColorStop(0.3, 'rgba(240, 248, 255, 0.5)');
                grad1.addColorStop(0.7, 'rgba(220, 235, 250, 0.2)');
                grad1.addColorStop(1, 'rgba(200, 220, 240, 0)');
                ctx.fillStyle = grad1;
                ctx.fillRect(0, 0, 64, 64);
                
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2.5,
                    transparent: true,
                    opacity: 0.5,
                    map: new THREE.CanvasTexture(canvas),
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.points = new THREE.Points(this.geometry, material);
                AppState.scene.add(this.points);
            }

            spawnEvaporation(x, z) {
                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) {
                        const idx = i * 3;
                        this.positions[idx] = x + (Math.random() - 0.5) * 10;
                        this.positions[idx + 1] = 0.3;
                        this.positions[idx + 2] = z + (Math.random() - 0.5) * 10;
                        
                        this.particles[i] = {
                            active: true,
                            life: 1.0,
                            vx: (Math.random() - 0.5) * 0.03,
                            vy: 0.06 + Math.random() * 0.08,
                            vz: (Math.random() - 0.5) * 0.03,
                            maxHeight: 6 + Math.random() * 10,
                            size: 0.8 + Math.random() * 1.2
                        };
                        this.sizes[i] = this.particles[i].size;
                        this.opacities[i] = 0.5;
                        break;
                    }
                }
            }

            update() {
                // More frequent evaporation
                if (Math.random() < 0.5) {
                    const water = AppState.waterBodies[Math.floor(Math.random() * AppState.waterBodies.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * water.r * 0.95;
                    this.spawnEvaporation(
                        water.x + Math.cos(angle) * radius,
                        water.y + Math.sin(angle) * radius
                    );
                }

                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) continue;
                    
                    const p = this.particles[i];
                    const idx = i * 3;
                    
                    // Expand and rise
                    this.positions[idx] += p.vx;
                    this.positions[idx + 1] += p.vy;
                    this.positions[idx + 2] += p.vz;
                    
                    p.life -= 0.008;
                    this.sizes[i] = p.size * (2 - p.life);
                    this.opacities[i] = p.life * 0.6;
                    
                    // Slow down as it rises
                    p.vy *= 0.98;
                    
                    if (p.life <= 0 || this.positions[idx + 1] > p.maxHeight) {
                        p.active = false;
                        this.positions[idx + 1] = -100;
                        this.sizes[i] = 0;
                        this.opacities[i] = 0;
                    }
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
                this.geometry.attributes.alpha.needsUpdate = true;
            }
        }

        class WindField {
            constructor() {
                this.size = 15;
                this.spacing = 8;
                this.field = [];
                this.time = 0;
                
                for (let x = 0; x < this.size; x++) {
                    this.field[x] = [];
                    for (let y = 0; y < this.size; y++) {
                        this.field[x][y] = [];
                        for (let z = 0; z < this.size; z++) {
                            this.field[x][y][z] = { x: 0, y: 0, z: 0 };
                        }
                    }
                }
            }

            update(t) {
                this.time = t * 0.0001;
                let avg = { x: 0, z: 0, c: 0 };
                
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        for (let z = 0; z < this.size; z++) {
                            const wx = (x - this.size / 2) * this.spacing;
                            const wy = y * this.spacing;
                            const wz = (z - this.size / 2) * this.spacing;
                            
                            const vx = Math.sin(wx * 0.03 + this.time) * Math.cos(wz * 0.02 + this.time * 0.5) * 2.5;
                            const vz = Math.cos(wx * 0.02 + this.time * 0.6) * Math.sin(wz * 0.03 + this.time) * 2.0;
                            
                            this.field[x][y][z] = { x: vx, y: 0, z: vz };
                            
                            if (y > 3 && y < 8) {
                                avg.x += vx;
                                avg.z += vz;
                                avg.c++;
                            }
                        }
                    }
                }
                
                return { x: avg.x / avg.c, z: avg.z / avg.c };
            }

            getAt(x, y, z) {
                // Map world coords to grid indices (floating)
                const gxF = (x / this.spacing) + this.size / 2;
                const gyF = (y / this.spacing);
                const gzF = (z / this.spacing) + this.size / 2;

                // Fast reject: completely outside the whole field
                if (gxF < 0 || gxF >= this.size || gyF < 0 || gyF >= this.size || gzF < 0 || gzF >= this.size) {
                    return { x: 0, y: 0, z: 0 };
                }

                // Integer cell indices (clamped so we can safely sample neighbors)
                const gx = Math.max(0, Math.min(this.size - 2, Math.floor(gxF)));
                const gy = Math.max(0, Math.min(this.size - 1, Math.floor(gyF))); // y uses available range
                const gz = Math.max(0, Math.min(this.size - 2, Math.floor(gzF)));

                // interpolation factor along x within the cell
                const fx = gxF - gx;

                // Safely grab cell entries (guard in case of unexpected holes)
                const c0 = (this.field[gx] && this.field[gx][gy] && this.field[gx][gy][gz]) ? this.field[gx][gy][gz] : { x: 0, y: 0, z: 0 };
                const c1 = (this.field[gx + 1] && this.field[gx + 1][gy] && this.field[gx + 1][gy][gz]) ? this.field[gx + 1][gy][gz] : c0;

                // return a small scaled wind vector (matches previous scaling)
                return {
                    x: (c0.x * (1 - fx) + c1.x * fx) * 0.03,
                    y: 0,
                    z: (c0.z * (1 - fx) + c1.z * fx) * 0.03
                };
            }
        }

        class CloudGrowth {
            constructor() {
                this.clouds = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.timer = 0;
                this.max = 50;
                this.clusterCenters = [];
                this.updrafts = [];
            }

            createUpdraft(x, z, strength) {
                return {
                    x, z,
                    strength: strength,
                    radius: 20 + Math.random() * 15,
                    height: 0,
                    maxHeight: 35 + Math.random() * 10,
                    age: 0,
                    maxAge: 200 + Math.random() * 150,
                    active: true
                };
            }

            getUpdraftAt(x, z) {
                let totalLift = 0;
                for (const updraft of this.updrafts) {
                    if (!updraft.active) continue;
                    const dist = Math.sqrt((x - updraft.x) ** 2 + (z - updraft.z) ** 2);
                    if (dist < updraft.radius) {
                        const factor = 1 - (dist / updraft.radius);
                        totalLift += updraft.strength * factor * (updraft.age / updraft.maxAge);
                    }
                }
                return totalLift;
            }

            isOverWater(x, z) {
                for (const w of AppState.waterBodies) {
                    if (Math.sqrt((x - w.x) ** 2 + (z - w.y) ** 2) < w.r) return true;
                }
                return false;
            }

            findNearestCluster(x, z, maxDist = 25) {
                let nearest = null;
                let minDist = maxDist;
                
                for (const cluster of this.clusterCenters) {
                    const dist = Math.sqrt((x - cluster.x) ** 2 + (z - cluster.z) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = cluster;
                    }
                }
                
                return nearest;
            }

            createCluster(x, z) {
                const cluster = {
                    x, z,
                    strength: 0.7 + Math.random() * 0.3,
                    age: 0,
                    maxAge: 400 + Math.random() * 300,
                    hasUpdraft: false
                };
                this.clusterCenters.push(cluster);
                return cluster;
            }

            makePuff(x, y, z, size, dark, turbulence = 0, cloudType = 'cumulus') {
                // use volumetric resolution from Graphics to adjust geometry detail for performance
                const res = Math.max(4, Math.floor(Graphics.volumetricResolution));
                
                // --- CIRRUS / HIGH-ALTITUDE SHEET / FIBROUS RENDERING ---
                if (cloudType && cloudType.startsWith('cirr')) {
                    // thin, stretched semi-transparent planes / streaks to emulate cirrus textures
                    const geom = new THREE.PlaneGeometry(size * 2.2, size * 0.18, 1, 1);
                    // rotate the plane to make wispy streak
                    geom.translate(0, 0, 0);
                    const mat = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(0.92, 0.94, 0.98),
                        transparent: true,
                        opacity: Graphics.volumetric ? (0.18 + dark * 0.12) * Graphics.volumetricDensity : 0.16,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                        blending: THREE.NormalBlending,
                    });
                    const mesh = new THREE.Mesh(geom, mat);
                    mesh.position.set(x, y, z);
                    mesh.rotation.set(-Math.PI/2 + (Math.random()-0.5)*0.25, Math.random()*Math.PI, (Math.random()-0.5)*0.4);
                    mesh.castShadow = false;
                    mesh.receiveShadow = false;
                    return mesh;
                }

                if (Graphics.cloudRenderMode === 'particles') {
                    // Create a soft particle sprite instead of a mesh puff
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                    const baseAlpha = 0.85;
                    grad.addColorStop(0, `rgba(255,255,255,${baseAlpha})`);
                    grad.addColorStop(0.4, `rgba(240,245,255,${baseAlpha * 0.6})`);
                    grad.addColorStop(1, 'rgba(200,220,240,0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 64, 64);

                    const spriteMap = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({
                        map: spriteMap,
                        color: new THREE.Color(1, 1, 1),
                        transparent: true,
                        opacity: Graphics.volumetric ? (0.45 + dark * 0.25) * Graphics.volumetricDensity : 0.4,
                        depthWrite: false,
                        blending: THREE.NormalBlending
                    });
                    const sprite = new THREE.Sprite(material);
                    const scale = size * (0.6 + Math.random() * 0.9 + turbulence * 0.5);
                    sprite.scale.set(scale * (0.9 + Math.random() * 0.4), scale * (0.6 + Math.random() * 0.6), 1);
                    sprite.position.set(x, y, z);
                    sprite.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    return sprite;
                }

                // volumetric mesh puff (existing approach)
                const geo = new THREE.SphereGeometry(size, res, Math.max(4, Math.floor(res * 0.8)));
                
                // Highly varied shapes for realistic cumulus appearance
                const scaleX = 0.85 + Math.random() * 0.5 + turbulence * 0.15;
                const scaleY = 0.8 + Math.random() * 0.7 + turbulence * 0.25;
                const scaleZ = 0.9 + Math.random() * 0.6 + turbulence * 0.2;
                geo.scale(scaleX, scaleY, scaleZ);
                
                // Realistic cloud coloring - bright white tops, darker bases
                const heightFactor = Math.max(0, (y - 12) / 25);
                const topBrightness = 0.95 + heightFactor * 0.05;
                const baseBrightness = 0.75 - dark * 0.4;
                const b = baseBrightness + (topBrightness - baseBrightness) * heightFactor;
                
                // Use Lambert for soft, realistic lighting
                // modulate opacity by volumetric density control and optionally disable volumetric for flat puffs
                const baseOpacity = 0.45 + dark * 0.25 + turbulence * 0.1;
                const opacity = Graphics.volumetric ? baseOpacity * Graphics.volumetricDensity : Math.min(1, baseOpacity * 0.75);
                const mat = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(b, b, b + 0.02),
                    transparent: true,
                    opacity: opacity,
                    depthWrite: false
                });
                mat.fog = true;

                const m = new THREE.Mesh(geo, mat);
                m.position.set(x, y, z);
                m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                m.castShadow = true;
                m.receiveShadow = true;
                return m;
            }

            grow(x, z) {
                // Allow cloud formation anywhere but only when local temperature/humidity permit
                const env = sampleEnvironment(x, z, 12);
                const humidityThreshold = 0.38; // minimum humidity to form clouds
                const tempThreshold = -10; // unrealistic cold min (keeps very hot areas from forming clouds)
                // Cloud formation chance based on humidity and a reasonable temperature window (-15..30)
                const tempOk = env.temperature > tempThreshold && env.temperature < 35;
                const humidityOk = env.humidity >= humidityThreshold;
                if (!tempOk || (!humidityOk && Math.random() > 0.12) || Math.random() > Math.min(1, (env.humidity - humidityThreshold) * 3 + 0.25)) {
                    // attempt to spawn high-altitude cirrus family when humidity slightly lower but other conditions allow
                    // Cirrus prefer drier, colder upper levels and often form high above base clouds
                    const envHigh = sampleEnvironment(x, z, 140);
                    if (envHigh.humidity > 0.18 && envHigh.temperature < 0 && Math.random() < 0.08) {
                        // create a cirrus-family cloud
                        const cirTypeRoll = Math.random();
                        const ctype = cirTypeRoll < 0.5 ? 'cirrus' : (cirTypeRoll < 0.8 ? 'cirrostratus' : 'cirrocumulus');
                        const c = {
                            x, z, age: 0,
                            maxAge: 800 + Math.random() * 600,
                            baseHeight: 34 + Math.random() * 14, // high altitude
                            height: null,
                            cloudTop: null,
                            cloudBase: null,
                            puffs: [],
                            grp: new THREE.Group(),
                            dying: false,
                            cluster: null,
                            growthRate: 0.005 + Math.random() * 0.01,
                            mass: 0,
                            condensationLevel: 0,
                            turbulence: 0.02,
                            velocity: { x: 0, z: 0 },
                            targetVelocity: { x: 0, z: 0 },
                            radius: 8 + Math.random() * 12,
                            widthFactor: 0.6 + Math.random() * 0.9,
                            horizontalSpread: 2.2,
                            mergeTimer: 0,
                            canMerge: true,
                            verticalVelocity: 0,
                            buoyancy: 0.1 + Math.random() * 0.2,
                            stage: ctype // label as cirrus family
                        };
                        c.height = c.baseHeight;
                        c.cloudTop = c.baseHeight + 2.0;
                        c.cloudBase = c.baseHeight - 1.0;
                        c.grp.position.set(x, 0, z);
                        this.group.add(c.grp);
                        return c;
                    }
                    return null;
                }

                // Variable width for different cloud types - slightly wider by default
                const widthFactor = 1.1 + Math.random() * 0.8; // 1.1 to 1.9
                
                const c = {
                    x, z, age: 0, 
                    maxAge: 400 + Math.random() * 300,
                    // enforce a safer minimum cloud base so clouds never form close to surface
                    // (place new clouds clearly above terrain/near-surface features)
                    baseHeight: 18 + Math.random() * 6,
                    height: null,      // will be initialized from baseHeight below
                    cloudTop: null,
                    cloudBase: null,
                    puffs: [], 
                    grp: new THREE.Group(), 
                    dying: false,
                    cluster: null,
                    growthRate: 0.025 + Math.random() * 0.025,
                    mass: 0,
                    condensationLevel: 0,
                    turbulence: 0,
                    velocity: { x: 0, z: 0 },
                    targetVelocity: { x: 0, z: 0 },
                    // start with a larger base radius so new clouds form with broader structure
                    radius: 3 + Math.random() * 1.8,
                    widthFactor: widthFactor,
                    horizontalSpread: 1.2,
                    mergeTimer: 0,
                    canMerge: true,
                    verticalVelocity: 0,
                    buoyancy: 0.5 + Math.random() * 0.5,
                    stage: 'cumulus'
                };
                // initialize height fields from baseHeight to ensure cloud tops/bases are above surface
                c.height = c.baseHeight;
                c.cloudTop = c.baseHeight;
                c.cloudBase = Math.max(c.baseHeight - 2.5, 8); // ensure base not below safe threshold
                c.grp.position.set(x, 0, z);
                this.group.add(c.grp);
                return c;
            }

            checkMerge(cloud1, cloud2) {
                const dist = Math.sqrt((cloud1.x - cloud2.x) ** 2 + (cloud1.z - cloud2.z) ** 2);
                const mergeRadius = (cloud1.radius * cloud1.horizontalSpread + cloud2.radius * cloud2.horizontalSpread) * 0.7;
                
                if (dist < mergeRadius && cloud1.canMerge && cloud2.canMerge && 
                    cloud1.age > 50 && cloud2.age > 50 &&
                    Math.abs(cloud1.height - cloud2.height) < 8) {
                    return true;
                }
                return false;
            }

            mergeClouds(cloud1, cloud2) {
                const totalMass = cloud1.mass + cloud2.mass;
                
                // Transfer mass and properties
                cloud1.mass += cloud2.mass * 0.85;
                
                // Merge radii like 3D terrain - additive volume
                const volume1 = Math.PI * cloud1.radius * cloud1.radius * cloud1.horizontalSpread;
                const volume2 = Math.PI * cloud2.radius * cloud2.radius * cloud2.horizontalSpread;
                const totalVolume = volume1 + volume2;
                cloud1.radius = Math.sqrt(totalVolume / (Math.PI * cloud1.horizontalSpread)) * 0.9;
                
                // Average width factors
                cloud1.widthFactor = (cloud1.widthFactor * cloud1.mass + cloud2.widthFactor * cloud2.mass) / totalMass;
                cloud1.horizontalSpread = (cloud1.horizontalSpread + cloud2.horizontalSpread) / 2;
                
                cloud1.maxAge += cloud2.maxAge * 0.4;
                cloud1.condensationLevel = Math.max(cloud1.condensationLevel, cloud2.condensationLevel);
                
                // Smooth position blend (like terrain heightmap merging)
                const blendFactor = cloud2.mass / totalMass;
                cloud1.x = cloud1.x * (1 - blendFactor) + cloud2.x * blendFactor;
                cloud1.z = cloud1.z * (1 - blendFactor) + cloud2.z * blendFactor;
                
                // Blend heights
                cloud1.cloudTop = Math.max(cloud1.cloudTop, cloud2.cloudTop);
                cloud1.cloudBase = Math.min(cloud1.cloudBase, cloud2.cloudBase);
                cloud1.height = cloud1.cloudTop;
                
                // Transfer puffs in a blended manner
                const transferCount = Math.min(8, cloud2.puffs.length);
                for (let i = 0; i < transferCount; i++) {
                    if (cloud2.puffs[i]) {
                        const puff = cloud2.puffs[i];
                        // Adjust puff position relative to new cloud center
                        const offsetX = cloud2.x - cloud1.x;
                        const offsetZ = cloud2.z - cloud1.z;
                        puff.position.x -= offsetX;
                        puff.position.z -= offsetZ;
                        cloud1.puffs.push(puff);
                        cloud1.grp.add(puff);
                    }
                }
                
                // Mark for removal
                cloud2.dying = true;
                cloud2.maxAge = cloud2.age + 10;
                
                // Cooldown
                cloud1.mergeTimer = 150;
                cloud1.canMerge = false;
            }

            update(t) {
                this.timer++;
                
                // Update updrafts
                this.updrafts = this.updrafts.filter(updraft => {
                    updraft.age++;
                    updraft.height = Math.min(updraft.maxHeight, updraft.height + 0.1);
                    if (updraft.age > updraft.maxAge) {
                        updraft.active = false;
                        return false;
                    }
                    return true;
                });
                
                // Update cluster centers
                this.clusterCenters = this.clusterCenters.filter(cluster => {
                    cluster.age++;
                    
                    // Create updraft for mature clusters
                    if (cluster.age === 50 && !cluster.hasUpdraft && Math.random() > 0.3) {
                        this.updrafts.push(this.createUpdraft(cluster.x, cluster.z, 0.8 + Math.random() * 0.4));
                        cluster.hasUpdraft = true;
                    }
                    
                    return cluster.age < cluster.maxAge;
                });
                
                // Spawn new clouds
                if (this.timer % 25 === 0 && this.clouds.length < this.max) {
                    // allow spawn anywhere over the terrain; environmental checks inside grow()
                    const span = 400; // half-size of terrain (matches terrain 800x800)
                    let attempts = 0;
                    let c = null;
                    while (!c && attempts < 5) {
                        const spawnX = (Math.random() * 2 - 1) * span;
                        const spawnZ = (Math.random() * 2 - 1) * span;

                        // Cloud clumping logic using clusters even away from water
                        const nearCluster = this.findNearestCluster(spawnX, spawnZ);

                        if (!nearCluster && Math.random() < 0.3) {
                            this.createCluster(spawnX, spawnZ);
                        }

                        c = this.grow(spawnX, spawnZ);
                        if (c) {
                            c.cluster = nearCluster;
                            this.clouds.push(c);
                        }
                        attempts++;
                    }
                }

                // Check for cloud merging
                for (let i = 0; i < this.clouds.length; i++) {
                    for (let j = i + 1; j < this.clouds.length; j++) {
                        if (this.checkMerge(this.clouds[i], this.clouds[j])) {
                            this.mergeClouds(this.clouds[i], this.clouds[j]);
                            break;
                        }
                    }
                }

                this.clouds = this.clouds.filter(c => {
                    c.age++;
                    
                    // Update merge timer
                    if (c.mergeTimer > 0) {
                        c.mergeTimer--;
                        if (c.mergeTimer === 0) c.canMerge = true;
                    }
                    
                    // Realistic cloud movement
                    const windAt = AppState.windField.getAt(c.x, c.height, c.z);
                    c.targetVelocity.x = windAt.x * 0.5;
                    c.targetVelocity.z = windAt.z * 0.5;
                    
                    // Smooth acceleration
                    c.velocity.x += (c.targetVelocity.x - c.velocity.x) * 0.05;
                    c.velocity.z += (c.targetVelocity.z - c.velocity.z) * 0.05;
                    
                    // Move cloud
                    c.x += c.velocity.x;
                    c.z += c.velocity.z;
                    c.grp.position.x = c.x;
                    c.grp.position.z = c.z;
                    
                    // Add slight drift for mature clouds
                    if (c.mass > 3) {
                        c.x += Math.sin(t * 0.0002 + c.age * 0.01) * 0.02;
                        c.z += Math.cos(t * 0.0002 + c.age * 0.01) * 0.02;
                    }
                    
                    // Enhanced cloud growth system with realistic vertical development
                    const updraftLift = this.getUpdraftAt(c.x, c.z);
                    
                    // Progressive mass accumulation based on condensation
                    // Increase growth rates so precipitation sources become sustained faster and remain active
                    c.mass += 0.03 + c.condensationLevel * 0.05 + updraftLift * 0.05;
                    // Condensation ramps faster to prevent short lived dry windows after formation
                    c.condensationLevel = Math.min(1, c.age / 80);
                    c.turbulence = updraftLift * 0.5;
                    c.radius = 2 + c.mass * 0.8;
                    
                    // Dynamic horizontal spread based on stage - ensure clouds aren't too narrow
                    if (c.stage === 'cumulus') {
                        c.horizontalSpread = 1.1 + c.widthFactor * 0.4;
                    } else if (c.stage === 'towering_cumulus') {
                        c.horizontalSpread = 1.0 + c.widthFactor * 0.35;
                    } else if (c.stage === 'cumulonimbus') {
                        c.horizontalSpread = 1.4 + c.widthFactor * 0.45;
                    } else if (c.stage === 'supercell') {
                        c.horizontalSpread = 1.8 + c.widthFactor * 0.45;
                    } else if (c.stage && c.stage.startsWith('cirr')) {
                        // cirrus family have broad thin sheets with large horizontal spread and low mass growth
                        c.horizontalSpread = 2.0 + c.widthFactor * 1.2;
                        c.mass = Math.max(0.2, c.mass * 0.2 + 0.02);
                    }
                    
                    // Realistic vertical cloud development
                    const temperature = 1 - (c.height / 40);
                    const moisture = c.condensationLevel;
                    
                    // Buoyancy-driven rise
                    c.buoyancy = (temperature * moisture * 0.8 + updraftLift * 1.5) * (1 - c.age / c.maxAge);
                    c.verticalVelocity += c.buoyancy * 0.02;
                    c.verticalVelocity *= 0.96;
                    
                    // Cloud rises
                    c.cloudTop += c.verticalVelocity;
                    c.height = c.cloudTop;
                    
                    // Base rises more slowly
                    if (c.age > 50) {
                        c.cloudBase += c.verticalVelocity * 0.3;
                    }
                    
                    // Determine cloud stage and growth stage with more complex transformations
                    let growthStage = 'developing';
                    const oldStage = c.stage;
                    
                    if (c.cloudTop < 20) {
                        c.stage = 'cumulus';
                        growthStage = 'developing';
                    } else if (c.cloudTop < 30 && c.mass > 2) {
                        c.stage = 'towering_cumulus';
                        growthStage = 'developing_to_mature';
                    } else if (c.cloudTop >= 30 && c.cloudTop < 36 && c.mass > 4) {
                        c.stage = 'cumulonimbus';
                        growthStage = 'mature';
                    } else if (c.cloudTop >= 36 && c.mass > 7 && c.condensationLevel > 0.8) {
                        c.stage = 'supercell';
                        growthStage = 'mature_intense';
                        c.turbulence = Math.max(c.turbulence, 0.6);
                    }
                    
                    // Trigger structural transformation when stage changes
                    if (oldStage !== c.stage && c.puffs.length > 0) {
                        // adjust existing puff opacities/scales for transition
                        const transitionFactor = c.stage === 'supercell' ? 1.2 : (c.stage === 'cumulonimbus' ? 1.1 : 1.0);
                        for (let p = 0; p < Math.min(8, c.puffs.length); p++) {
                            const puff = c.puffs[p];
                            if (puff && puff.material) {
                                puff.material.opacity *= transitionFactor * 0.9;
                                if (puff.scale) puff.scale.multiplyScalar(0.95 + Math.random() * 0.1);
                            }
                        }
                    }

                    // promote to supercell when cumulonimbus is tall, heavy and strongly condensed
                    if (c.stage === 'cumulonimbus' && c.cloudTop > 36 && c.mass > 7 && c.condensationLevel > 0.8) {
                        c.stage = 'supercell';
                        growthStage = 'mature';
                        // supercells have stronger turbulence and broader anvils
                        c.turbulence = Math.max(c.turbulence, 0.6);
                    }
                    
                    if (c.age > c.maxAge * 0.7) {
                        growthStage = 'dissipating';
                        c.stage = 'dissipating';
                    }
                    
                    // Multi-stage growth based on cloud type
                    let effectiveGrowthRate = c.growthRate;
                    if (c.stage === 'cumulus') {
                        effectiveGrowthRate *= (1 + updraftLift * 3);
                    } else if (c.stage === 'towering_cumulus') {
                        effectiveGrowthRate *= (1 + updraftLift * 2);
                    } else if (c.stage === 'cumulonimbus') {
                        effectiveGrowthRate *= (1 + updraftLift * 1.5);
                        if (c.puffs.length % 20 === 0) {
                            const anvilPuff = this.makePuff(
                                (Math.random() - 0.5) * (c.radius + 5),
                                c.cloudTop + 2,
                                (Math.random() - 0.5) * (c.radius + 5),
                                2 + Math.random() * 3,
                                0.2,
                                0
                            );
                            c.puffs.push(anvilPuff);
                            c.grp.add(anvilPuff);
                        }
                    } else if (c.stage === 'supercell') {
                        effectiveGrowthRate *= (1 + updraftLift * 2.2);
                        c.horizontalSpread = 1.8 + c.widthFactor * 0.6;
                        // stronger anvil and overshooting top for supercells
                        if (c.puffs.length % 16 === 0) {
                            const anvilPuff = this.makePuff(
                                (Math.random() - 0.5) * (c.radius + 8),
                                c.cloudTop + 3 + Math.random() * 2,
                                (Math.random() - 0.5) * (c.radius + 8),
                                2.5 + Math.random() * 3.5,
                                0.25,
                                0.4
                            );
                            c.puffs.push(anvilPuff);
                            c.grp.add(anvilPuff);
                        }
                    } else if (c.stage === 'dissipating') {
                        effectiveGrowthRate *= 0.3;
                        c.verticalVelocity *= 0.9;
                    }
                    
                    if (c.age < c.maxAge * 0.75) {
                        // Dynamic puff generation
                        let puffInterval = 5;
                        if (updraftLift > 0.5) puffInterval = 2;
                        else if (updraftLift > 0.3) puffInterval = 3;
                        else if (growthStage === 'mature') puffInterval = 4;
                        
                        if (c.age % puffInterval === 0) {
                            const puffCount = (updraftLift > 0.5 && growthStage === 'developing') ? 3 : (updraftLift > 0.5 ? 2 : 1);
                            
                            for (let p = 0; p < puffCount; p++) {
                                const a = Math.random() * Math.PI * 2;
                                const d = Math.sqrt(c.puffs.length) * 0.6 + Math.random() * 1.5;
                                
                                // Height affected by updraft and stage
                                const baseH = c.height + c.age * effectiveGrowthRate;
                                const h = baseH + updraftLift * 5 + (growthStage === 'mature' ? 2 : 0);
                                
                                const dark = Math.min(0.65, (c.age / 200) + c.condensationLevel * 0.3 + (growthStage === 'mature' ? 0.15 : 0));
                                
                                // Create dense, overlapping structure like real cumulus
                                const layerCount = (growthStage === 'mature' || dark > 0.4) ? 3 : 2;
                                for (let layer = 0; layer < layerCount; layer++) {
                                    const angleOffset = (layer * Math.PI * 2) / layerCount;
                                    const radiusOffset = layer * 0.4;
                                    const heightOffset = layer * 0.6 - 0.3;
                                    
                                    // place puffs using the cloud's current radius and widthFactor so new clouds are broader
                                    const spread = (c.radius * Math.max(1.0, c.widthFactor)) * (0.45 + Math.random() * 0.9);
                                    const radial = spread * (0.6 + Math.random() * 0.6) + radiusOffset + (Math.sqrt(c.puffs.length) * 0.15);
                                    const cloudTypeForPuff = (c.stage && c.stage.startsWith('cirr')) ? c.stage : undefined;
                                    const puff = this.makePuff(
                                        Math.cos(a + angleOffset) * radial,
                                        h + heightOffset,
                                        Math.sin(a + angleOffset) * radial,
                                        1.8 + Math.random() * 2.8 + updraftLift * 1.2 + (growthStage === 'mature' ? 0.8 : 0), 
                                        dark + layer * 0.08,
                                        c.turbulence,
                                        cloudTypeForPuff
                                    );
                                    c.puffs.push(puff);
                                    c.grp.add(puff);
                                }
                                c.height = h;
                            }
                        }
                    }
                    
                    if (c.age > c.maxAge) {
                        c.dying = true;
                        // start a more pronounced dissipation animation: shrink/fade/fall puffs
                        c.puffs.forEach(p => {
                            if (!p) return;
                            // mark for dissipation progress
                            p.userData = p.userData || {};
                            p.userData.dissipate = p.userData.dissipate || (0.02 + Math.random() * 0.04);
                            p.userData.vy = p.userData.vy || (0.002 + Math.random() * 0.004); // gentle fall
                        });
                    }
                    
                    // Enhanced animation with turbulence
                    c.puffs.forEach((p, i) => {
                        if (p) {
                            p.rotation.y += 0.0002 + c.turbulence * 0.0005;
                            p.rotation.z += c.turbulence * 0.0003;
                            
                            // Updraft effect on existing puffs
                            const puffLift = this.getUpdraftAt(c.x, c.z) * 0.01;
                            p.position.y += Math.sin(t * 0.0003 + i) * 0.003 + puffLift;
                            
                            // Turbulent motion
                            if (c.turbulence > 0.2) {
                                p.position.x += Math.sin(t * 0.0005 + i) * c.turbulence * 0.02;
                                p.position.z += Math.cos(t * 0.0005 + i) * c.turbulence * 0.02;
                            }
                            // If cloud is dying, progressively shrink, fade, and fall puffs (dissipation animation)
                            if (c.dying) {
                                const dd = p.userData && p.userData.dissipate ? p.userData.dissipate : 0.03;
                                // fade
                                if (p.material && typeof p.material.opacity === 'number') {
                                    p.material.opacity = Math.max(0, (p.material.opacity || 1) - dd * 0.75);
                                }
                                // shrink
                                if (p.scale) p.scale.multiplyScalar(Math.max(0.985, 1 - dd * 0.8));
                                // fall toward ground
                                const fallVy = p.userData && p.userData.vy ? p.userData.vy : 0.003;
                                p.position.y = Math.max(0.6, p.position.y - fallVy * 6);
                            }
                        }
                    });

                    // If cloud is dying, allow occasional small wispy puff creation to preserve complex residual structure
                    if (c.dying && Math.random() < 0.06) {
                        // spawn a few small, thin puffs that drift and fade (adds structure during dissipation)
                        const tinyCount = 1 + Math.floor(Math.random() * 2);
                        for (let tp = 0; tp < tinyCount; tp++) {
                            const a2 = Math.random() * Math.PI * 2;
                            const radial2 = (c.radius * 0.4) * (0.6 + Math.random() * 0.8);
                            const smallP = this.makePuff(
                                Math.cos(a2) * radial2,
                                c.cloudBase + (Math.random() * 1.5),
                                Math.sin(a2) * radial2,
                                0.6 + Math.random() * 1.2,
                                0.12 + Math.random() * 0.18,
                                Math.min(0.25, c.turbulence * 0.4)
                            );
                            // make it more translucent and short lived
                            if (smallP.material) smallP.material.opacity = 0.28 + Math.random() * 0.12;
                            c.puffs.push(smallP);
                            c.grp.add(smallP);
                        }
                    }
                    
                    if (c.dying && c.puffs[0] && c.puffs[0].material && c.puffs[0].material.opacity < 0.05) {
                        c.puffs.forEach(p => {
                            if (p) {
                                if (p.geometry) p.geometry.dispose();
                                if (p.material) p.material.dispose();
                            }
                        });
                        AppState.cloudSystem.group.remove(c.grp);
                        return false;
                    }
                    
                    return true;
                });
            }

            getMature() {
                // Treat supercell as highest-maturity source as well; only these produce sustained/heavy precipitation
                return this.clouds.filter(c => (c.stage === 'cumulonimbus' || c.stage === 'towering_cumulus' || c.stage === 'supercell') && !c.dying && c.mass > 3);
            }

            // New: return clouds that can source precipitation including dying ones (with weaker effect)
            getPrecipSources() {
                // Return any cloud that can source precipitation.
                // Strong sources: towering convection and above; weak sources: dissipating clouds still holding moisture.
                // We now provide a continuous list including dying clouds (weaker) so precipitation systems can sample them every frame.
                return this.clouds.filter(c => {
                    if (!c) return false;
                    // Any mature deep convection or moderately heavy clouds can precipitate
                    const strongStage = (c.stage === 'cumulonimbus' || c.stage === 'towering_cumulus' || c.stage === 'supercell');
                    const hasMass = c.mass > 1.0;
                    const allowDying = c.dying && c.mass > 0.8;
                    // continuous sources: either strongStage & hasMass or dying but still with mass
                    return (strongStage && hasMass) || allowDying;
                });
            }
        }

        class Precipitation {
            constructor(windFieldRef, cloudSystemRef) {
                this.windFieldRef = windFieldRef;
                this.cloudSystemRef = cloudSystemRef;
                this.max = 3000;
                this.drops = [];
                this.vel = [];
                this.types = [];
                this.enableShafts = true;
                this.cloudShafts = new Map();
                
                const geo = new THREE.BufferGeometry();
                this.pos = new Float32Array(this.max * 3);
                this.sizes = new Float32Array(this.max);
                this.colors = new Float32Array(this.max * 3);
                this.ages = new Float32Array(this.max);
                
                for (let i = 0; i < this.max; i++) {
                    this.drops.push({ active: false });
                    this.vel.push({ y: 0, size: 0 });
                    this.types.push('rain');
                    this.pos[i * 3] = 0;
                    this.pos[i * 3 + 1] = -1000;
                    this.pos[i * 3 + 2] = 0;
                    this.sizes[i] = 0;
                    this.colors[i * 3] = 1;
                    this.colors[i * 3 + 1] = 1;
                    this.colors[i * 3 + 2] = 1;
                    this.ages[i] = 0;
                }

                geo.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                geo.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                geo.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                
                const canvas = document.createElement('canvas');
                canvas.width = 16;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                
                // Enhanced gradient for more defined raindrops
                const grad = ctx.createLinearGradient(0, 0, 0, 48);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.2, 'rgba(230, 245, 255, 0.95)');
                grad.addColorStop(0.5, 'rgba(200, 230, 255, 0.7)');
                grad.addColorStop(0.8, 'rgba(160, 200, 240, 0.4)');
                grad.addColorStop(1, 'rgba(120, 170, 220, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 16, 48);
                
                const mat = new THREE.PointsMaterial({
                    size: 0.8,
                    transparent: true,
                    opacity: 0.95,
                    map: new THREE.CanvasTexture(canvas),
                    depthWrite: false,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });

                this.rain = new THREE.Points(geo, mat);
                AppState.scene.add(this.rain);
                
                this.createStreakSystem();
                this.rainshaftGroup = new THREE.Group();
                AppState.scene.add(this.rainshaftGroup);
            }

            createStreakSystem() {
                this.streakGeometry = new THREE.BufferGeometry();
                const streakPositions = new Float32Array(300 * 6);
                this.streakGeometry.setAttribute('position', new THREE.BufferAttribute(streakPositions, 3));
                
                const streakMaterial = new THREE.LineBasicMaterial({
                    color: 0xaaccff,
                    transparent: true,
                    opacity: 0.4,
                    linewidth: 1.5
                });
                
                this.streakLines = new THREE.LineSegments(this.streakGeometry, streakMaterial);
                AppState.scene.add(this.streakLines);
            }

            resize(newMax) {
                newMax = Math.max(200, Math.min(3000, Math.floor(newMax)));
                if (newMax === this.max) return;
                const oldMax = this.max;
                const oldPos = this.pos;
                const oldSizes = this.sizes;
                const oldColors = this.colors;
                const oldDrops = this.drops;
                const oldVel = this.vel;
                const oldTypes = this.types;

                this.max = newMax;
                this.drops = [];
                this.vel = [];
                this.types = [];
                this.pos = new Float32Array(this.max * 3);
                this.sizes = new Float32Array(this.max);
                this.colors = new Float32Array(this.max * 3);
                this.ages = new Float32Array(this.max);

                for (let i = 0; i < this.max; i++) {
                    if (i < oldMax && oldDrops[i] && oldDrops[i].active) {
                        const idx = i * 3;
                        this.drops.push({ active: true });
                        this.vel.push(oldVel[i]);
                        this.types.push(oldTypes[i]);
                        this.pos[idx] = oldPos[idx];
                        this.pos[idx + 1] = oldPos[idx + 1];
                        this.pos[idx + 2] = oldPos[idx + 2];
                        this.sizes[i] = oldSizes[i];
                        this.colors[idx] = oldColors[idx];
                        this.colors[idx + 1] = oldColors[idx + 1];
                        this.colors[idx + 2] = oldColors[idx + 2];
                    } else {
                        this.drops.push({ active: false });
                        this.vel.push({ y: 0, size: 0 });
                        this.types.push('rain');
                        const idx = i * 3;
                        this.pos[idx] = 0;
                        this.pos[idx + 1] = -1000;
                        this.pos[idx + 2] = 0;
                    }
                }

                this.rain.geometry.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                this.rain.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.rain.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.rain.geometry.attributes.position.needsUpdate = true;
                this.rain.geometry.attributes.size.needsUpdate = true;
                this.rain.geometry.attributes.color.needsUpdate = true;
            }

            getTemperature(altitude) {
                const seaLevelTemp = 15;
                const lapseRate = 6.5;
                return seaLevelTemp - (altitude / 1000) * lapseRate;
            }

            determinePrecipType(temperature, altitude) {
                if (temperature < -8) {
                    return 'snow';
                } else if (temperature < -2 && altitude > 14) {
                    return 'sleet';
                } else if (temperature < 1 && Math.random() < 0.25) {
                    return 'freezing_rain';
                } else {
                    return 'rain';
                }
            }

            spawn(cloud) {
                if (!cloud) return;
                // Only heavy precipitation for towering cumulus, cumulonimbus, supercell.
                // Cumulus may produce occasional light precip (low probability).
                const stage = cloud.stage || 'cumulus';
                if (stage === 'cumulus' && Math.random() > 0.06) return; // ~6% chance for light rain from ordinary cumulus
                if (stage === 'towering_cumulus' && Math.random() > 0.45) {
                    // towering cumulus will sometimes produce moderate showers; let ~55% pass
                    return;
                }
                const cx = cloud.x;
                const cz = cloud.z;
                const h = cloud.height - 1;
                const radius = Math.max(6, cloud.radius * 0.85);

                const env = sampleEnvironment(cx, cz, 0);
                if (env.humidity < 0.35) return;

                const heightFactor = Math.max(0.8, 1 + (cloud.height - 12) * 0.06);
                const maturityFactor = Math.min(2.2, 0.6 + cloud.condensationLevel * 1.6);
                // stage multiplier: cumulus (light) < towering_cumulus (moderate) < cumulonimbus (strong) < supercell (very strong)
                let stageFactor = 0.35; // default for very weak sources (should rarely reach here)
                if (stage === 'cumulus') stageFactor = 0.25;
                else if (stage === 'towering_cumulus') stageFactor = 0.9;
                else if (stage === 'cumulonimbus') stageFactor = 1.3;
                else if (stage === 'supercell') stageFactor = 1.8;

                // Spawn more frequently and larger drops for higher stageFactor
                for (let i = 0; i < this.max; i++) {
                    if (!this.drops[i].active) {
                        const idx = i * 3;
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * radius;
                        this.pos[idx] = cx + Math.cos(angle) * r;
                        this.pos[idx + 1] = h;
                        this.pos[idx + 2] = cz + Math.sin(angle) * r;
                        
                        const temp = this.getTemperature(h);
                        const precipType = this.determinePrecipType(temp, h);
                        this.types[i] = precipType;
                        
                        // size and speed scaled strongly by stageFactor and maturity
                        const sizeMult = heightFactor * maturityFactor * stageFactor;
                        let s, fallSpeed, color;

                        if (precipType === 'snow') {
                            s = (1.4 + Math.random() * 2.2) * sizeMult;
                            fallSpeed = (0.08 + (s / 4) * 0.1) * (1.6 + Math.random() * 0.4);
                            color = { r: 1.0, g: 1.0, b: 1.0 };
                        } else if (precipType === 'sleet') {
                            s = (0.9 + Math.random() * 1.4) * sizeMult;
                            fallSpeed = (0.18 + (s / 3) * 0.32) * (1.7 + Math.random() * 0.3);
                            color = { r: 0.92, g: 0.96, b: 1.0 };
                        } else if (precipType === 'freezing_rain') {
                            s = (0.8 + Math.random() * 2.2) * sizeMult;
                            fallSpeed = (0.22 + (s / 3) * 0.4) * (1.8 + Math.random() * 0.4);
                            color = { r: 0.75, g: 0.88, b: 1.0 };
                        } else {
                            // rain: make drops larger and faster for towering/cb/supercell
                            s = (0.9 + Math.random() * 3.6) * sizeMult;
                            fallSpeed = (0.32 + (s / 3) * 0.6) * (2.2 + Math.random() * 0.8);
                            color = { r: 0.86, g: 0.94, b: 1.0 };
                        }
                        
                        this.vel[i] = { y: fallSpeed, size: s };
                        // scale visual size differently for heavy precip
                        this.sizes[i] = s * (0.22 + Math.min(0.6, stageFactor * 0.18));
                        this.colors[idx] = color.r;
                        this.colors[idx + 1] = color.g;
                        this.colors[idx + 2] = color.b;
                        this.ages[i] = 0;
                        this.drops[i] = { active: true };
                        break;
                    }
                }
            }

            update() {
                // include dying clouds as weaker precipitation sources
                const sources = this.cloudSystemRef.getPrecipSources ? this.cloudSystemRef.getPrecipSources() : this.cloudSystemRef.getMature();
                
                // Track and clean up rainshafts for dead clouds
                for (const [cloud, shaftObj] of this.cloudShafts) {
                    if (!cloud || cloud.dying || !cloud.grp) {
                        if (shaftObj) {
                            this.rainshaftGroup.remove(shaftObj);
                            if (shaftObj.geometry) shaftObj.geometry.dispose();
                            if (shaftObj.material) shaftObj.material.dispose();
                        }
                        this.cloudShafts.delete(cloud);
                    }
                }

                if (sources.length > 0) {
                    // Iterate sources and produce continuous precipitation proportional to cloud properties.
                    sources.forEach((c) => {
                        if (!c) return;
                        // compute continuous intensity from cloud phys props (height, mass, condensation, stage)
                        const heightFactor = Math.max(0.9, 1 + (c.height - 12) * 0.05);
                        const maturityFactor = Math.min(2.5, 0.5 + c.condensationLevel * 2.0);
                        let stageFactor = 0.35;
                        if (c.stage === 'towering_cumulus') stageFactor = 0.9;
                        else if (c.stage === 'cumulonimbus') stageFactor = 1.3;
                        else if (c.stage === 'supercell') stageFactor = 1.9;
                        // dying clouds contribute but much weaker
                        const dyingFactor = c.dying ? 0.22 : 1.0;
                        // incorporate turbulence/updraft to bias charge of droplet formation and size
                        const turbFactor = 1 + (c.turbulence || 0) * 0.8;
                        // final intensity 0..~2
                        const intensity = Math.max(0, Math.min(2.2, (c.mass / 5) * maturityFactor * heightFactor * stageFactor * dyingFactor * turbFactor));
                        
                        // visual shaft parameters
                        const shaftRadius = Math.max(4.5, c.radius * 0.9 * Math.sqrt(1 + c.condensationLevel * 0.6));
                        const shaftHeight = Math.max(1.6, c.height - 0.3);

                        // ensure a shaft object exists and follows the cloud (cloud dissipation will fade it)
                        if (this.enableShafts && intensity > 0.06 && shaftHeight > 1.5) {
                            let shaftObj = this.cloudShafts.get(c);
                            if (!shaftObj) {
                                const pcnt = 160;
                                const pGeo = new THREE.BufferGeometry();
                                const pPos = new Float32Array(pcnt * 3);
                                for (let pi = 0; pi < pcnt; pi++) {
                                    pPos[pi*3] = c.x;
                                    pPos[pi*3+1] = -1000;
                                    pPos[pi*3+2] = c.z;
                                }
                                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                                const baseCol = new THREE.Color(0xaaccff);
                                const pMat = new THREE.PointsMaterial({
                                    size: 0.32,
                                    color: baseCol,
                                    transparent: true,
                                    opacity: Math.min(0.5, 0.18 + intensity * 0.44) * (c.dying ? 0.6 : 1.0),
                                    depthWrite: false,
                                    blending: THREE.NormalBlending
                                });
                                shaftObj = new THREE.Points(pGeo, pMat);
                                // store deterministic seed and breathing parameters rather than relying on per-frame random fills
                                shaftObj.userData = { life: 1.0, baseCol, offsetY: 0.0, vy: 0.003 + Math.random() * 0.006, pulse: intensity, cloudRef: c, seed: Math.random()*1000, swirl: 0.08 + Math.random()*0.18 };
                                this.cloudShafts.set(c, shaftObj);
                                this.rainshaftGroup.add(shaftObj);
                            }
                            // populate shaft in cloud-local positions so it follows cloud when cloud moves
                            // deterministic procedural fill (time-driven) so updates remain animated and not frozen by logic
                            const pArr = shaftObj.geometry.attributes.position.array;
                            const pcnt = pArr.length / 3;
                            const timePhase = performance.now() * 0.0006 + (shaftObj.userData.seed || 0);
                            for (let pi = 0; pi < pcnt; pi++) {
                                // banding and slow swirl provide continuous motion
                                const band = (pi % 3);
                                const bandFrac = band === 0 ? 0.82 : (band === 1 ? 0.48 : 0.14);
                                const y = Math.max(0.6, bandFrac * shaftHeight) + Math.sin(timePhase + pi * 0.023) * 0.06 + (shaftObj.userData.offsetY || 0);
                                const swirl = Math.sin(timePhase * (0.9 + band * 0.12) + pi * 0.09) * (shaftObj.userData.swirl || 0.12);
                                const rrand = (0.65 + 0.35 * Math.sin(timePhase * 0.7 + pi * 0.031)) * shaftRadius * (0.68 + 0.48 * ((pi % 7)/7));
                                const ang = (pi * 0.371 + swirl) % (Math.PI * 2);
                                pArr[pi*3] = c.x + Math.cos(ang) * rrand + (Math.sin(timePhase + pi) * 0.02);
                                pArr[pi*3+1] = y;
                                pArr[pi*3+2] = c.z + Math.sin(ang) * rrand + (Math.cos(timePhase + pi) * 0.02);
                            }
                            shaftObj.geometry.attributes.position.needsUpdate = true;
                            // keep shaft positioned at world origin (points are absolute), but store pulse for animation
                            shaftObj.material.opacity = Math.min(0.75, 0.18 + intensity * 0.5) * (c.dying ? 0.55 : 1.0);
                            shaftObj.userData.pulse = intensity * (1 + c.condensationLevel * 0.6);
                            // breathing offset reacts to updraft and creates gentle continuous vertical motion
                            const updraftLocal = (AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(c.x, c.z) : 0);
                            shaftObj.userData.offsetY = Math.sin(performance.now() * 0.0013 + (shaftObj.userData.seed || 0)) * (0.18 + updraftLocal * 0.8) + (shaftObj.userData.offsetY * 0.92 || 0);
                        }

                        // Continuous drop spawn: spawn count scales with intensity and cloud area.
                        // heavier storms spawn many drops per frame, light/ dying clouds spawn only a few.
                        const areaFactor = Math.max(0.6, (c.radius * c.horizontalSpread) / 6);
                        // base spawn count (clamped)
                        const spawnBase = Math.floor(Math.min(60, Math.max(1, intensity * 18 * areaFactor)));
                        // dying clouds further reduce spawn rate
                        const spawnMultiplier = c.dying ? (0.14 + Math.random() * 0.26) : (0.7 + Math.random() * 0.6);
                        const totalToSpawn = Math.max(1, Math.floor(spawnBase * spawnMultiplier));

                        for (let s = 0; s < totalToSpawn; s++) {
                            this.spawn(c);
                        }
                    });
                }

                let active = 0;
                let streakIdx = 0;
                const streakPos = this.streakGeometry.attributes.position.array;
                
                for (let i = 0; i < this.max; i++) {
                    if (!this.drops[i].active) continue;
                    
                    const idx = i * 3;
                    const altitude = this.pos[idx + 1];
                    const w = this.windFieldRef.getAt(this.pos[idx], altitude, this.pos[idx + 2]);
                    
                    const oldY = altitude;
                    
                    let windResistance = 1.0;
                    if (this.types[i] === 'snow') {
                        windResistance = 3.5;
                    } else if (this.types[i] === 'sleet') {
                        windResistance = 1.8;
                    } else if (this.types[i] === 'freezing_rain') {
                        windResistance = 0.8;
                    }
                    
                    this.pos[idx + 1] -= this.vel[i].y;
                    this.pos[idx] += w.x * windResistance * (0.8 / (this.vel[i].size + 0.1));
                    this.pos[idx + 2] += w.z * windResistance * (0.8 / (this.vel[i].size + 0.1));
                    
                    this.ages[i]++;
                    
                    const currentTemp = this.getTemperature(altitude);
                    
                    if (this.types[i] === 'snow' && currentTemp > 3 && altitude < 8) {
                        this.types[i] = 'rain';
                        this.vel[i].y = 0.4 + (this.vel[i].size / 3) * 0.6;
                        this.colors[idx] = 0.88;
                        this.colors[idx + 1] = 0.94;
                        this.colors[idx + 2] = 1.0;
                    }
                    
                    if (streakIdx < 300 && this.vel[i].y > 0.6 && Math.random() < 0.2 && this.types[i] !== 'snow') {
                        const si = streakIdx * 6;
                        streakPos[si] = this.pos[idx];
                        streakPos[si + 1] = oldY;
                        streakPos[si + 2] = this.pos[idx + 2];
                        streakPos[si + 3] = this.pos[idx];
                        streakPos[si + 4] = this.pos[idx + 1];
                        streakPos[si + 5] = this.pos[idx + 2];
                        streakIdx++;
                    }
                    
                    if (this.pos[idx + 1] < 0.5 || this.ages[i] > 800) {
                        this.drops[i].active = false;
                        this.pos[idx] = 0;
                        this.pos[idx + 1] = -1000;
                        this.pos[idx + 2] = 0;
                        this.sizes[i] = 0;
                    } else {
                        active++;
                    }
                }
                
                for (let i = streakIdx * 6; i < 300 * 6; i++) {
                    streakPos[i] = 0;
                }

                this.rain.geometry.attributes.position.needsUpdate = true;
                this.rain.geometry.attributes.size.needsUpdate = true;
                this.rain.geometry.attributes.color.needsUpdate = true;
                this.streakGeometry.attributes.position.needsUpdate = true;
                return active;
            }
        }

        class Lightning {
            constructor(cloudSystemRef) {
                this.cloudSystemRef = cloudSystemRef;
                this.bolts = [];
                this.charge = 0;
                // Raise threshold and make accumulation slower so strikes are less frequent
                this.threshold = 220;
                this.last = 0;
                this.count = 0;
                this.flash = new THREE.PointLight(0xddeeff, 0, 200);
                AppState.scene.add(this.flash);
                this.enabled = true;
                // store per-cloud charge reservoirs
                this._cloudCharge = new WeakMap();
            }

            createSteppedLeader(sx, sy, sz, ex, ey, ez) {
                const segments = [];
                const steps = 25 + Math.floor(Math.random() * 10);
                let currentX = sx, currentY = sy, currentZ = sz;
                
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const targetX = sx + (ex - sx) * t;
                    const targetY = sy + (ey - sy) * t - Math.pow(t, 1.5) * 5;
                    const targetZ = sz + (ez - sz) * t;
                    
                    // Stepped leader movement
                    const stepSize = 2 + Math.random() * 3;
                    const chaos = (1 - Math.abs(t - 0.5) * 2) * 6;
                    
                    currentX += (targetX - currentX) * 0.3 + (Math.random() - 0.5) * chaos;
                    currentY += (targetY - currentY) * 0.3 + (Math.random() - 0.5) * stepSize;
                    currentZ += (targetZ - currentZ) * 0.3 + (Math.random() - 0.5) * chaos;
                    
                    segments.push(new THREE.Vector3(currentX, currentY, currentZ));
                }
                
                return segments;
            }

            createBranch(originPoint, depth = 0, maxDepth = 3) {
                if (depth >= maxDepth || Math.random() > 0.7) return;
                
                const branches = 1 + Math.floor(Math.random() * 2);
                
                for (let b = 0; b < branches; b++) {
                    const branchLength = 8 + Math.random() * 12 * (1 - depth / maxDepth);
                    const branchSteps = 6 + Math.floor(Math.random() * 6);
                    const branchPoints = [];
                    
                    let bx = originPoint.x;
                    let by = originPoint.y;
                    let bz = originPoint.z;
                    
                    const angleH = Math.random() * Math.PI * 2;
                    const angleV = (Math.random() - 0.3) * Math.PI * 0.5;
                    
                    for (let i = 0; i <= branchSteps; i++) {
                        const t = i / branchSteps;
                        const len = branchLength * t;
                        
                        bx += Math.cos(angleH) * Math.cos(angleV) * (branchLength / branchSteps) + (Math.random() - 0.5) * 2;
                        by -= Math.sin(angleV) * (branchLength / branchSteps) + Math.random() * 1.5;
                        bz += Math.sin(angleH) * Math.cos(angleV) * (branchLength / branchSteps) + (Math.random() - 0.5) * 2;
                        
                        branchPoints.push(new THREE.Vector3(bx, by, bz));
                    }
                    
                    const opacity = 0.7 - depth * 0.15;
                    const branchGeom = new THREE.BufferGeometry().setFromPoints(branchPoints);
                    const branchMat = new THREE.LineBasicMaterial({
                        color: 0xccddff,
                        transparent: true,
                        opacity: opacity,
                        linewidth: 2
                    });
                    
                    const branch = new THREE.Line(branchGeom, branchMat);
                    branch.userData.life = 0.9 - depth * 0.1;
                    AppState.scene.add(branch);
                    this.bolts.push(branch);
                    
                    // Recursive branching
                    if (Math.random() > 0.5) {
                        this.createBranch(branchPoints[Math.floor(branchPoints.length / 2)], depth + 1, maxDepth);
                    }
                }
            }

            makeBolt(sx, sy, sz, ex, ey, ez) {
                // Main channel with stepped leader
                const mainPath = this.createSteppedLeader(sx, sy, sz, ex, ey, ez);
 
                // Create multi-width core stroke (main + wider glow) for visual depth
                const mainGeom = new THREE.BufferGeometry().setFromPoints(mainPath);
                const mainMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1,
                    linewidth: 3
                });
                const mainBolt = new THREE.Line(mainGeom, mainMat);
                mainBolt.userData.life = 1.0;
                mainBolt.userData.isMain = true;
                AppState.scene.add(mainBolt);
                this.bolts.push(mainBolt);

                // layered glow / bloom lines for thickness and temporal variance
                const glowGeom = new THREE.BufferGeometry().setFromPoints(mainPath);
                const glowMat = new THREE.LineBasicMaterial({
                    color: 0x9fe6ff,
                    transparent: true,
                    opacity: 0.45,
                    linewidth: 9
                });
                const glow = new THREE.Line(glowGeom, glowMat);
                glow.userData.life = 0.9;
                AppState.scene.add(glow);
                this.bolts.push(glow);

                // subtle corona points along path to simulate plasma beads / return-stroke brightness
                const pts = new THREE.BufferGeometry();
                const ptArr = new Float32Array(mainPath.length * 3);
                for (let i = 0; i < mainPath.length; i++) {
                    ptArr[i*3] = mainPath[i].x + (Math.random()-0.5)*0.6;
                    ptArr[i*3+1] = mainPath[i].y + (Math.random()-0.5)*0.6;
                    ptArr[i*3+2] = mainPath[i].z + (Math.random()-0.5)*0.6;
                }
                pts.setAttribute('position', new THREE.BufferAttribute(ptArr, 3));
                const beadMat = new THREE.PointsMaterial({ size: 1.6, color: 0xeefcff, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending });
                const beads = new THREE.Points(pts, beadMat);
                beads.userData.life = 0.65;
                AppState.scene.add(beads);
                this.bolts.push(beads);

                // Create complex branching from multiple points with variable depth & jittered directions
                const sampleCount = Math.max(3, Math.floor(mainPath.length * 0.18));
                for (let bI = 0; bI < sampleCount; bI++) {
                    const idx = Math.floor((bI / sampleCount) * mainPath.length * (0.6 + Math.random() * 0.6));
                    if (Math.random() > 0.25) {
                        // add small jittered forks and allow deeper recursion occasionally
                        this.createBranch(mainPath[Math.max(1, Math.min(mainPath.length-2, idx))], 0, 2 + (Math.random() < 0.18 ? 1 : 0));
                    }
                }

                // Multi-segment return stroke: quick brightening pulses along core with small delays
                const pulseCount = 1 + Math.floor(Math.random() * 2);
                for (let p = 0; p < pulseCount; p++) {
                    setTimeout(() => {
                        if (mainBolt && mainBolt.material) {
                            mainBolt.material.opacity = 1.2;
                        }
                        if (glow && glow.material) glow.material.opacity = Math.min(1.0, glow.material.opacity + 0.35);
                        // emit some transient sparks (tiny particles) near the bottom of the bolt
                        const sparkGeo = new THREE.BufferGeometry();
                        const sc = 28 + Math.floor(Math.random() * 24);
                        const sPos = new Float32Array(sc * 3);
                        for (let si = 0; si < sc; si++) {
                            const t = Math.random();
                            const pt = mainPath[Math.floor(t * (mainPath.length-1))];
                            sPos[si*3] = pt.x + (Math.random()-0.5) * 3.2;
                            sPos[si*3+1] = pt.y + (Math.random()-0.5) * 2.2;
                            sPos[si*3+2] = pt.z + (Math.random()-0.5) * 3.2;
                        }
                        sparkGeo.setAttribute('position', new THREE.BufferAttribute(sPos, 3));
                        const sparkMat = new THREE.PointsMaterial({ size: 0.9, color: 0xfff9f3, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending });
                        const sparks = new THREE.Points(sparkGeo, sparkMat);
                        sparks.userData = { life: 0.28 + Math.random() * 0.24 };
                        AppState.scene.add(sparks);
                        this.bolts.push(sparks);
                        setTimeout(() => {
                            // quick fade
                            if (mainBolt && mainBolt.material) mainBolt.material.opacity = Math.max(0.0, (mainBolt.material.opacity || 1) - 0.6);
                            if (glow && glow.material) glow.material.opacity *= 0.6;
                        }, 60 + Math.random() * 120);
                    }, 30 * p + Math.random() * 90);
                }
            }

            // New helper to pulse multiple strikes quickly (count >=1)
            pulseStrike(sx, sy, sz, ex, ey, ez, count = 2, spacingMs = 90) {
                // immediate strike
                this.makeBolt(sx, sy, sz, ex, ey, ez);
                // schedule additional quick pulses with slight jitter
                for (let p = 1; p < count; p++) {
                    setTimeout(() => {
                        const jitter = (p * 0.6);
                        const ox = (Math.random() - 0.5) * 6 * jitter;
                        const oz = (Math.random() - 0.5) * 6 * jitter;
                        const oy = (Math.random() - 0.5) * 2 * jitter;
                        this.makeBolt(sx + ox, sy + oy, sz + oz, ex + (Math.random()-0.5)*8, ey + (Math.random()-0.5)*1.2, ez + (Math.random()-0.5)*8);
                    }, spacingMs * p);
                }
            }

            strike() {
                if (!this.enabled) return;
                const mature = this.cloudSystemRef.getMature();
                if (mature.length === 0) return;
                
                const c = mature[Math.floor(Math.random() * mature.length)];
                const sx = c.x + (Math.random() - 0.5) * 10;
                const sz = c.z + (Math.random() - 0.5) * 10;
                
                // decide pulse count (2..4) biased by cloud intensity
                const basePulse = (c.mass > 7 || c.stage === 'supercell') ? 3 : 2;
                const pulseCount = basePulse + Math.floor(Math.random() * 2);

                // Cloud-to-ground strike(s) using pulseStrike
                this.pulseStrike(
                    sx, c.height + 5, sz,
                    sx + (Math.random() - 0.5) * 25, 0.5, sz + (Math.random() - 0.5) * 25,
                    pulseCount,
                    90
                );
                
                // Occasional cloud-to-cloud pulsing
                if (Math.random() > 0.6 && mature.length > 1) {
                    const c2 = mature[Math.floor(Math.random() * mature.length)];
                    this.pulseStrike(
                        sx, c.height + 3, sz,
                        c2.x + (Math.random() - 0.5) * 8, c2.height + 2, c2.z + (Math.random() - 0.5) * 8,
                        Math.max(2, Math.floor(pulseCount / 1.5)),
                        110
                    );
                }
                
                this.flash.intensity = 35;
                this.flash.position.set(sx, c.height, sz);
                this.count++;
                this.last = performance.now();
                
                // Distance-based camera shake: scale by how close camera is to strike
                const cam = AppState.camera.position;
                const dist = Math.sqrt((sx - cam.x)**2 + (c.height - cam.y)**2 + (sz - cam.z)**2);
                const maxDist = 150;
                const proximity = Math.max(0, 1 - dist / maxDist); // 0..1
                const baseIntensity = 0.5 + proximity * 4.0; // scales from 0.5 to 4.5 depending on distance
                
                const s = 1.2 + baseIntensity * 2.5;
                AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, s);
                AppState.cameraControls.shake.duration = Math.max(AppState.cameraControls.shake.duration, 600);
                AppState.cameraControls.shake.time = 0;
            }

            update(t) {
                if (!this.enabled) {
                    // decay existing bolts quickly
                    this.bolts.forEach(b => b.userData && (b.userData.life -= 0.08));
                }
                const mature = this.cloudSystemRef.getMature();

                // Per-cloud charge separation model:
                // Each cloud accumulates a bipolar reservoir proportional to mass, condensation and updraft/turbulence.
                let totalCharge = 0;
                for (const c of this.cloudSystemRef.clouds) {
                    if (!c) continue;
                    // Only accumulate charge for deep convective storms (cumulonimbus and supercell)
                    if (c.stage !== 'cumulonimbus' && c.stage !== 'supercell') {
                        // ensure weaker clouds don't retain large charge reservoirs
                        const prevZero = this._cloudCharge.get(c) || 0;
                        const decayed = prevZero * 0.92;
                        this._cloudCharge.set(c, decayed);
                        // include small decayed residual but primarily ignore for global potential
                        totalCharge += Math.abs(decayed) * 0.12;
                        continue;
                    }
                    // compute local separation tendency for qualifying clouds
                    const updraft = (AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(c.x, c.z) : 0);
                    const separation = (c.mass || 0) * (c.condensationLevel || 0) * (0.4 + (c.turbulence || 0)) * (1 + updraft * 0.8);
                    // sign: positive for main convective cores, reduce sign for dissipating clouds
                    const sign = c.dying ? -0.4 : 1.0;
                    const prev = this._cloudCharge.get(c) || 0;
                    // accumulate with slight randomness for variability
                    const delta = separation * 0.035 * (0.65 + Math.random() * 0.5) * sign;
                    const newCharge = prev * 0.96 + delta;
                    this._cloudCharge.set(c, newCharge);
                    totalCharge += Math.abs(newCharge);
                }

                // global charge is aggregated absolute reservoir (mimics region-wide potential)
                // reduce scaling so totalCharge must accumulate longer to reach threshold
                this.charge = Math.max(0, Math.min(1000, totalCharge * 3.0));

                // Attempt discharge if threshold exceeded and mature convection present
                // NOTE: cooldown requirement reduced so strikes can happen as soon as charge condition meets threshold
                if (this.charge > this.threshold && mature.length > 0) {
                    // choose a cloud with high local charge to strike from
                    let sourceCloud = null;
                    let bestCharge = 0;
                    for (const c of this.cloudSystemRef.clouds) {
                        const qc = Math.abs(this._cloudCharge.get(c) || 0);
                        if (qc > bestCharge) { bestCharge = qc; sourceCloud = c; }
                    }
                    if (sourceCloud && Math.random() > 0.35) {
                        // Prefer CG strikes if cloud has strong positive reservoir else attempt inter-cloud
                        const sx = sourceCloud.x + (Math.random() - 0.5) * 12;
                        const sz = sourceCloud.z + (Math.random() - 0.5) * 12;
                        // decide pulse count based on local charge and cloud intensity
                        const basePulse = (sourceCloud.mass > 7 || sourceCloud.stage === 'supercell') ? 3 : 2;
                        // bias to more pulses when charge is large
                        const pulseCount = basePulse + Math.floor(Math.random() * (1 + Math.min(3, Math.floor(Math.abs(bestCharge) / 4))));
                        if (Math.random() < 0.66) {
                            // cloud-to-ground pulsing
                            this.pulseStrike(
                                sx, sourceCloud.height + 4 + Math.random() * 6, sz,
                                sx + (Math.random() - 0.5) * 20, 0.5, sz + (Math.random() - 0.5) * 20,
                                pulseCount,
                                90
                            );
                        } else {
                            const targets = this.cloudSystemRef.clouds.filter(cc => cc !== sourceCloud && Math.hypot(cc.x - sourceCloud.x, cc.z - sourceCloud.z) < 120);
                            if (targets.length > 0) {
                                const c2 = targets[Math.floor(Math.random() * targets.length)];
                                this.pulseStrike(
                                    sx, sourceCloud.height + 3, sz,
                                    c2.x + (Math.random() - 0.5) * 8, c2.height + 2, c2.z + (Math.random() - 0.5) * 8,
                                    Math.max(2, Math.floor(pulseCount / 1.5)),
                                    110
                                );
                            } else {
                                // fallback ground pulsing
                                this.pulseStrike(
                                    sx, sourceCloud.height + 4, sz,
                                    sx + (Math.random() - 0.5) * 20, 0.5, sz + (Math.random() - 0.5) * 20,
                                    pulseCount,
                                    100
                                );
                            }
                        }

                        // On strike: clear the main cloud's charge and reduce neighbors.
                        const prevSrc = this._cloudCharge.get(sourceCloud) || 0;
                        this._cloudCharge.set(sourceCloud, 0);
                        for (const nb of this.cloudSystemRef.clouds) {
                            if (!nb || nb === sourceCloud) continue;
                            const d = Math.hypot(nb.x - sourceCloud.x, nb.z - sourceCloud.z);
                            if (d < 180) {
                                const factor = Math.max(0, 1 - d / 180);
                                const prev = this._cloudCharge.get(nb) || 0;
                                this._cloudCharge.set(nb, prev * (1 - 0.7 * factor));
                            }
                        }

                        this.flash.intensity = 35;
                        this.flash.position.set(sx, sourceCloud.height, sz);
                        this.count++;
                        this.last = performance.now();

                        // camera shake scaled to strike proximity & the charge strength
                        const cam = AppState.camera.position;
                        const dist = Math.sqrt((sx - cam.x)**2 + (sourceCloud.height - cam.y)**2 + (sz - cam.z)**2);
                        const maxDist = 180;
                        const proximity = Math.max(0, 1 - dist / maxDist);
                        const baseIntensity = 0.8 + proximity * 3.6;
                        const s = 1.0 + baseIntensity * (Math.min(5, Math.abs(bestCharge)) / 4.0);
                        AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, s);
                        AppState.cameraControls.shake.duration = Math.max(AppState.cameraControls.shake.duration, 700);
                        AppState.cameraControls.shake.time = 0;
                    }
                }

                // Flash decay and bolt life update same as before
                this.flash.intensity *= 0.75;

                // update bolts and transient spark particles with type-aware fading/size pulsing
                for (let i = this.bolts.length - 1; i >= 0; i--) {
                    const b = this.bolts[i];
                    if (!b || !b.userData) continue;
                    // different decay for lines vs points
                    const isLine = b.type && b.type.indexOf('Line') >= 0;
                    const fadeSpeed = (b.userData.isMain ? 0.14 : (b.userData.life ? 0.12 : 0.08));
                    b.userData.life -= fadeSpeed * (isLine ? 1.0 : 0.9);
                    // gentle flicker for glow
                    if (b.material) {
                        const flick = 1 + (Math.random() - 0.5) * 0.08;
                        b.material.opacity = Math.max(0, (b.material.opacity || 1) * (0.92 + 0.06 * (b.userData.life || 0)) * flick);
                    }
                    if ((b.userData.life || 0) <= 0) {
                        AppState.scene.remove(b);
                        if (b.geometry) b.geometry.dispose();
                        if (b.material) b.material.dispose();
                        this.bolts.splice(i, 1);
                    } else {
                        // animate small sparks points to drift/fall slightly
                        if (b.type && b.type.indexOf('Points') >= 0 && b.geometry && b.geometry.attributes.position) {
                            const arr = b.geometry.attributes.position.array;
                            for (let k = 0; k < arr.length; k += 3) {
                                arr[k] += (Math.random() - 0.5) * 0.02 * (1 + (1 - b.userData.life));
                                arr[k+1] -= 0.02 * (0.5 + Math.random() * 0.6) * (1 - b.userData.life);
                                arr[k+2] += (Math.random() - 0.5) * 0.02 * (1 + (1 - b.userData.life));
                            }
                            b.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }
            }
        }

        // Rainbow visual system (optical arcs tied to sun position & moisture)
        class RainbowSystem {
            constructor() {
                this.enabled = true;
                this.arcs = new THREE.Group();
                AppState.scene.add(this.arcs);
                this.sunDir = new THREE.Vector3(1, 1, 0).normalize();
                this.persistent = []; // keep light-weight line/mesh artifacts
            }

            update(t) {
                if (!this.enabled) {
                    // fade and clear
                    this.arcs.traverse(o => {
                        if (o.material) {
                            o.material.opacity *= 0.88;
                        }
                    });
                    // remove fully faded
                    this.arcs.children = this.arcs.children.filter(c => (c.material && c.material.opacity > 0.02) || !c.material);
                    return;
                }

                // Rainbows require sun behind the camera and moisture in front (use low-level downburst / rain shaft density)
                // We compute a simple proxy: average shaft opacity and recent precipitation presence
                let moistureScore = 0;
                if (AppState.rainSystem) {
                    // look at a subset of shafts or drops to approximate humidity columns
                    if (AppState.rainSystem.cloudShafts) {
                        for (const [cloud, shaft] of AppState.rainSystem.cloudShafts) {
                            if (!shaft || !shaft.material) continue;
                            moistureScore += shaft.material.opacity || 0;
                        }
                    }
                    // also consider rain drops count
                    const activeDrops = AppState.rainSystem ? AppState.rainSystem.max - AppState.rainSystem.drops.filter(d=>!d.active).length : 0;
                    moistureScore += Math.min(1, activeDrops / 800);
                }

                // Get sun direction from scene directional light (sun)
                const sunObj = AppState.scene.children.find(o => o && o.isDirectionalLight);
                if (sunObj) {
                    this.sunDir.copy(sunObj.position).normalize();
                }

                // Determine if viewing geometry supports rainbow (sun low behind camera approx)
                const camVec = new THREE.Vector3();
                AppState.camera.getWorldDirection(camVec);
                // rainbow forms opposite the sun relative to camera: check dot between sunDir and cam forward, want sun behind camera (dot < -0.2)
                const sunBehind = this.sunDir.dot(camVec) < -0.2;

                // spawn or update arcs if moisture is sufficient and sun is behind
                if (moistureScore > 0.18 && sunBehind) {
                    // build 1 or 2 arcs based on intensity
                    const arcCount = moistureScore > 0.6 ? 2 : 1;
                    // reuse or create arcs
                    while (this.arcs.children.length < arcCount) {
                        const ring = this._createRainbowArc();
                        this.arcs.add(ring);
                    }

                    // update position/orientation to be centered opposite sun and at a comfortable distance
                    const baseDir = this.sunDir.clone().negate().setY(0).normalize();
                    const up = new THREE.Vector3(0,1,0);
                    const right = new THREE.Vector3().crossVectors(up, baseDir).normalize();
                    const center = new THREE.Vector3().copy(AppState.camera.position).add(baseDir.clone().multiplyScalar(140)).setY(24);

                    for (let i = 0; i < this.arcs.children.length; i++) {
                        const arc = this.arcs.children[i];
                        const scale = 1.0 + i * 0.35;
                        arc.position.copy(center);
                        arc.lookAt(AppState.camera.position);
                        arc.scale.setScalar(1.0 + i * 0.18);
                        arc.material.opacity = Math.min(0.95, (0.22 + moistureScore * 0.85) * (1.0 - i * 0.35) );
                        // slight pulsation
                        arc.rotation.z = Math.sin(t * 0.0007 + i) * 0.02;
                    }
                } else {
                    // fade out arcs
                    this.arcs.traverse(o => { if (o.material) o.material.opacity *= 0.92; });
                    // remove very faint
                    this.arcs.children = this.arcs.children.filter(c => (c.material && c.material.opacity > 0.02));
                }
            }

            _createRainbowArc() {
                // create a simple semi-circular ribbon using a strip of vertices and vertex colors for spectral gradient
                const seg = 96;
                const radius = 60;
                const inner = radius * 0.88;
                const outer = radius * 1.04;
                const positions = [];
                const colors = [];
                for (let i = 0; i <= seg; i++) {
                    const t = i / seg; // 0..1 across arc from left to right
                    const angle = Math.PI * (0.05 + 0.9 * t); // semi arc
                    // outer
                    positions.push(Math.cos(angle) * outer, Math.sin(angle) * outer, 0);
                    // inner
                    positions.push(Math.cos(angle) * inner, Math.sin(angle) * inner, 0);

                    // spectral color gradient across the thickness (approx ROYGBIV)
                    const spec = new THREE.Color();
                    // map t to approximate wavelength
                    const col = new THREE.Color().setHSL(0.66 - t * 0.66, 0.95, 0.6);
                    colors.push(col.r, col.g, col.b);
                    colors.push(col.r * 0.85, col.g * 0.85, col.b * 0.85);
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                // create a two-sided transparent material that uses vertex colors
                const mat = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.0,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                // create a triangle strip via Index buffer
                const indices = [];
                for (let i = 0; i < seg; i++) {
                    const a = i * 2;
                    const b = a + 1;
                    const c = a + 2;
                    const d = a + 3;
                    indices.push(a, c, b);
                    indices.push(c, d, b);
                }
                geometry.setIndex(indices);
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.renderOrder = 1000;
                return mesh;
            }
        }

        // Downburst system: creates short-lived strong downward/outward winds under intense mature clouds
        class Downburst {
            constructor(windFieldRef, cloudSystemRef) {
                this.windField = windFieldRef;
                this.cloudSystem = cloudSystemRef;
                this.events = []; // active downbursts
                this.cooldown = 0;
                
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }

            // schedule a downburst at (x,z) with strength and radius
            trigger(x, z, strength = 6, radius = 20, duration = 180) {
                const event = {
                    x, z, strength, radius, life: duration, maxLife: duration,
                    created: performance.now(),
                    // add vorticity and impulse vectors for richer dynamics
                    vortexSpin: (Math.random() > 0.5 ? 1 : -1) * (0.6 + Math.random() * 1.4),
                    coreRadius: Math.max(6, radius * (0.25 + Math.random() * 0.45)),
                    visuals: new THREE.Group() // Group for associated meshes/particles
                };
                
                // --- Downburst Foot / Outflow Visualization ---
                
                // 1. Ground splash (expanding particle ring for dust/mist)
                const splashParticles = this.createSplashParticles(event);
                event.visuals.add(splashParticles);
                
                // 2. Persistent outflow boundary (ring geometry that fades)
                const ringGeo = new THREE.RingGeometry(event.coreRadius * 0.8, event.radius * 0.9, 32);
                const baseCol = new THREE.Color(0xc8d0e0);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: baseCol, 
                    transparent: true, 
                    opacity: 0.15 * (strength / 10), 
                    side: THREE.DoubleSide, 
                    depthWrite: false, 
                    blending: THREE.AdditiveBlending 
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(0, 0.4, 0); // relative to event.visuals group
                ring.userData.maxScale = 3 + strength * 0.3;
                ring.userData.type = 'outflow_ring';
                event.visuals.add(ring);
                
                event.visuals.position.set(x, 0, z);
                this.group.add(event.visuals);

                this.events.push(event);
            }

            createSplashParticles(event) {
                const particleCount = 200;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(particleCount * 3);
                const pVel = new Float32Array(particleCount * 3);
                const pLife = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * event.radius * 0.6;
                    
                    pPos[i*3] = Math.cos(angle) * r;
                    pPos[i*3+1] = 0.5;
                    pPos[i*3+2] = Math.sin(angle) * r;
                    
                    pVel[i*3] = Math.cos(angle) * (1 + Math.random() * event.strength * 0.1);
                    pVel[i*3+1] = 0.2 + Math.random() * 0.8; // upward kick
                    pVel[i*3+2] = Math.sin(angle) * (1 + Math.random() * event.strength * 0.1);
                    
                    pLife[i] = 1.0;
                }
                
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                pGeo.setAttribute('velocity', new THREE.BufferAttribute(pVel, 3));
                pGeo.setAttribute('life', new THREE.BufferAttribute(pLife, 1));
                
                const pMat = new THREE.PointsMaterial({
                    size: 0.8 + event.strength * 0.05,
                    color: 0xc8d0e0, // dusty light grey/blue
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const points = new THREE.Points(pGeo, pMat);
                points.userData = { 
                    type: 'splash_particles', 
                    strength: event.strength, 
                    maxLife: event.maxLife 
                };
                return points;
            }

            // inject a transient perturbation into the wind field for low levels
            applyToWind(event) {
                // affect a subset of windField cells near ground (gy = 0..4)
                const s = event.strength;
                const r = event.radius;
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const now = performance.now();

                for (let gx = 0; gx < size; gx++) {
                    for (let gy = 0; gy < Math.min(6, size); gy++) {
                        for (let gz = 0; gz < size; gz++) {
                            const wx = (gx - size / 2) * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const dx = wx - event.x;
                            const dz = wz - event.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < r) {
                                const radialFactor = 1 - dist / r;
                                const lifeFactor = Math.max(0.08, event.life / event.maxLife);
                                // outward radial push stronger near start, weaker at edges
                                const radialPush = s * radialFactor * lifeFactor * (1 + (4 - gy) * 0.18);
                                // add rotational (vortex) component, stronger near coreRadius
                                const vortexInfluence = Math.max(0, 1 - dist / Math.max(1, event.coreRadius));
                                const spin = event.vortexSpin * 0.9 * vortexInfluence * lifeFactor * (1 + (4 - gy) * 0.08);
                                // compute unit radial and tangential vectors
                                const inv = 1 / (dist + 0.0001);
                                const ux = dx * inv;
                                const uz = dz * inv;
                                // tangential perpendicular vector
                                const tx = -uz;
                                const tz = ux;
                                // apply combined radial + tangential perturbation
                                this.windField.field[gx][gy][gz].x += ux * radialPush * 0.6 + tx * spin * 0.8;
                                this.windField.field[gx][gy][gz].z += uz * radialPush * 0.6 + tz * spin * 0.8;
                                // add a small downward signal stored in cell for precipitation/visuals to read
                                if (!this.windField.field[gx][gy][gz].__downburst) this.windField.field[gx][gy][gz].__downburst = 0;
                                this.windField.field[gx][gy][gz].__downburst += radialPush * 0.06 * (1 + (5 - gy) * 0.06);
                                // also inject a short-lived vorticity marker
                                if (!this.windField.field[gx][gy][gz].__vortex) this.windField.field[gx][gy][gz].__vortex = 0;
                                this.windField.field[gx][gy][gz].__vortex += Math.sign(event.vortexSpin) * vortexInfluence * lifeFactor * 0.02;
                            }
                        }
                    }
                }
            }

            // occasionally spawn downbursts from very mature, heavy clouds
            update(t) {
                // cooldown reduces chance spam
                if (this.cooldown > 0) this.cooldown--;

                // check mature clouds and randomly trigger events when heavy updrafts collapse
                const mature = this.cloudSystem.getMature();
                mature.forEach(c => {
                    // high mass and sudden age spike can cause collapse -> downburst chance
                    if (c.mass > 6 && Math.random() < 0.0012 && this.cooldown === 0) {
                        const x = c.x + (Math.random() - 0.5) * 8;
                        const z = c.z + (Math.random() - 0.5) * 8;
                        const strength = 6 + Math.random() * 10;
                        const radius = Math.max(12, c.radius * 1.0 + Math.random() * 18);
                        const dur = 100 + Math.floor(Math.random() * 220);
                        this.trigger(x, z, strength, radius, dur);
                        this.cooldown = 700 + Math.floor(Math.random() * 400);
                        // stronger camera shake for larger downbursts
                        AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, 0.9 + strength * 0.18);
                    }
                });

                // apply active events to wind field and age them
                for (let i = this.events.length - 1; i >= 0; i--) {
                    const ev = this.events[i];
                    
                    // --- Visual Update ---
                    const progress = ev.life / ev.maxLife;
                    ev.visuals.traverse(obj => {
                        if (obj.userData.type === 'outflow_ring' && obj.material) {
                            const scale = 1 + (ev.maxLife - ev.life) * (obj.userData.maxScale || 3) / ev.maxLife;
                            obj.scale.set(scale, scale, scale);
                            // Initial heavy opacity, fading quickly
                            obj.material.opacity = Math.max(0.01, (progress * 0.8 + 0.2) * (ev.strength / 10) * 0.15);
                        } else if (obj.userData.type === 'splash_particles' && obj.geometry) {
                            const positions = obj.geometry.attributes.position.array;
                            const velocities = obj.geometry.attributes.velocity.array;
                            const lives = obj.geometry.attributes.life.array;
                            let allDead = true;
                            
                            for (let j = 0; j < positions.length / 3; j++) {
                                if (lives[j] > 0) {
                                    positions[j*3] += velocities[j*3] * 0.01;
                                    positions[j*3+1] += velocities[j*3+1] * 0.01;
                                    positions[j*3+2] += velocities[j*3+2] * 0.01;
                                    // Gravity/air resistance
                                    velocities[j*3+1] -= 0.05 * 0.01;
                                    
                                    lives[j] -= 0.005;
                                    
                                    if (positions[j*3+1] < 0.5) lives[j] = 0; // hit ground
                                    
                                    if (lives[j] > 0) allDead = false;
                                    
                                    // Fade based on particle life
                                    obj.material.opacity = Math.min(0.8, progress) * (lives[j] / 1.0) * 0.8; 
                                } else {
                                    // hide dead particle
                                    positions[j*3+1] = -1000;
                                }
                            }
                            obj.geometry.attributes.position.needsUpdate = true;
                            // If main event is dying, ensure particles fade and die out
                            if (ev.life < 10 && allDead) {
                                ev.life = 0;
                            }
                        }
                    });

                    // apply multiple passes per frame to create a broad transient gust and an inner core collapse
                    this.applyToWind(ev);
                    // inner core pulse that decays faster
                    if (ev.life > ev.maxLife * 0.6) {
                        // create a strong inner core impulse for the first part
                        const corePulse = {
                            x: ev.x + (Math.random() - 0.5) * (ev.coreRadius * 0.2),
                            z: ev.z + (Math.random() - 0.5) * (ev.coreRadius * 0.2),
                            strength: ev.strength * 0.6,
                            radius: Math.max(4, ev.coreRadius * 0.8),
                            life: 6,
                            maxLife: 6,
                            vortexSpin: ev.vortexSpin * (0.6 + Math.random() * 0.6)
                        };
                        this.applyToWind(corePulse);
                    }
                    // visual subtle ground flash at creation
                    if (ev.life === ev.maxLife - 1) {
                        const flash = new THREE.PointLight(0xaad6ff, 0.9, ev.radius * 1.6);
                        flash.position.set(ev.x, 8, ev.z);
                        AppState.scene.add(flash);
                        setTimeout(() => {
                            flash.intensity = 0.25;
                            setTimeout(() => {
                                AppState.scene.remove(flash);
                                if (flash.dispose) flash.dispose();
                            }, 300);
                        }, 80);
                    }
                    ev.life--;
                    if (ev.life <= 0) {
                        // Dispose visuals
                        ev.visuals.traverse(obj => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.group.remove(ev.visuals);
                        this.events.splice(i, 1);
                    }
                }
            }
        }

        // Tornado system: attaches to supercell clouds and injects strong rotating inflow/outflow winds
        class TornadoSystem {
            constructor(windFieldRef, cloudSystemRef) {
                this.windField = windFieldRef;
                this.cloudSystem = cloudSystemRef;
                this.tornadoes = [];
                this.cooldown = 0;
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }

            spawnFromCloud(cloud) {
                // ensure tornadoes only spawn from robust supercells with strong vertical structure and mature updrafts
                if (!cloud || cloud.stage !== 'supercell' || cloud.dying) return;
                // require significant vertical extent and a pronounced base/top separation and mass
                const cloudVerticalExtent = Math.max(0, (cloud.cloudTop || cloud.height) - (cloud.cloudBase || (cloud.height - 8)));
                if (cloudVerticalExtent < 16 || cloud.mass < 7.5 || cloud.condensationLevel < 0.6) return;

                const existing = this.tornadoes.find(t => t.cloud === cloud);
                if (existing) return;

                const baseRadius = 3.5 + Math.random() * 3.0;
                const topRadius = 0.6 + Math.random() * 0.6;
                // make funnel height tied to cloud base/top so it anchors correctly
                const height = Math.max(18, cloud.cloudTop - cloud.cloudBase + 4);
                const segs = 24;

                const funnelGeo = new THREE.CylinderGeometry(topRadius, baseRadius, height, segs, 1, true);
                funnelGeo.translate(0, height * 0.5, 0);

                const funnelMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(0x8690a0),
                    transparent: true,
                    opacity: 0.0, // keep mesh invisible; visuals from debris & particle column
                    metalness: 0.05,
                    roughness: 0.85,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const funnel = new THREE.Mesh(funnelGeo, funnelMat);
                funnel.castShadow = false;
                funnel.receiveShadow = false;
                funnel.visible = false;

                const coreLight = new THREE.PointLight(0xaad0ff, 1.2, Math.max(30, height * 1.2), 2);
                coreLight.position.set(0, height * 0.45, 0);

                // more detailed debris/column particles with height-proportional distribution and variable spiral speeds
                const debrisCount = 500;
                const dGeo = new THREE.BufferGeometry();
                const dPos = new Float32Array(debrisCount * 3);
                const dVel = new Float32Array(debrisCount * 3);
                const dPhase = new Float32Array(debrisCount); // phase per particle so spiral isn't uniform
                for (let i = 0; i < debrisCount; i++) {
                    const hFrac = Math.random();
                    const radialBias = 0.3 + (1 - hFrac) * 0.7;
                    const r = radialBias * baseRadius * (0.3 + Math.random() * 0.9);
                    const ang = Math.random() * Math.PI * 2;
                    dPos[i*3] = Math.cos(ang) * r;
                    dPos[i*3+1] = 0.5 + hFrac * height;
                    dPos[i*3+2] = Math.sin(ang) * r;
                    // velocities tuned so upper particles have stronger tangential motion and slower fall
                    const tangential = 0.02 + (1 - hFrac) * 0.12;
                    const downward = 0.006 + hFrac * 0.04;
                    dVel[i*3] = -Math.sin(ang) * tangential;
                    dVel[i*3+1] = -downward;
                    dVel[i*3+2] = Math.cos(ang) * tangential;
                    dPhase[i] = Math.random() * Math.PI * 2;
                }
                dGeo.setAttribute('position', new THREE.BufferAttribute(dPos, 3));
                dGeo.setAttribute('velocity', new THREE.BufferAttribute(dVel, 3));
                dGeo.setAttribute('phase', new THREE.BufferAttribute(dPhase, 1));
                const dMat = new THREE.PointsMaterial({
                    size: 0.45,
                    color: 0x9fd5ff,
                    transparent: true,
                    opacity: 0.95,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                const debris = new THREE.Points(dGeo, dMat);

                const container = new THREE.Group();
                container.add(funnel);
                container.add(coreLight);
                container.add(debris);
                container.position.set(cloud.x, 0, cloud.z);
                this.group.add(container);

                const tornado = {
                    cloud,
                    obj: container,
                    funnel,
                    debris,
                    baseRadius,
                    topRadius,
                    height,
                    life: 700 + Math.random() * 400,
                    maxLife: 700 + Math.random() * 400,
                    strength: 10 + Math.random() * 10,
                    spinSign: Math.random() > 0.5 ? 1 : -1
                };

                this.tornadoes.push(tornado);

                // camera shake on tornado birth
                AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, 1.3);
                AppState.cameraControls.shake.duration = 800;
                AppState.cameraControls.shake.time = 0;
            }

            applyToWind(tornado) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const rMax = tornado.baseRadius * 3.3;
                const x0 = tornado.obj.position.x;
                const z0 = tornado.obj.position.z;

                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        const dx = wx - x0;
                        const dz = wz - z0;
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        if (dist > rMax || dist < 0.001) continue;

                        const inv = 1 / dist;
                        const ux = dx * inv;
                        const uz = dz * inv;
                        const tx = -uz;
                        const tz = ux;

                        const core = 1 - Math.min(1, dist / rMax);
                        const inflow = tornado.strength * 1.2 * core;
                        const spin = tornado.strength * 0.9 * core * tornado.spinSign;

                        for (let gy = 0; gy < Math.min(this.windField.size, 10); gy++) {
                            const cell = this.windField.field[gx][gy][gz];
                            cell.x += (-ux * inflow + tx * spin) * 0.12;
                            cell.z += (-uz * inflow + tz * spin) * 0.12;
                            // vertical marker for intense updraft
                            cell.__updraft = (cell.__updraft || 0) + core * 0.12;
                        }
                    }
                }
            }

            update(t) {
                if (!this.cloudSystem) return;

                if (this.cooldown > 0) this.cooldown--;

                // look for supercell clouds and occasionally spawn tornadoes
                if (this.cooldown === 0) {
                    const candidates = this.cloudSystem.clouds.filter(c => c.stage === 'supercell' && !c.dying && c.mass > 7);
                    if (candidates.length > 0 && Math.random() < 0.005) {
                        const c = candidates[Math.floor(Math.random() * candidates.length)];
                        this.spawnFromCloud(c);
                        this.cooldown = 1200 + Math.floor(Math.random() * 800);
                    }
                }

                for (let i = this.tornadoes.length - 1; i >= 0; i--) {
                    const tno = this.tornadoes[i];
                    const cloud = tno.cloud;

                    // follow parent cloud slowly
                    if (cloud && !cloud.dying) {
                        const targetX = cloud.x;
                        const targetZ = cloud.z;
                        tno.obj.position.x += (targetX - tno.obj.position.x) * 0.06;
                        tno.obj.position.z += (targetZ - tno.obj.position.z) * 0.06;
                        // adjust funnel height with cloud base/top
                        const newHeight = Math.max(18, cloud.cloudBase + 8);
                        if (Math.abs(newHeight - tno.height) > 0.5) {
                            tno.height += (newHeight - tno.height) * 0.15;
                            tno.funnel.scale.y = tno.height / Math.max(1, tno.funnel.geometry.parameters.height || tno.height);
                        }
                    }

                    // spin funnel
                    tno.obj.rotation.y += 0.04 * tno.spinSign;

                    // update debris (blue particles slowly falling)
                    const posAttr = tno.debris.geometry.attributes.position;
                    const velAttr = tno.debris.geometry.attributes.velocity;
                    const p = posAttr.array;
                    const v = velAttr.array;
                    const count = p.length / 3;
                    for (let j = 0; j < count; j++) {
                        const idx = j * 3;
                        p[idx]     += v[idx]     * 1.0;
                        p[idx + 1] += v[idx + 1] * 1.0;
                        p[idx + 2] += v[idx + 2] * 1.0;

                        // spiral and reset once near ground
                        const r = Math.sqrt(p[idx]*p[idx] + p[idx+2]*p[idx+2]) + 0.0001;
                        const ang = Math.atan2(p[idx+2], p[idx]) + 0.1 * tno.spinSign;
                        const baseR = Math.min(tno.baseRadius * 1.2, r + 0.02);
                        p[idx] = Math.cos(ang) * baseR;
                        p[idx+2] = Math.sin(ang) * baseR;

                        if (p[idx+1] < 0.6) {
                            // respawn higher up
                            const nr = Math.random() * tno.baseRadius * 0.9;
                            const nang = Math.random() * Math.PI * 2;
                            p[idx] = Math.cos(nang) * nr;
                            p[idx+1] = 2 + Math.random() * (tno.height * 0.9);
                            p[idx+2] = Math.sin(nang) * nr;
                        }
                    }
                    posAttr.needsUpdate = true;

                    // apply wind influence
                    this.applyToWind(tno);

                    // fade over lifetime
                    tno.life--;
                    const lifeFrac = Math.max(0, tno.life / tno.maxLife);
                    tno.funnel.material.opacity = 0.2 + lifeFrac * 0.5;
                    tno.debris.material.opacity = 0.3 + lifeFrac * 0.6;

                    if (tno.life <= 0 || (cloud && cloud.dying)) {
                        this.group.remove(tno.obj);
                        tno.funnel.geometry.dispose();
                        tno.funnel.material.dispose();
                        tno.debris.geometry.dispose();
                        tno.debris.material.dispose();
                        this.tornadoes.splice(i, 1);
                    }
                }
            }
        }

        // New frontal & derecho systems
        class WarmFront {
            constructor(windField, cloudSystem) {
                this.windField = windField;
                this.cloudSystem = cloudSystem;
                this.fronts = []; // active warm fronts
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }
            spawn(x, z, length = 180, speed = 0.06, tilt = 0.15) {
                const f = {
                    x, z, length, speed, tilt, age: 0, maxAge: 3600,
                    group: new THREE.Group(),
                    linePoints: []
                };
                // visual ribbon
                const seg = Math.max(8, Math.floor(length / 12));
                const geo = new THREE.BufferGeometry();
                const pts = new Float32Array((seg + 1) * 3);
                for (let i = 0; i <= seg; i++) {
                    const t = i / seg;
                    pts[i * 3] = x + Math.cos(0.0) * (t - 0.5) * length;
                    pts[i * 3 + 1] = 12 + tilt * 8 * Math.sin(t * Math.PI);
                    pts[i * 3 + 2] = z + Math.sin(0.0) * (t - 0.5) * length;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
                const mat = new THREE.LineBasicMaterial({ color: 0xffe3b8, transparent: true, opacity: 0.22 });
                const line = new THREE.Line(geo, mat);
                f.group.add(line);
                f.line = line;
                this.group.add(f.group);
                this.fronts.push(f);
                return f;
            }
            applyToWind(f) {
                // gentle lift ahead of warm front, steering low-level winds northeast-ish locally
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        const dx = wx - f.x;
                        const dz = wz - f.z;
                        const along = dx * 0.01 - dz * 0.005;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const influence = Math.max(0, 1 - dist / (f.length * 0.8));
                        if (influence > 0.01) {
                            // push low-level winds and add slight updraft
                            for (let gy = 0; gy < Math.min(6, size); gy++) {
                                const cell = this.windField.field[gx][gy][gz];
                                cell.x += 0.03 * influence * (along * 0.6 + 0.2);
                                cell.z += 0.02 * influence * (along * 0.2 - 0.1);
                                cell.__updraft = (cell.__updraft || 0) + 0.002 * influence * (1 + (6 - gy) * 0.08);
                            }
                        }
                    }
                }
            }
            update(t) {
                for (let i = this.fronts.length - 1; i >= 0; i--) {
                    const f = this.fronts[i];
                    f.age++;
                    // propagate the front forward using its speed
                    f.x += f.speed * 12;
                    f.z += f.speed * 6 * 0.35;
                    // nudge visual
                    if (f.line && f.line.geometry && f.line.geometry.attributes.position) {
                        const attr = f.line.geometry.attributes.position.array;
                        for (let j = 0; j < attr.length / 3; j++) {
                            attr[j * 3 + 1] = 10 + Math.sin((t * 0.0006) + j) * 0.6 + Math.max(0, Math.sin(f.age * 0.002 + j) * 0.4);
                        }
                        f.line.geometry.attributes.position.needsUpdate = true;
                    }
                    // apply to windfield to lift and encourage stratiform cloud formation ahead of front
                    this.applyToWind(f);
                    // spawn shelf-like cloud band: encourage the cloudSystem to create broad layered puffs along line
                    if (f.age % 30 === 0) {
                        const seg = Math.max(6, Math.floor(f.length / 30));
                        for (let s = 0; s < seg; s++) {
                            const tpos = (s / seg - 0.5) * f.length + (Math.random() - 0.5) * 6;
                            const cx = f.x + tpos + (Math.random() - 0.5) * 10;
                            const cz = f.z + (Math.random() - 0.5) * 10;
                            // bias to broad stratiform: use cloudSystem.grow with slight parameters
                            const c = this.cloudSystem.grow(cx, cz);
                            if (c) {
                                c.baseHeight = 10 + Math.random() * 6;
                                c.growthRate *= 0.5;
                                c.widthFactor *= 1.6;
                            }
                        }
                    }
                    if (f.age > f.maxAge) {
                        // remove visuals
                        f.group.traverse(obj => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.group.remove(f.group);
                        this.fronts.splice(i, 1);
                    }
                }
            }
        }

        class ColdFront {
            constructor(windField, cloudSystem) {
                this.windField = windField;
                this.cloudSystem = cloudSystem;
                this.fronts = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }
            spawn(x, z, length = 140, speed = 0.18, steepness = 1.2) {
                const f = {
                    x, z, length, speed, steepness, age: 0, maxAge: 2400,
                    group: new THREE.Group()
                };
                // shelf cloud visualization (broad thin plate)
                const seg = Math.max(6, Math.floor(length / 18));
                const planeGeo = new THREE.PlaneGeometry(length, 8, seg, 1);
                const verts = planeGeo.attributes.position.array;
                for (let i = 0; i < verts.length; i += 3) {
                    verts[i + 1] = 6 + Math.random() * 2; // small undulation
                }
                planeGeo.attributes.position.needsUpdate = true;
                const mat = new THREE.MeshLambertMaterial({ color: 0xb5c7d6, transparent: true, opacity: 0.78, depthWrite: false });
                const mesh = new THREE.Mesh(planeGeo, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(x, 14, z);
                f.group.add(mesh);
                f.shelf = mesh;
                this.group.add(f.group);
                this.fronts.push(f);
                return f;
            }
            applyToWind(f) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        const dx = wx - f.x;
                        const dz = wz - f.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const influence = Math.max(0, 1 - dist / (f.length * 0.6));
                        if (influence > 0.02) {
                            // strong push, downdraft at immediate front then outflow
                            for (let gy = 0; gy < Math.min(6, size); gy++) {
                                const cell = this.windField.field[gx][gy][gz];
                                const push = f.speed * 0.6 * influence;
                                cell.x += push * (dx > 0 ? -1 : 1) * 0.5;
                                cell.z += push * (dz > 0 ? -1 : 1) * 0.5;
                                // induce a downward signal for precip acceleration close to front
                                cell.__downburst = (cell.__downburst || 0) + 0.004 * influence * (1 + (6 - gy) * 0.08);
                            }
                        }
                    }
                }
            }
            update(t) {
                for (let i = this.fronts.length - 1; i >= 0; i--) {
                    const f = this.fronts[i];
                    f.age++;
                    // faster progression
                    f.x += f.speed * 20;
                    f.z += f.speed * 6;
                    // wobble shelf mesh and lower it slightly to convey gust
                    if (f.shelf && f.shelf.geometry) {
                        f.shelf.position.y = 12 + Math.sin(t * 0.0008 + f.age * 0.01) * 1.2;
                        f.shelf.rotation.z = Math.sin(f.age * 0.004) * 0.06;
                    }
                    // apply to winds and encourage narrow towering convection immediately behind front
                    this.applyToWind(f);
                    if (f.age % 18 === 0) {
                        // spawn short-lived towering cumulus behind the front line
                        const bx = f.x - (10 + Math.random() * 12);
                        const bz = f.z + (Math.random() - 0.5) * 8;
                        const c = this.cloudSystem.grow(bx, bz);
                        if (c) {
                            c.baseHeight = 14 + Math.random() * 6;
                            c.growthRate *= 1.8;
                            c.widthFactor *= 0.6;
                            c.turbulence = Math.max(c.turbulence, 0.6);
                        }
                    }
                    if (f.age > f.maxAge) {
                        f.group.traverse(obj => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.group.remove(f.group);
                        this.fronts.splice(i, 1);
                    }
                }
            }
        }

        class DerechoSystem {
            constructor(windField, cloudSystem, rainSystem) {
                this.windField = windField;
                this.cloudSystem = cloudSystem;
                this.rainSystem = rainSystem;
                this.events = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.cooldown = 0;
            }
            trySpawnFromClusters() {
                // occasionally organize a powerful linear convective system from mature clusters
                if (this.cooldown > 0) { this.cooldown--; return; }
                const mature = this.cloudSystem.getMature();
                if (mature.length < 3) return;
                // if several mature clouds line up roughly, spawn derecho
                if (Math.random() < 0.003) {
                    const c = mature[Math.floor(Math.random() * mature.length)];
                    const x = c.x - 40 + (Math.random() * 80);
                    const z = c.z - 10 + (Math.random() * 20);
                    this.spawn(x, z, 250, 10 + Math.random() * 20);
                    this.cooldown = 2400 + Math.floor(Math.random()*2000);
                }
            }
            spawn(x, z, length = 240, strength = 14) {
                const ev = {
                    x, z, length, strength, life: 900 + Math.floor(Math.random() * 800), maxLife: 900 + Math.floor(Math.random() * 800),
                    group: new THREE.Group()
                };
                // visual: long translucent band
                const geo = new THREE.PlaneGeometry(length, 18, Math.max(4, Math.floor(length/20)), 1);
                const attr = geo.attributes.position.array;
                for (let i = 0; i < attr.length; i += 3) {
                    attr[i + 1] = 6 + (Math.random() - 0.5) * 1.2;
                }
                geo.attributes.position.needsUpdate = true;
                const mat = new THREE.MeshBasicMaterial({ color: 0x9fbfdc, transparent: true, opacity: 0.24, side: THREE.DoubleSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(x, 14, z);
                ev.group.add(mesh);
                this.group.add(ev.group);
                this.events.push(ev);
                // immediate strong wind perturbation and potential downburst line
                this.applyToWind(ev);
            }
            applyToWind(ev) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const r = ev.length * 0.6;
                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        const dx = wx - ev.x;
                        const dz = wz - ev.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const influence = Math.max(0, 1 - dist / r);
                        if (influence > 0.02) {
                            for (let gy = 0; gy < Math.min(6, size); gy++) {
                                const cell = this.windField.field[gx][gy][gz];
                                // strong straight-line winds: push eastward-ish relative to event
                                cell.x += ev.strength * 0.02 * influence;
                                cell.z += ev.strength * 0.01 * influence;
                                // create downburst markers to accelerate precipitation and create shelf-like outflow
                                cell.__downburst = (cell.__downburst || 0) + 0.018 * influence * (1 + (6 - gy) * 0.12);
                            }
                        }
                    }
                }
            }
            update(t) {
                // try to spawn occasionally based on clusters
                this.trySpawnFromClusters();
                for (let i = this.events.length - 1; i >= 0; i--) {
                    const ev = this.events[i];
                    ev.life--;
                    // progress movement to the east/south-east
                    ev.x += 0.28;
                    ev.z += 0.05;
                    // visual breathing
                    ev.group.children.forEach(c => {
                        if (c.geometry && c.geometry.attributes.position) {
                            const arr = c.geometry.attributes.position.array;
                            for (let j = 0; j < arr.length; j += 3) {
                                arr[j + 1] = 5 + Math.sin(t * 0.0012 + j) * 0.8;
                            }
                            c.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                    // apply to wind field continuously and spawn linear precipitation
                    this.applyToWind(ev);
                    // spawn concentrated precipitation along the core line to create derecho rain/wind effects
                    if (this.rainSystem && ev.life % 6 === 0) {
                        const steps = Math.max(6, Math.floor(ev.length / 30));
                        for (let s = 0; s < steps; s++) {
                            const px = ev.x + (s / steps - 0.5) * ev.length + (Math.random() - 0.5) * 6;
                            const pz = ev.z + (Math.random() - 0.5) * 8;
                            // create a brief, intense cloud to source rain if none near
                            const c = this.cloudSystem.grow(px, pz);
                            if (c) {
                                c.baseHeight = 16 + Math.random() * 6;
                                c.mass += 1.2 * (ev.strength / 12);
                                c.condensationLevel = Math.min(1, c.condensationLevel + 0.15);
                                // spawn multiple raindrops from this transient enhancement
                                for (let k = 0; k < 5; k++) this.rainSystem.spawn(c);
                            }
                        }
                    }
                    if (ev.life <= 0) {
                        ev.group.traverse(o => { if (o.geometry) o.geometry.dispose(); if (o.material) o.material.dispose(); });
                        this.group.remove(ev.group);
                        this.events.splice(i, 1);
                    }
                }
            }
        }

        function setupControls() {
            // Mouse controls
            // Use Pointer Events for consistent mouse & touch drag handling on the renderer canvas
            const canvas = AppState.renderer.domElement;
            canvas.style.touchAction = 'none'; // prevent browser gestures interfering

            canvas.addEventListener('pointerdown', (e) => {
                // only handle primary button
                if (e.pointerType === 'mouse' && e.button !== 0) return;
                canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
                AppState.cameraControls.isDrag = true;
                AppState.cameraControls.prevMouse = { x: e.clientX, y: e.clientY };
                // optional pointer lock suggestion when in FP mode
                if (AppState.firstPerson && document.body.requestPointerLock) {
                    try { document.body.requestPointerLock(); } catch (err) {}
                }
            });

            canvas.addEventListener('pointermove', (e) => {
                if (!AppState.cameraControls.isDrag) return;
                const dx = e.clientX - AppState.cameraControls.prevMouse.x;
                const dy = e.clientY - AppState.cameraControls.prevMouse.y;
                AppState.cameraControls.rotation.theta -= dx * 0.03;
                AppState.cameraControls.rotation.phi -= dy * 0.02;
                AppState.cameraControls.rotation.phi = Math.max(0.08, Math.min(Math.PI / 2.2, AppState.cameraControls.rotation.phi));
                AppState.cameraControls.prevMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('pointerup', (e) => {
                canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
                AppState.cameraControls.isDrag = false;
                if (document.exitPointerLock) try { document.exitPointerLock(); } catch (err) {}
            });
            canvas.addEventListener('pointercancel', (e) => {
                canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
                AppState.cameraControls.isDrag = false;
            });

            // Touch controls (orbit/look handled via joystick below)
            AppState.renderer.domElement.addEventListener('touchstart', e => {
                // prevent default handled per listeners when needed
            });

            // Keyboard controls for FPS movement and GUI
            const keys = {};
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;

                // toggle GUI with H
                if (e.key === 'h' || e.key === 'H') {
                    AppState.showGui = !AppState.showGui;
                    document.body.classList.toggle('ui-collapsed', !AppState.showGui);
                    ['stats', 'controls', 'info', 'graphics'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.setAttribute('aria-hidden', String(!AppState.showGui));
                    });
                    document.getElementById('toggle-gui').textContent = AppState.showGui ? 'üëÅÔ∏è Hide UI' : 'üëÅÔ∏è Show UI';
                }
            });
            window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

            // WASD movement loop integrated into animation (values persisted) ‚Äî orbit only (no FP movement)
            function updateKeyboardMovement() {
                const ctrl = AppState.cameraControls;
                ctrl.move.forward = 0;
                ctrl.move.right = 0;
                let speed = ctrl.speed;
                if (keys['shift']) speed *= ctrl.runMultiplier;
                if (keys['w']) ctrl.move.forward += 1;
                if (keys['s']) ctrl.move.forward -= 1;
                if (keys['a']) ctrl.move.right -= 1;
                if (keys['d']) ctrl.move.right += 1;
                // No first-person movement ‚Äî WASD inert in orbit view (can be repurposed later)
                requestAnimationFrame(updateKeyboardMovement);
            }
            updateKeyboardMovement();

            // toggle GUI via button dispatch (keeps semantics)
            // direct GUI toggle so it's reliable across environments
            document.getElementById('toggle-gui').addEventListener('click', () => {
                AppState.showGui = !AppState.showGui;
                document.body.classList.toggle('ui-collapsed', !AppState.showGui);
                ['stats', 'controls', 'info', 'graphics'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.setAttribute('aria-hidden', String(!AppState.showGui));
                    if (el) el.classList.toggle('hidden', !AppState.showGui);
                });
                document.getElementById('toggle-gui').textContent = AppState.showGui ? 'üëÅÔ∏è Hide UI' : 'üëÅÔ∏è Show UI';
            });

            // Pause button
            const pauseBtn = document.getElementById('pause-btn');
            pauseBtn.addEventListener('click', () => {
                AppState.paused = !AppState.paused;
                pauseBtn.textContent = AppState.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
            });

            // make Controls panel closable: add close button to controls panel (kept but now only hides controls panel)
            (function addControlsClose() {
                const controlsEl = document.getElementById('controls');
                if (!controlsEl) return;
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.title = 'Close';
                closeBtn.style.position = 'absolute';
                closeBtn.style.top = '8px';
                closeBtn.style.right = '8px';
                closeBtn.style.width = '30px';
                closeBtn.style.height = '30px';
                closeBtn.style.borderRadius = '6px';
                closeBtn.style.border = '1px solid rgba(255,255,255,0.08)';
                closeBtn.style.background = 'rgba(0,0,0,0.5)';
                closeBtn.style.color = 'white';
                closeBtn.style.cursor = 'pointer';
                controlsEl.appendChild(closeBtn);

                // toggle via close button (hide) and add a small reopen button
                closeBtn.addEventListener('click', () => {
                    controlsEl.classList.add('hidden');
                    // create reopen button if not present
                    if (!document.getElementById('reopen-controls')) {
                        const btn = document.createElement('button');
                        btn.id = 'reopen-controls';
                        btn.textContent = 'Controls';
                        document.body.appendChild(btn);
                        btn.addEventListener('click', () => {
                            controlsEl.classList.remove('hidden');
                            btn.remove();
                        });
                    }
                });
            })();
        }

        function init() {
            AppState.scene = new THREE.Scene();
            AppState.scene.background = new THREE.Color(0x5a7a95);
            AppState.scene.fog = new THREE.Fog(0x5a7a95, 100, 350);

            AppState.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            AppState.camera.position.set(0, 25, 70);

            AppState.renderer = new THREE.WebGLRenderer({ antialias: true });
            AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            AppState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            AppState.renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(AppState.renderer.domElement);

            const ambient = new THREE.AmbientLight(0x808fa0, 1.2);
            AppState.scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xfffae6, 1.5);
            sun.position.set(60, 50, 80);
            sun.castShadow = true;
            sun.shadow.camera.left = sun.shadow.camera.bottom = -70;
            sun.shadow.camera.right = sun.shadow.camera.top = 70;
            sun.shadow.mapSize.width = sun.shadow.mapSize.height = 1024;
            AppState.scene.add(sun);

            const back = new THREE.DirectionalLight(0xffd9a8, 0.8);
            back.position.set(-50, 40, -60);
            AppState.scene.add(back);

            createTerrain();
            
            AppState.windField = new WindField();
            AppState.evaporationSystem = new EvaporationSystem();
            AppState.cloudSystem = new CloudGrowth();
            AppState.rainSystem = new Precipitation(AppState.windField, AppState.cloudSystem);
            AppState.lightningSystem = new Lightning(AppState.cloudSystem);
            AppState.downburstSystem = new Downburst(AppState.windField, AppState.cloudSystem);
            // Rainbow system (visualization dependent on sun & moisture)
            AppState.rainbowSystem = new RainbowSystem();
            AppState.updraftSystem = new (class UpdraftSystem {
                constructor(windFieldRef, cloudSystemRef) {
                    this.wind = windFieldRef;
                    this.clouds = cloudSystemRef;
                    this.events = []; // transient concentrated updraft pulses
                }
                // return net updraft lift at x,z (0..1 scale)
                getUpdraftAt(x, z) {
                    // base lift from cloud updraft objects (cloudSystem maintains updrafts)
                    let lift = 0;
                    if (this.clouds && this.clouds.updrafts) {
                        for (const u of this.clouds.updrafts) {
                            if (!u || !u.active) continue;
                            const dist = Math.hypot(x - u.x, z - u.z);
                            if (dist < u.radius) {
                                const f = 1 - dist / u.radius;
                                lift += u.strength * f * Math.min(1, u.age / Math.max(1, u.maxAge));
                            }
                        }
                    }
                    // transient event pulses (localized stronger updrafts)
                    for (let i = this.events.length - 1; i >= 0; i--) {
                        const ev = this.events[i];
                        const d = Math.hypot(x - ev.x, z - ev.z);
                        if (d < ev.radius) {
                            const f2 = 1 - d / ev.radius;
                            lift += ev.strength * f2 * (ev.life / ev.maxLife);
                        }
                        ev.life--;
                        if (ev.life <= 0) this.events.splice(i, 1);
                    }
                    return Math.min(2.0, lift); // allow >1 for strong updrafts but clamp
                }
                // spawn a transient pulse (used by cloud collapse or manual triggers)
                trigger(x, z, strength = 1.2, radius = 12, duration = 60) {
                    this.events.push({ x, z, strength, radius, life: duration, maxLife: duration });
                }
                update() {
                    // gently nudge low-level wind field to simulate organized updraft columns
                    // small inexpensive pass to add vertical hint into wind cells
                    if (!this.wind || !this.wind.field) return;
                    const now = performance.now();
                    const size = this.wind.size;
                    const spacing = this.wind.spacing;
                    for (let gx = 0; gx < size; gx++) {
                        for (let gz = 0; gz < size; gz++) {
                            // sample world position of cell center
                            const wx = (gx - size / 2) * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const up = this.getUpdraftAt(wx, wz);
                            if (up > 0.001) {
                                // apply a small upward proxy stored on the cell for other systems to read
                                for (let gy = 0; gy < Math.min(6, size); gy++) {
                                    const cell = this.wind.field[gx][gy][gz];
                                    cell.__updraft = (cell.__updraft || 0) + up * 0.002 * (1 + (6 - gy) * 0.08);
                                }
                            }
                        }
                    }
                    // decay __updraft markers over time
                    for (let gx = 0; gx < this.wind.size; gx++) {
                        for (let gy = 0; gy < Math.min(6, this.wind.size); gy++) {
                            for (let gz = 0; gz < this.wind.size; gz++) {
                                const c = this.wind.field[gx][gy][gz];
                                if (c && c.__updraft) {
                                    c.__updraft *= 0.92;
                                }
                            }
                        }
                    }
                }
            })(AppState.windField, AppState.cloudSystem);
            
            AppState.tornadoSystem = new TornadoSystem(AppState.windField, AppState.cloudSystem);

            // Instantiate new frontal & derecho systems
            AppState.warmFrontSystem = new WarmFront(AppState.windField, AppState.cloudSystem);
            AppState.coldFrontSystem = new ColdFront(AppState.windField, AppState.cloudSystem);
            AppState.derechoSystem = new DerechoSystem(AppState.windField, AppState.cloudSystem, AppState.rainSystem);
            
            // SUN, GLARE & GODRAYS (toggleable)
            (function createSunAndGodrays() {
                // Sun directional light reference already added above as 'sun'
                // Create a lens-glare sprite positioned at sun direction for simple glare effect
                const glareCanvas = document.createElement('canvas');
                glareCanvas.width = glareCanvas.height = 256;
                const gctx = glareCanvas.getContext('2d');
                const ggrad = gctx.createRadialGradient(128,128,0,128,128,128);
                ggrad.addColorStop(0, 'rgba(255,255,220,0.95)');
                ggrad.addColorStop(0.2, 'rgba(255,235,190,0.55)');
                ggrad.addColorStop(0.5, 'rgba(255,200,150,0.18)');
                ggrad.addColorStop(1, 'rgba(255,200,150,0)');
                gctx.fillStyle = ggrad;
                gctx.fillRect(0,0,256,256);
                const glareTex = new THREE.CanvasTexture(glareCanvas);
                const glareMat = new THREE.SpriteMaterial({ map: glareTex, color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false, blending: THREE.AdditiveBlending });
                const sunGlare = new THREE.Sprite(glareMat);
                sunGlare.scale.set(80,80,1);
                sunGlare.userData = { enabled: true };
                AppState.scene.add(sunGlare);
                AppState._sunGlare = sunGlare;

                // Simple godrays approximation: a large, low-opacity cone aligned with sun direction, additive blended
                const coneGeo = new THREE.ConeGeometry(120, 260, 16, 1, true);
                coneGeo.translate(0, -130, 0); // pivot top at origin
                const coneMat = new THREE.MeshBasicMaterial({ color: 0xfff8d8, transparent: true, opacity: 0.0, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
                const godrays = new THREE.Mesh(coneGeo, coneMat);
                godrays.userData = { enabled: true, baseOpacity: 0.12 };
                AppState.scene.add(godrays);
                AppState._godrays = godrays;

                // update function to position glare/godrays each frame (attached to AppState for animate loop)
                AppState._updateSunEffects = function() {
                    // Find directional light (sun)
                    const sunLight = AppState.scene.children.find(o => o && o.isDirectionalLight);
                    if (!sunLight) return;
                    // position glare far in sun direction relative to camera so it appears at sun screen position
                    const camPos = AppState.camera.position.clone();
                    const sunDir = sunLight.position.clone().normalize();
                    const glarePos = camPos.clone().sub(sunDir.clone().multiplyScalar(180));
                    if (AppState._sunGlare) {
                        AppState._sunGlare.position.copy(glarePos);
                        // Fresnel-ish fade by angle between sunDir and camera forward
                        const camForward = new THREE.Vector3();
                        AppState.camera.getWorldDirection(camForward);
                        const facing = Math.max(0, -sunDir.dot(camForward));
                        AppState._sunGlare.material.opacity = Graphics.sun ? Math.min(0.98, 0.15 + facing * 1.2) : 0.0;
                    }
                    if (AppState._godrays) {
                        // Position cone so top points toward sun and top is above the scene
                        const target = camPos.clone().sub(sunDir.clone().multiplyScalar(220));
                        AppState._godrays.position.copy(target);
                        // orient cone along sun direction: cone's local -Y points toward world -Y, rotate to face opposite sunDir
                        AppState._godrays.lookAt(camPos);
                        AppState._godrays.material.opacity = Graphics.godrays ? Math.min(0.45, AppState._godrays.userData.baseOpacity * (0.6 + Math.max(0, -sunDir.y) * 1.2)) : 0.0;
                    }
                };
            })();

            setupControls();
            // detect CPU & GPU and display
            (function detectHardware() {
                try {
                    const cpuEl = document.getElementById('cpu');
                    const gpuEl = document.getElementById('gpu');
                    // CPU cores
                    const cores = navigator.hardwareConcurrency || '‚Äî';
                    if (cpuEl) cpuEl.textContent = cores;
                    // GPU via WebGL debug renderer info
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    let renderer = 'Unknown';
                    if (gl) {
                        const dbg = gl.getExtension('WEBGL_debug_renderer_info');
                        if (dbg) {
                            renderer = gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) || renderer;
                        } else {
                            renderer = gl.getParameter(gl.RENDERER) || renderer;
                        }
                    }
                    if (gpuEl) gpuEl.textContent = renderer;
                } catch (e) {
                    console.warn('Hardware detect failed', e);
                }
            })();
        }

        let frames = 0;
        let lastFps = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now();

            // compute delta time in seconds for movement integration
            const dt = ((t - (AppState._lastTime || t)) / 1000) || 0;
            AppState._lastTime = t;

            if (AppState.paused) {
                // Still render the current scene so camera can be moved while paused
                AppState.renderer.render(AppState.scene, AppState.camera);
                return;
            }

            const ws = AppState.windField.update(t);

            // New systems should be updated after the core wind update so they can perturb the field
            if (AppState.warmFrontSystem) AppState.warmFrontSystem.update(t);
            if (AppState.coldFrontSystem) AppState.coldFrontSystem.update(t);
            if (AppState.derechoSystem) AppState.derechoSystem.update(t);

            // Apply downburst effects after base wind update so perturbations persist for this frame
            if (AppState.downburstSystem) AppState.downburstSystem.update(t);
            if (AppState.tornadoSystem) AppState.tornadoSystem.update(t);
            const windSpeed = Math.sqrt(ws.x * ws.x + ws.z * ws.z);
            
            AppState.evaporationSystem.update();
            AppState.cloudSystem.update(t);
            // apply diurnal infrared/temperature update (DayNight)
            const deltaMs = (dt * 1000);
            if (window.DayNight) window.DayNight.update(deltaMs);
            applyDayNightToScene();
            const activePart = AppState.rainSystem.update();
            AppState.lightningSystem.update(t);
            if (AppState.rainbowSystem) AppState.rainbowSystem.update(t);

            // update sun effects (glare & godrays) per-frame
            if (AppState._updateSunEffects) AppState._updateSunEffects();

            // Apply first-person movement based on joystick / forward button inputs
            if (AppState.firstPerson) {
                // movement speed (units per second)
                const baseSpeed = AppState.cameraControls.speed * (AppState.cameraControls.move.forward ? 1 : 1) * (keys && keys['shift'] ? AppState.cameraControls.runMultiplier : 1) || AppState.cameraControls.speed;
                // compute forward/right basis from yaw
                const yaw = AppState.cameraControls.rotation.yaw || 0;
                const forwardVec = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
                const rightVec = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).normalize();
                // apply movement scaled by dt so button hold speed is consistent
                const moveForward = (AppState.cameraControls.move.forward || 0);
                const moveRight = (AppState.cameraControls.move.right || 0);
                AppState.camera.position.addScaledVector(forwardVec, moveForward * baseSpeed * dt * 3.0);
                AppState.camera.position.addScaledVector(rightVec, moveRight * baseSpeed * dt * 3.0);
            }

            // Positional camera shake handling (shake applied to lookAt target)
            const shake = AppState.cameraControls.shake;
            const ctrl = AppState.cameraControls;

            // base camera placement (spherical around center) or FP
            if (!AppState.firstPerson) {
                AppState.camera.position.x = ctrl.distance * Math.sin(ctrl.rotation.theta) * Math.cos(ctrl.rotation.phi);
                AppState.camera.position.y = ctrl.distance * Math.sin(ctrl.rotation.phi);
                AppState.camera.position.z = ctrl.distance * Math.cos(ctrl.rotation.theta) * Math.cos(ctrl.rotation.phi);

                // final lookAt with positional offset (positional shake)
                const baseTarget = { x: 0, y: 20, z: 0 };
                let targetOffset = { x: 0, y: 0, z: 0 };
                if (shake.intensity > 0.001 && (shake.duration > 0 || shake.time < shake.duration)) {
                    shake.time += Math.min(1000 / 60, 16.66);
                    const progress = Math.min(1, shake.time / Math.max(1, shake.duration));
                    const decay = 1 - progress;
                    const freq = shake.frequency || 18;
                    targetOffset.x = (Math.sin(t * 0.001 * freq) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.12 * decay;
                    targetOffset.y = (Math.cos(t * 0.001 * freq * 0.6) * 0.4 + (Math.random() - 0.5) * 0.6) * shake.intensity * 0.06 * decay;
                    targetOffset.z = (Math.cos(t * 0.001 * freq * 1.1) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.12 * decay;
                    shake.intensity *= 0.94;
                    if (shake.time >= shake.duration || shake.intensity < 0.03) {
                        shake.intensity = 0;
                        shake.duration = 0;
                        shake.time = 0;
                    }
                }
                AppState.camera.lookAt(baseTarget.x + targetOffset.x, baseTarget.y + targetOffset.y, baseTarget.z + targetOffset.z);
            } else {
                // First-person view: yaw/pitch applied directly
                // Keep camera at its current position (moved by movement joystick / WASD). Rotate target based on yaw/pitch for look vector.
                const yaw = ctrl.rotation.yaw || 0;
                const pitch = ctrl.rotation.pitch || 0;
                // compute forward target
                const look = new THREE.Vector3(Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), Math.cos(yaw) * Math.cos(pitch));
                const targetPos = new THREE.Vector3().copy(AppState.camera.position).add(look);
                // apply small positional shake to camera position if present
                if (shake.intensity > 0.001 && (shake.duration > 0 || shake.time < shake.duration)) {
                    shake.time += Math.min(1000 / 60, 16.66);
                    const progress = Math.min(1, shake.time / Math.max(1, shake.duration));
                    const decay = 1 - progress;
                    const freq = shake.frequency || 18;
                    const offset = new THREE.Vector3(
                        (Math.sin(t * 0.001 * freq) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.06 * decay,
                        (Math.cos(t * 0.001 * freq * 0.6) * 0.4 + (Math.random() - 0.5) * 0.6) * shake.intensity * 0.03 * decay,
                        (Math.cos(t * 0.001 * freq * 1.1) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.06 * decay
                    );
                    AppState.camera.position.add(offset);
                    targetPos.add(offset);
                    shake.intensity *= 0.94;
                    if (shake.time >= shake.duration || shake.intensity < 0.03) {
                        shake.intensity = 0;
                        shake.duration = 0;
                        shake.time = 0;
                    }
                }
                AppState.camera.lookAt(targetPos);
            }

            AppState.renderer.render(AppState.scene, AppState.camera);

            frames++;
            if (t - lastFps > 1000) {
                document.getElementById('fps').textContent = frames;
                document.getElementById('particles').textContent = activePart;
                document.getElementById('clouds').textContent = AppState.cloudSystem.clouds.length;
                document.getElementById('charge').textContent = Math.floor(AppState.lightningSystem.charge);
                document.getElementById('strikes').textContent = AppState.lightningSystem.count;
                document.getElementById('wind').textContent = windSpeed.toFixed(1);
                // update hardware readout occasionally
                try {
                    const cpuEl = document.getElementById('cpu');
                    const gpuEl = document.getElementById('gpu');
                    if (cpuEl && cpuEl.textContent === '‚Äî') cpuEl.textContent = (navigator.hardwareConcurrency || '‚Äî');
                    // GPU is set at init; no frequent update needed
                } catch (e) {}
                frames = 0;
                lastFps = t;
            }
        }

        function applyGraphicsSettings() {
            // shadows
            AppState.renderer.shadowMap.enabled = Graphics.shadows;
            // also try to set castShadow on directional lights if present
            AppState.scene.traverse(obj => {
                if (obj.isDirectionalLight || obj.isSpotLight || obj.isPointLight) {
                    if (obj.castShadow !== undefined) obj.castShadow = !!Graphics.shadows;
                }
            });
            // particle count adjustment (rain)
            if (AppState.rainSystem) {
                const newMax = Math.max(200, Math.min(3000, Math.floor(Graphics.particleDetail)));
                if (newMax !== AppState.rainSystem.max && typeof AppState.rainSystem.resize === 'function') {
                    AppState.rainSystem.resize(newMax);
                } else {
                    AppState.rainSystem.max = newMax;
                }
                AppState.rainSystem.enableShafts = !!Graphics.rainshafts;
                // control visual shaft visibility
                if (AppState.rainSystem.rainshaftGroup) {
                    AppState.rainSystem.rainshaftGroup.visible = !!Graphics.rainshafts;
                }
            }
            // lightning
            if (AppState.lightningSystem) AppState.lightningSystem.enabled = !!Graphics.lightning;
            // rainbow
            if (AppState.rainbowSystem) AppState.rainbowSystem.enabled = !!Graphics.rainbow;
            // cloud detail - control max clouds
            if (AppState.cloudSystem) {
                const newMaxClouds = Math.max(10, Math.min(200, Math.floor(Graphics.cloudDetail)));
                AppState.cloudSystem.max = newMaxClouds;
                // expose volumetric settings to cloud system for immediate effect
                AppState.cloudSystem.volumetricEnabled = !!Graphics.volumetric;
                AppState.cloudSystem.volumetricDensity = Number(Graphics.volumetricDensity);
                AppState.cloudSystem.volumetricResolution = Number(Graphics.volumetricResolution);
                // if there are too many clouds right now, prune oldest/dying ones
                if (AppState.cloudSystem.clouds.length > newMaxClouds) {
                    const excess = AppState.cloudSystem.clouds.length - newMaxClouds;
                    // remove oldest (largest age) or dying clouds first
                    AppState.cloudSystem.clouds.sort((a,b) => (b.dying?1:0) - (a.dying?1:0) || b.age - a.age);
                    for (let i = 0; i < excess; i++) {
                        const c = AppState.cloudSystem.clouds.pop();
                        if (c && c.grp) {
                            // dispose meshes inside group
                            c.puffs.forEach(p => {
                                if (!p) return;
                                if (p.geometry) p.geometry.dispose();
                                if (p.material) p.material.dispose();
                            });
                            AppState.cloudSystem.group.remove(c.grp);
                        }
                    }
                }
            }
            // ensure cloud system is aware of render mode and volumetric toggles
            if (AppState.cloudSystem) {
                AppState.cloudSystem.renderMode = Graphics.cloudRenderMode;
                AppState.cloudSystem.volumetricEnabled = !!Graphics.volumetric;
                AppState.cloudSystem.volumetricDensity = Number(Graphics.volumetricDensity);
                AppState.cloudSystem.volumetricResolution = Number(Graphics.volumetricResolution);

                // rebuild existing cloud puffs to apply new render mode immediately
                AppState.cloudSystem.clouds.forEach(c => {
                    if (!c || !c.grp || !c.puffs) return;
                    c.puffs.forEach(p => {
                        if (!p) return;
                        c.grp.remove(p);
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                    });
                    c.puffs = [];
                });
            }
            // evaporation multiplier
            if (AppState.evaporationSystem) {
                AppState.evaporationSystem.multiplier = Number(Graphics.evapMultiplier) || 1;
            }
            // Sun glare & godrays toggles: set material opacities from Graphics flags immediately
            if (AppState._sunGlare && AppState._sunGlare.material) {
                AppState._sunGlare.material.opacity = Graphics.sun ? AppState._sunGlare.material.opacity || 0.35 : 0.0;
            }
            if (AppState._godrays && AppState._godrays.material) {
                AppState._godrays.material.opacity = Graphics.godrays ? AppState._godrays.userData.baseOpacity : 0.0;
            }
            // pixel ratio
            if (AppState.renderer) {
                const pr = Math.max(0.5, Math.min(2, Number(Graphics.pixelRatio)));
                AppState.renderer.setPixelRatio(pr);
                AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        init();
        animate();

        // wire graphics UI controls to Graphics object and apply settings
        (function setupGraphicsUI() {
            const shadowToggle = document.getElementById('shadow-toggle');
            const rainshaftToggle = document.getElementById('rainshaft-toggle');
            const lightningToggle = document.getElementById('lightning-toggle');
            const particleRange = document.getElementById('particle-range');
            const cloudRange = document.getElementById('cloud-range');
            const pxRange = document.getElementById('px-range');
            const cloudModeSelect = document.getElementById('cloud-mode');
            const evapRange = document.getElementById('evap-range');
            // add Sun & Godrays toggles
            const sunContainer = document.createElement('div');
            sunContainer.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
            const sunLabel = document.createElement('div'); sunLabel.textContent = 'Sun Glare';
            const sunChk = document.createElement('input'); sunChk.type = 'checkbox'; sunChk.id = 'sun-toggle'; sunChk.checked = true;
            sunContainer.appendChild(sunLabel); sunContainer.appendChild(sunChk);
            const gfxBox = document.getElementById('graphics') || document.querySelector('.ui-panel#graphics');
            if (gfxBox) gfxBox.insertBefore(sunContainer, gfxBox.firstChild.nextSibling);

            const godContainer = document.createElement('div');
            godContainer.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
            const godLabel = document.createElement('div'); godLabel.textContent = 'Godrays';
            const godChk = document.createElement('input'); godChk.type = 'checkbox'; godChk.id = 'godray-toggle'; godChk.checked = true;
            godContainer.appendChild(godLabel); godContainer.appendChild(godChk);
            if (gfxBox) gfxBox.insertBefore(godContainer, sunContainer.nextSibling);

            const rainbowToggle = document.createElement('input');
            rainbowToggle.type = 'checkbox';
            rainbowToggle.id = 'rainbow-toggle';
            // insert rainbow toggle into graphics panel near lightning toggle if that exists
            const lightningRow = document.getElementById('lightning-toggle');
            if (lightningRow && lightningRow.parentElement) {
                const container = document.createElement('div');
                container.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
                const label = document.createElement('div');
                label.textContent = 'Rainbows';
                container.appendChild(label);
                container.appendChild(rainbowToggle);
                lightningRow.parentElement.insertBefore(container, lightningRow.parentElement.children[lightningRow.parentElement.children.length - 1] || null);
            } else {
                // fallback: append to graphics group
                const gbox = document.getElementById('graphics');
                if (gbox) {
                    const container = document.createElement('div');
                    container.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
                    const label = document.createElement('div');
                    label.textContent = 'Rainbows';
                    container.appendChild(label);
                    container.appendChild(rainbowToggle);
                    gbox.appendChild(container);
                }
            }

            if (shadowToggle) {
                shadowToggle.addEventListener('change', () => {
                    Graphics.shadows = shadowToggle.checked;
                    applyGraphicsSettings();
                });
            }
            if (rainshaftToggle) {
                rainshaftToggle.addEventListener('change', () => {
                    Graphics.rainshafts = rainshaftToggle.checked;
                    applyGraphicsSettings();
                });
            }
            if (lightningToggle) {
                lightningToggle.addEventListener('change', () => {
                    Graphics.lightning = lightningToggle.checked;
                    applyGraphicsSettings();
                });
            }
            if (particleRange) {
                particleRange.addEventListener('input', () => {
                    Graphics.particleDetail = Number(particleRange.value);
                    applyGraphicsSettings();
                });
            }
            if (cloudRange) {
                cloudRange.addEventListener('input', () => {
                    Graphics.cloudDetail = Number(cloudRange.value);
                    applyGraphicsSettings();
                });
            }
            if (pxRange) {
                pxRange.addEventListener('input', () => {
                    Graphics.pixelRatio = Number(pxRange.value);
                    applyGraphicsSettings();
                });
            }
            if (cloudModeSelect) {
                cloudModeSelect.addEventListener('change', () => {
                    Graphics.cloudRenderMode = cloudModeSelect.value === 'particles' ? 'particles' : 'volumetric';
                    applyGraphicsSettings();
                });
            }
            if (evapRange) {
                evapRange.addEventListener('input', () => {
                    Graphics.evapMultiplier = Number(evapRange.value);
                    applyGraphicsSettings();
                });
            }
            if (document.getElementById('sun-toggle')) {
                document.getElementById('sun-toggle').addEventListener('change', (e) => {
                    Graphics.sun = e.target.checked;
                    applyGraphicsSettings();
                });
            }
            if (document.getElementById('godray-toggle')) {
                document.getElementById('godray-toggle').addEventListener('change', (e) => {
                    Graphics.godrays = e.target.checked;
                    applyGraphicsSettings();
                });
            }
            if (rainbowToggle) {
                rainbowToggle.addEventListener('change', () => {
                    Graphics.rainbow = rainbowToggle.checked;
                    applyGraphicsSettings();
                });
            }

            // initialize from current UI values
            if (shadowToggle) Graphics.shadows = shadowToggle.checked;
            if (rainshaftToggle) Graphics.rainshafts = rainshaftToggle.checked;
            if (lightningToggle) Graphics.lightning = lightningToggle.checked;
            if (rainbowToggle) Graphics.rainbow = rainbowToggle.checked !== undefined ? rainbowToggle.checked : true;
            if (particleRange) Graphics.particleDetail = Number(particleRange.value);
            if (cloudRange) Graphics.cloudDetail = Number(cloudRange.value);
            if (pxRange) Graphics.pixelRatio = Number(pxRange.value);
            if (cloudModeSelect) Graphics.cloudRenderMode = cloudModeSelect.value === 'particles' ? 'particles' : 'volumetric';
            if (evapRange) Graphics.evapMultiplier = Number(evapRange.value);
            Graphics.sun = document.getElementById('sun-toggle') ? document.getElementById('sun-toggle').checked : true;
            Graphics.godrays = document.getElementById('godray-toggle') ? document.getElementById('godray-toggle').checked : true;

            applyGraphicsSettings();
        })();

        // Mobile joystick using nipplejs (esm.sh) - left = movement, right = look
        (async () => {
            try {
                const { default: nipplejs } = await import('https://esm.sh/nipplejs@0.9.0');
                // create invisible zones for two joysticks
                const moveZone = document.createElement('div');
                moveZone.id = 'joy-move';
                moveZone.className = 'joy-zone';
                document.body.appendChild(moveZone);

                const lookZone = document.createElement('div');
                lookZone.id = 'joy-look';
                lookZone.className = 'joy-zone';
                document.body.appendChild(lookZone);

                const mgrMove = nipplejs.create({ zone: moveZone, mode: 'static', position: { left: '60px', top: '60px' }, color: '#6cf' });
                const mgrLook = nipplejs.create({ zone: lookZone, mode: 'static', position: { right: '60px', top: '60px' }, color: '#6cf' });

                // Movement joystick: controls forward/back and strafing
                let moveActive = false;
                mgrMove.on('start', () => moveActive = true);
                mgrMove.on('end', () => {
                    moveActive = false;
                    AppState.cameraControls.move.forward = 0;
                    AppState.cameraControls.move.right = 0;
                });
                mgrMove.on('move', (evt, data) => {
                    if (!moveActive || !data) return;
                    const force = data.force || 0;
                    const angle = data.angle && data.angle.radian !== undefined ? data.angle.radian : 0;
                    // project joystick vector to forward/right in FP orientation
                    const vx = Math.cos(angle) * force;
                    const vy = Math.sin(angle) * force;
                    // map to forward and right axes (invert y so up = forward)
                    AppState.cameraControls.move.forward = -vy * 1.4;
                    AppState.cameraControls.move.right = vx * 1.4;
                });

                // Look joystick: controls yaw/pitch when in FP or orbit rotation otherwise
                let lookActive = false;
                mgrLook.on('start', () => lookActive = true);
                mgrLook.on('end', () => lookActive = false);
                mgrLook.on('move', (evt, data) => {
                    if (!lookActive || !data) return;
                    const vx = data.vector.x || 0;
                    const vy = data.vector.y || 0;
                    if (AppState.firstPerson) {
                        AppState.cameraControls.rotation.yaw -= vx * 0.06;
                        AppState.cameraControls.rotation.pitch -= vy * 0.05;
                        AppState.cameraControls.rotation.pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, AppState.cameraControls.rotation.pitch));
                    } else {
                        AppState.cameraControls.rotation.theta -= vx * 0.03;
                        AppState.cameraControls.rotation.phi -= vy * 0.02;
                        AppState.cameraControls.rotation.phi = Math.max(0.08, Math.min(Math.PI / 2.2, AppState.cameraControls.rotation.phi));
                    }
                    // optional zoom with pushing look joystick forward/back
                    if (data.distance) {
                        AppState.cameraControls.distance = Math.max(20, Math.min(AppState.cameraControls.maxDistance || 300, AppState.cameraControls.distance + vy * 0.8));
                    }
                });
            } catch (err) {
                console.warn('Joystick failed to load:', err);
            }
        })();

        // FP toggle wiring
        (function setupFPToggle() {
            const btn = document.getElementById('fp-toggle');
            function setFP(enabled) {
                AppState.firstPerson = !!enabled;
                btn.classList.toggle('active', AppState.firstPerson);
                btn.textContent = AppState.firstPerson ? 'FP Mode: ON' : 'FP Mode';
                // when switching to FP, position camera to a reasonable height if far out
                if (AppState.firstPerson) {
                    // move camera to ground-level viewpoint preserving current orbit focus direction
                    const theta = AppState.cameraControls.rotation.theta || 0;
                    const phi = AppState.cameraControls.rotation.phi || 0;
                    AppState.cameraControls.rotation.yaw = theta;
                    AppState.cameraControls.rotation.pitch = (phi - Math.PI/2) * -1 * 0.9; // convert orbit pitch to FP pitch approx
                    // place camera near terrain height 1.6 * scale
                    AppState.camera.position.set(0, 2.0, 0);
                } else {
                    // move back to orbit camera default distance
                    AppState.cameraControls.rotation.theta = AppState.cameraControls.rotation.yaw || 0;
                    AppState.cameraControls.rotation.phi = Math.max(0.12, Math.min(Math.PI / 2.2, Math.PI/2 - (AppState.cameraControls.rotation.pitch || 0)));
                    AppState.camera.position.set(
                        AppState.cameraControls.distance * Math.sin(AppState.cameraControls.rotation.theta) * Math.cos(AppState.cameraControls.rotation.phi),
                        AppState.cameraControls.distance * Math.sin(AppState.cameraControls.rotation.phi),
                        AppState.cameraControls.distance * Math.cos(AppState.cameraControls.rotation.theta) * Math.cos(AppState.cameraControls.rotation.phi)
                    );
                }
            }
            btn.addEventListener('click', () => setFP(!AppState.firstPerson));
            // initialize state
            setFP(false);
        })();

        // Reset simulation: clear clouds, rain, lightning, downbursts and reset counters
        function resetSimulation() {
            // clear clouds
            if (AppState.cloudSystem) {
                AppState.cloudSystem.clouds.forEach(c => {
                    if (!c) return;
                    c.puffs.forEach(p => {
                        if (!p) return;
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                    });
                    if (c.grp) AppState.cloudSystem.group.remove(c.grp);
                });
                AppState.cloudSystem.clouds = [];
                AppState.cloudSystem.clusterCenters = [];
                AppState.cloudSystem.updrafts = [];
            }

            // clear precipitation
            if (AppState.rainSystem) {
                for (let i = 0; i < AppState.rainSystem.max; i++) {
                    AppState.rainSystem.drops[i] = { active: false };
                    AppState.rainSystem.pos[i * 3] = 0;
                    AppState.rainSystem.pos[i * 3 + 1] = -1000;
                    AppState.rainSystem.pos[i * 3 + 2] = 0;
                }
                AppState.rainSystem.rain.geometry.attributes.position.needsUpdate = true;
            }

            // clear lightning
            if (AppState.lightningSystem) {
                AppState.lightningSystem.bolts.forEach(b => {
                    if (b.geometry) b.geometry.dispose();
                    if (b.material) b.material.dispose();
                    AppState.scene.remove(b);
                });
                AppState.lightningSystem.bolts = [];
                AppState.lightningSystem.charge = 0;
                AppState.lightningSystem.count = 0;
            }

            // clear downbursts
            if (AppState.downburstSystem) AppState.downburstSystem.events = [];

            // reset camera to safe orbit
            AppState.firstPerson = false;
            document.getElementById('fp-toggle').classList.remove('active');
            document.getElementById('fp-toggle').textContent = 'FP Mode';
            AppState.camera.position.set(0, 25, 70);
            AppState.cameraControls.distance = 70;
            AppState.cameraControls.rotation.theta = 0;
            AppState.cameraControls.rotation.phi = Math.PI / 5.5;
        }

        document.getElementById('reset-btn').addEventListener('click', () => {
            resetSimulation();
        });

        // Forward button wiring (touch / hold)
        (function setupForwardButton() {
            const fbtn = document.getElementById('forward-btn');
            if (!fbtn) return;
            let pointerActive = false;
            const setForward = (v) => { AppState.cameraControls.move.forward = v ? 1 : 0; };
            fbtn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                pointerActive = true;
                setForward(true);
            });
            window.addEventListener('pointerup', (e) => {
                if (!pointerActive) return;
                pointerActive = false;
                setForward(false);
            });
            // also support touchend/cancel
            fbtn.addEventListener('pointercancel', () => { pointerActive = false; setForward(false); });
            // keyboard 'w' already sets move.forward via updateKeyboardMovement; ensure releasing W stops movement
        })();
    </script>
</body>
</html>