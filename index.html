<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Storm Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Courier New', monospace; }
        #canvas-container { width: 100vw; height: 100vh; }
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 16px;
            border-radius: 12px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #stats { top: 16px; left: 16px; }
        #controls { bottom: 16px; left: 16px; font-size: 12px; }
        #info { bottom: 16px; right: 16px; font-size: 12px; }
        #toggle-gui {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }
        #toggle-gui:hover { background: rgba(0, 0, 0, 0.9); }
        .stat-value { color: #6cf; font-weight: bold; }
        .hidden { display: none; }
        .title { color: #6cf; font-weight: bold; margin-bottom: 12px; }
        /* Pause button styling */
        #pause-btn {
            position: absolute;
            top: 16px;
            right: 120px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }
        #pause-btn:hover { background: rgba(0, 0, 0, 0.9); }
        #graphics {
            position: absolute;
            right: 16px;
            top: 120px;
            width: 220px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 16px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #shadow-toggle, #rainshaft-toggle, #lightning-toggle, #particle-range, #cloud-range, #px-range {
            margin-left: auto;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="stats" class="ui-panel">
        <div class="title">‚ö° Storm Dynamics</div>
        <div>FPS: <span class="stat-value" id="fps">0</span></div>
        <div>Raindrops: <span class="stat-value" id="particles">0</span></div>
        <div>Clouds: <span class="stat-value" id="clouds">0</span></div>
        <div>Charge: <span class="stat-value" id="charge">0</span>%</div>
        <div>Strikes: <span class="stat-value" id="strikes">0</span></div>
        <div>Wind: <span class="stat-value" id="wind">0</span> m/s</div>
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 11px; color: #888;">
            <div>‚Ä¢ Clouds form over water</div>
            <div>‚Ä¢ Evaporation & condensation</div>
            <div>‚Ä¢ Wind-driven cloud movement</div>
            <div>‚Ä¢ Dynamic precipitation</div>
            <div>‚Ä¢ Branching lightning</div>
        </div>
    </div>
    <div id="controls" class="ui-panel">
        <div style="color: #ccc; margin-bottom: 8px; font-weight: bold;">Controls</div>
        <div style="color: #aaa; font-size: 11px;">
            <div>üñ±Ô∏è <strong>Mouse Drag</strong> - Rotate camera</div>
            <div>üñ≤Ô∏è <strong>Mouse Wheel</strong> - Zoom in/out</div>
            <div>üëÜ <strong>Touch Drag</strong> - Rotate camera</div>
            <div>ü§è <strong>Pinch</strong> - Zoom in/out</div>
            <div>‚å®Ô∏è <strong>H Key</strong> - Hide/Show GUI</div>
        </div>
    </div>
    <div id="graphics" class="ui-panel" style="right:16px; top:120px; width:220px;">
        <div style="color:#6cf; font-weight:bold; margin-bottom:8px;">Graphics</div>
        <div style="font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>Shadows</div>
            <input id="shadow-toggle" type="checkbox" checked />
        </div>
        <div style="font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>Rainshafts</div>
            <input id="rainshaft-toggle" type="checkbox" checked />
        </div>
        <div style="font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>Lightning</div>
            <input id="lightning-toggle" type="checkbox" checked />
        </div>
        <div style="font-size:12px; color:#ddd; margin-bottom:8px;">
            <div style="margin-bottom:4px;">Particle Detail</div>
            <input id="particle-range" type="range" min="200" max="3000" step="100" value="300" style="width:100%;" />
        </div>
        <div style="font-size:12px; color:#ddd; margin-bottom:8px;">
            <div style="margin-bottom:4px;">Cloud Detail</div>
            <input id="cloud-range" type="range" min="10" max="200" step="10" value="50" style="width:100%;" />
        </div>
        <div style="font-size:12px; color:#ddd;">
            <div style="margin-bottom:4px;">Pixel Ratio</div>
            <input id="px-range" type="range" min="0.5" max="2" step="0.1" value="1" style="width:100%;" />
        </div>
    </div>
    <div id="info" class="ui-panel">
        <div style="color: #6cf; font-weight: bold;">Storm Simulator v5.0</div>
        <div style="color: #888;">Physically Based Weather</div>
    </div>
    <button id="pause-btn">‚è∏ Pause</button>
    <button id="toggle-gui">üëÅÔ∏è Hide GUI</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global state
        const AppState = {
            scene: null,
            camera: null,
            renderer: null,
            showGui: true,
            windField: null,
            cloudSystem: null,
            rainSystem: null,
            lightningSystem: null,
            evaporationSystem: null,
            waterBodies: [],
            paused: false,
            cameraControls: {
                isDrag: false,
                prevMouse: { x: 0, y: 0 },
                rotation: { theta: 0, phi: Math.PI / 5.5 },
                distance: 70,
                shake: { x: 0, y: 0, z: 0, intensity: 0 }
            }
        };

        // Graphics settings defaults
        const Graphics = {
            shadows: true,
            rainshafts: true,
            lightning: true,
            particleDetail: 300,
            cloudDetail: 50,
            pixelRatio: 1
        };

        function createTerrain() {
            const geo = new THREE.PlaneGeometry(400, 400, 100, 100);
            const pos = geo.attributes.position.array;
            const col = new Float32Array(pos.length);

            AppState.waterBodies = [
                { x: 0, y: 0, r: 50, d: -2 },
                { x: -80, y: 60, r: 35, d: -1.5 },
                { x: 100, y: -70, r: 40, d: -1.8 }
            ];

            for (let i = 0; i < pos.length; i += 3) {
                const x = pos[i];
                const y = pos[i + 1];
                let z = Math.sin(x * 0.02) * Math.cos(y * 0.03) * 2;
                let isWater = false;

                for (const w of AppState.waterBodies) {
                    const dist = Math.sqrt((x - w.x) ** 2 + (y - w.y) ** 2);
                    if (dist < w.r) {
                        z += w.d * (1 - dist / w.r);
                        isWater = true;
                        break;
                    }
                }

                pos[i + 2] = z;
                col[i] = isWater ? 0.2 : 0.4;
                col[i + 1] = isWater ? 0.4 : 0.6;
                col[i + 2] = isWater ? 0.7 : 0.3;
            }

            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.8,
                metalness: 0.2
            }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            AppState.scene.add(ground);
        }

        class EvaporationSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 500;
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.maxParticles * 3);
                this.sizes = new Float32Array(this.maxParticles);
                this.opacities = new Float32Array(this.maxParticles);
                
                for (let i = 0; i < this.maxParticles; i++) {
                    this.particles.push({ active: false, life: 0 });
                    this.positions[i * 3] = 0;
                    this.positions[i * 3 + 1] = -100;
                    this.positions[i * 3 + 2] = 0;
                    this.sizes[i] = 0;
                    this.opacities[i] = 0;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.opacities, 1));
                
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Multi-layer gradient for wispy vapor
                const grad1 = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                grad1.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                grad1.addColorStop(0.3, 'rgba(240, 248, 255, 0.5)');
                grad1.addColorStop(0.7, 'rgba(220, 235, 250, 0.2)');
                grad1.addColorStop(1, 'rgba(200, 220, 240, 0)');
                ctx.fillStyle = grad1;
                ctx.fillRect(0, 0, 64, 64);
                
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2.5,
                    transparent: true,
                    opacity: 0.5,
                    map: new THREE.CanvasTexture(canvas),
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.points = new THREE.Points(this.geometry, material);
                AppState.scene.add(this.points);
            }

            spawnEvaporation(x, z) {
                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) {
                        const idx = i * 3;
                        this.positions[idx] = x + (Math.random() - 0.5) * 10;
                        this.positions[idx + 1] = 0.3;
                        this.positions[idx + 2] = z + (Math.random() - 0.5) * 10;
                        
                        this.particles[i] = {
                            active: true,
                            life: 1.0,
                            vx: (Math.random() - 0.5) * 0.03,
                            vy: 0.06 + Math.random() * 0.08,
                            vz: (Math.random() - 0.5) * 0.03,
                            maxHeight: 6 + Math.random() * 10,
                            size: 0.8 + Math.random() * 1.2
                        };
                        this.sizes[i] = this.particles[i].size;
                        this.opacities[i] = 0.5;
                        break;
                    }
                }
            }

            update() {
                // More frequent evaporation
                if (Math.random() < 0.5) {
                    const water = AppState.waterBodies[Math.floor(Math.random() * AppState.waterBodies.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * water.r * 0.95;
                    this.spawnEvaporation(
                        water.x + Math.cos(angle) * radius,
                        water.y + Math.sin(angle) * radius
                    );
                }

                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) continue;
                    
                    const p = this.particles[i];
                    const idx = i * 3;
                    
                    // Expand and rise
                    this.positions[idx] += p.vx;
                    this.positions[idx + 1] += p.vy;
                    this.positions[idx + 2] += p.vz;
                    
                    p.life -= 0.008;
                    this.sizes[i] = p.size * (2 - p.life);
                    this.opacities[i] = p.life * 0.6;
                    
                    // Slow down as it rises
                    p.vy *= 0.98;
                    
                    if (p.life <= 0 || this.positions[idx + 1] > p.maxHeight) {
                        p.active = false;
                        this.positions[idx + 1] = -100;
                        this.sizes[i] = 0;
                        this.opacities[i] = 0;
                    }
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
                this.geometry.attributes.alpha.needsUpdate = true;
            }
        }

        class WindField {
            constructor() {
                this.size = 15;
                this.spacing = 8;
                this.field = [];
                this.time = 0;
                
                for (let x = 0; x < this.size; x++) {
                    this.field[x] = [];
                    for (let y = 0; y < this.size; y++) {
                        this.field[x][y] = [];
                        for (let z = 0; z < this.size; z++) {
                            this.field[x][y][z] = { x: 0, y: 0, z: 0 };
                        }
                    }
                }
            }

            update(t) {
                this.time = t * 0.0001;
                let avg = { x: 0, z: 0, c: 0 };
                
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        for (let z = 0; z < this.size; z++) {
                            const wx = (x - this.size / 2) * this.spacing;
                            const wy = y * this.spacing;
                            const wz = (z - this.size / 2) * this.spacing;
                            
                            const vx = Math.sin(wx * 0.03 + this.time) * Math.cos(wz * 0.02 + this.time * 0.5) * 2.5;
                            const vz = Math.cos(wx * 0.02 + this.time * 0.6) * Math.sin(wz * 0.03 + this.time) * 2.0;
                            
                            this.field[x][y][z] = { x: vx, y: 0, z: vz };
                            
                            if (y > 3 && y < 8) {
                                avg.x += vx;
                                avg.z += vz;
                                avg.c++;
                            }
                        }
                    }
                }
                
                return { x: avg.x / avg.c, z: avg.z / avg.c };
            }

            getAt(x, y, z) {
                const gx = Math.floor((x / this.spacing) + this.size / 2);
                const gy = Math.floor(y / this.spacing);
                const gz = Math.floor((z / this.spacing) + this.size / 2);
                
                if (gx < 0 || gx >= this.size - 1 || gy < 0 || gy >= this.size - 1 || gz < 0 || gz >= this.size - 1) {
                    return { x: 0, y: 0, z: 0 };
                }
                
                const fx = (x / this.spacing) + this.size / 2 - gx;
                const c0 = this.field[gx][gy][gz];
                const c1 = this.field[gx + 1][gy][gz];
                
                return { 
                    x: (c0.x * (1 - fx) + c1.x * fx) * 0.03, 
                    y: 0, 
                    z: c0.z * 0.03 
                };
            }
        }

        class CloudGrowth {
            constructor() {
                this.clouds = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.timer = 0;
                this.max = 50;
                this.clusterCenters = [];
                this.updrafts = [];
            }

            createUpdraft(x, z, strength) {
                return {
                    x, z,
                    strength: strength,
                    radius: 20 + Math.random() * 15,
                    height: 0,
                    maxHeight: 35 + Math.random() * 10,
                    age: 0,
                    maxAge: 200 + Math.random() * 150,
                    active: true
                };
            }

            getUpdraftAt(x, z) {
                let totalLift = 0;
                for (const updraft of this.updrafts) {
                    if (!updraft.active) continue;
                    const dist = Math.sqrt((x - updraft.x) ** 2 + (z - updraft.z) ** 2);
                    if (dist < updraft.radius) {
                        const factor = 1 - (dist / updraft.radius);
                        totalLift += updraft.strength * factor * (updraft.age / updraft.maxAge);
                    }
                }
                return totalLift;
            }

            isOverWater(x, z) {
                for (const w of AppState.waterBodies) {
                    if (Math.sqrt((x - w.x) ** 2 + (z - w.y) ** 2) < w.r) return true;
                }
                return false;
            }

            findNearestCluster(x, z, maxDist = 25) {
                let nearest = null;
                let minDist = maxDist;
                
                for (const cluster of this.clusterCenters) {
                    const dist = Math.sqrt((x - cluster.x) ** 2 + (z - cluster.z) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = cluster;
                    }
                }
                
                return nearest;
            }

            createCluster(x, z) {
                const cluster = {
                    x, z,
                    strength: 0.7 + Math.random() * 0.3,
                    age: 0,
                    maxAge: 400 + Math.random() * 300,
                    hasUpdraft: false
                };
                this.clusterCenters.push(cluster);
                return cluster;
            }

            makePuff(x, y, z, size, dark, turbulence = 0) {
                const geo = new THREE.SphereGeometry(size, 12, 12);
                
                // Highly varied shapes for realistic cumulus appearance
                const scaleX = 0.85 + Math.random() * 0.5 + turbulence * 0.15;
                const scaleY = 0.8 + Math.random() * 0.7 + turbulence * 0.25;
                const scaleZ = 0.9 + Math.random() * 0.6 + turbulence * 0.2;
                geo.scale(scaleX, scaleY, scaleZ);
                
                // Realistic cloud coloring - bright white tops, darker bases
                const heightFactor = Math.max(0, (y - 12) / 25);
                const topBrightness = 0.95 + heightFactor * 0.05;
                const baseBrightness = 0.75 - dark * 0.4;
                const b = baseBrightness + (topBrightness - baseBrightness) * heightFactor;
                
                // Use Lambert for soft, realistic lighting
                const mat = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(b, b, b + 0.02),
                    transparent: true,
                    opacity: 0.45 + dark * 0.25 + turbulence * 0.1,
                    depthWrite: false
                });
                mat.fog = true;

                const m = new THREE.Mesh(geo, mat);
                m.position.set(x, y, z);
                m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                m.castShadow = true;
                m.receiveShadow = true;
                return m;
            }

            grow(x, z) {
                if (!this.isOverWater(x, z)) return null;
                
                // Variable width for different cloud types - slightly wider by default
                const widthFactor = 1.1 + Math.random() * 0.8; // 1.1 to 1.9
                
                const c = {
                    x, z, age: 0, 
                    maxAge: 400 + Math.random() * 300,
                    baseHeight: 12,
                    height: 12,
                    cloudTop: 12,
                    cloudBase: 10,
                    puffs: [], 
                    grp: new THREE.Group(), 
                    dying: false,
                    cluster: null,
                    growthRate: 0.025 + Math.random() * 0.025,
                    mass: 0,
                    condensationLevel: 0,
                    turbulence: 0,
                    velocity: { x: 0, z: 0 },
                    targetVelocity: { x: 0, z: 0 },
                    radius: 2,
                    widthFactor: widthFactor,
                    horizontalSpread: 1.2,
                    mergeTimer: 0,
                    canMerge: true,
                    verticalVelocity: 0,
                    buoyancy: 0.5 + Math.random() * 0.5,
                    stage: 'cumulus'
                };
                c.grp.position.set(x, 0, z);
                this.group.add(c.grp);
                return c;
            }

            checkMerge(cloud1, cloud2) {
                const dist = Math.sqrt((cloud1.x - cloud2.x) ** 2 + (cloud1.z - cloud2.z) ** 2);
                const mergeRadius = (cloud1.radius * cloud1.horizontalSpread + cloud2.radius * cloud2.horizontalSpread) * 0.7;
                
                if (dist < mergeRadius && cloud1.canMerge && cloud2.canMerge && 
                    cloud1.age > 50 && cloud2.age > 50 &&
                    Math.abs(cloud1.height - cloud2.height) < 8) {
                    return true;
                }
                return false;
            }

            mergeClouds(cloud1, cloud2) {
                const totalMass = cloud1.mass + cloud2.mass;
                
                // Transfer mass and properties
                cloud1.mass += cloud2.mass * 0.85;
                
                // Merge radii like 3D terrain - additive volume
                const volume1 = Math.PI * cloud1.radius * cloud1.radius * cloud1.horizontalSpread;
                const volume2 = Math.PI * cloud2.radius * cloud2.radius * cloud2.horizontalSpread;
                const totalVolume = volume1 + volume2;
                cloud1.radius = Math.sqrt(totalVolume / (Math.PI * cloud1.horizontalSpread)) * 0.9;
                
                // Average width factors
                cloud1.widthFactor = (cloud1.widthFactor * cloud1.mass + cloud2.widthFactor * cloud2.mass) / totalMass;
                cloud1.horizontalSpread = (cloud1.horizontalSpread + cloud2.horizontalSpread) / 2;
                
                cloud1.maxAge += cloud2.maxAge * 0.4;
                cloud1.condensationLevel = Math.max(cloud1.condensationLevel, cloud2.condensationLevel);
                
                // Smooth position blend (like terrain heightmap merging)
                const blendFactor = cloud2.mass / totalMass;
                cloud1.x = cloud1.x * (1 - blendFactor) + cloud2.x * blendFactor;
                cloud1.z = cloud1.z * (1 - blendFactor) + cloud2.z * blendFactor;
                
                // Blend heights
                cloud1.cloudTop = Math.max(cloud1.cloudTop, cloud2.cloudTop);
                cloud1.cloudBase = Math.min(cloud1.cloudBase, cloud2.cloudBase);
                cloud1.height = cloud1.cloudTop;
                
                // Transfer puffs in a blended manner
                const transferCount = Math.min(8, cloud2.puffs.length);
                for (let i = 0; i < transferCount; i++) {
                    if (cloud2.puffs[i]) {
                        const puff = cloud2.puffs[i];
                        // Adjust puff position relative to new cloud center
                        const offsetX = cloud2.x - cloud1.x;
                        const offsetZ = cloud2.z - cloud1.z;
                        puff.position.x -= offsetX;
                        puff.position.z -= offsetZ;
                        cloud1.puffs.push(puff);
                        cloud1.grp.add(puff);
                    }
                }
                
                // Mark for removal
                cloud2.dying = true;
                cloud2.maxAge = cloud2.age + 10;
                
                // Cooldown
                cloud1.mergeTimer = 150;
                cloud1.canMerge = false;
            }

            update(t) {
                this.timer++;
                
                // Update updrafts
                this.updrafts = this.updrafts.filter(updraft => {
                    updraft.age++;
                    updraft.height = Math.min(updraft.maxHeight, updraft.height + 0.1);
                    if (updraft.age > updraft.maxAge) {
                        updraft.active = false;
                        return false;
                    }
                    return true;
                });
                
                // Update cluster centers
                this.clusterCenters = this.clusterCenters.filter(cluster => {
                    cluster.age++;
                    
                    // Create updraft for mature clusters
                    if (cluster.age === 50 && !cluster.hasUpdraft && Math.random() > 0.3) {
                        this.updrafts.push(this.createUpdraft(cluster.x, cluster.z, 0.8 + Math.random() * 0.4));
                        cluster.hasUpdraft = true;
                    }
                    
                    return cluster.age < cluster.maxAge;
                });
                
                // Spawn new clouds
                if (this.timer % 25 === 0 && this.clouds.length < this.max) {
                    const w = AppState.waterBodies[Math.floor(Math.random() * AppState.waterBodies.length)];
                    const a = Math.random() * Math.PI * 2;
                    const r = Math.random() * w.r * 0.8;
                    let spawnX = w.x + Math.cos(a) * r;
                    let spawnZ = w.y + Math.sin(a) * r;
                    
                    // Cloud clumping logic
                    const nearCluster = this.findNearestCluster(spawnX, spawnZ);
                    
                    if (nearCluster && Math.random() < 0.7) {
                        const clumpAngle = Math.random() * Math.PI * 2;
                        const clumpDist = 5 + Math.random() * 15;
                        spawnX = nearCluster.x + Math.cos(clumpAngle) * clumpDist;
                        spawnZ = nearCluster.z + Math.sin(clumpAngle) * clumpDist;
                    } else if (Math.random() < 0.3) {
                        const newCluster = this.createCluster(spawnX, spawnZ);
                    }
                    
                    const c = this.grow(spawnX, spawnZ);
                    if (c) {
                        c.cluster = nearCluster;
                        this.clouds.push(c);
                    }
                }

                // Check for cloud merging
                for (let i = 0; i < this.clouds.length; i++) {
                    for (let j = i + 1; j < this.clouds.length; j++) {
                        if (this.checkMerge(this.clouds[i], this.clouds[j])) {
                            this.mergeClouds(this.clouds[i], this.clouds[j]);
                            break;
                        }
                    }
                }

                this.clouds = this.clouds.filter(c => {
                    c.age++;
                    
                    // Update merge timer
                    if (c.mergeTimer > 0) {
                        c.mergeTimer--;
                        if (c.mergeTimer === 0) c.canMerge = true;
                    }
                    
                    // Realistic cloud movement
                    const windAt = AppState.windField.getAt(c.x, c.height, c.z);
                    c.targetVelocity.x = windAt.x * 0.5;
                    c.targetVelocity.z = windAt.z * 0.5;
                    
                    // Smooth acceleration
                    c.velocity.x += (c.targetVelocity.x - c.velocity.x) * 0.05;
                    c.velocity.z += (c.targetVelocity.z - c.velocity.z) * 0.05;
                    
                    // Move cloud
                    c.x += c.velocity.x;
                    c.z += c.velocity.z;
                    c.grp.position.x = c.x;
                    c.grp.position.z = c.z;
                    
                    // Add slight drift for mature clouds
                    if (c.mass > 3) {
                        c.x += Math.sin(t * 0.0002 + c.age * 0.01) * 0.02;
                        c.z += Math.cos(t * 0.0002 + c.age * 0.01) * 0.02;
                    }
                    
                    // Enhanced cloud growth system with realistic vertical development
                    const updraftLift = this.getUpdraftAt(c.x, c.z);
                    
                    // Progressive mass accumulation based on condensation
                    c.mass += 0.015 + c.condensationLevel * 0.025 + updraftLift * 0.03;
                    c.condensationLevel = Math.min(1, c.age / 120);
                    c.turbulence = updraftLift * 0.5;
                    c.radius = 2 + c.mass * 0.8;
                    
                    // Dynamic horizontal spread based on stage - ensure clouds aren't too narrow
                    if (c.stage === 'cumulus') {
                        c.horizontalSpread = 1.1 + c.widthFactor * 0.4;
                    } else if (c.stage === 'towering_cumulus') {
                        c.horizontalSpread = 1.0 + c.widthFactor * 0.35;
                    } else if (c.stage === 'cumulonimbus') {
                        c.horizontalSpread = 1.4 + c.widthFactor * 0.45;
                    }
                    
                    // Realistic vertical cloud development
                    const temperature = 1 - (c.height / 40);
                    const moisture = c.condensationLevel;
                    
                    // Buoyancy-driven rise
                    c.buoyancy = (temperature * moisture * 0.8 + updraftLift * 1.5) * (1 - c.age / c.maxAge);
                    c.verticalVelocity += c.buoyancy * 0.02;
                    c.verticalVelocity *= 0.96;
                    
                    // Cloud rises
                    c.cloudTop += c.verticalVelocity;
                    c.height = c.cloudTop;
                    
                    // Base rises more slowly
                    if (c.age > 50) {
                        c.cloudBase += c.verticalVelocity * 0.3;
                    }
                    
                    // Determine cloud stage and growth stage
                    let growthStage = 'developing';
                    
                    if (c.cloudTop < 20) {
                        c.stage = 'cumulus';
                        growthStage = 'developing';
                    } else if (c.cloudTop < 30 && c.mass > 2) {
                        c.stage = 'towering_cumulus';
                        growthStage = 'mature';
                    } else if (c.cloudTop >= 30 && c.mass > 4) {
                        c.stage = 'cumulonimbus';
                        growthStage = 'mature';
                    }
                    
                    if (c.age > c.maxAge * 0.7) {
                        growthStage = 'dissipating';
                        c.stage = 'dissipating';
                    }
                    
                    // Multi-stage growth based on cloud type
                    let effectiveGrowthRate = c.growthRate;
                    if (c.stage === 'cumulus') {
                        effectiveGrowthRate *= (1 + updraftLift * 3);
                    } else if (c.stage === 'towering_cumulus') {
                        effectiveGrowthRate *= (1 + updraftLift * 2);
                    } else if (c.stage === 'cumulonimbus') {
                        effectiveGrowthRate *= (1 + updraftLift * 1.5);
                        if (c.puffs.length % 20 === 0) {
                            const anvilPuff = this.makePuff(
                                (Math.random() - 0.5) * (c.radius + 5),
                                c.cloudTop + 2,
                                (Math.random() - 0.5) * (c.radius + 5),
                                2 + Math.random() * 3,
                                0.2,
                                0
                            );
                            c.puffs.push(anvilPuff);
                            c.grp.add(anvilPuff);
                        }
                    } else if (c.stage === 'dissipating') {
                        effectiveGrowthRate *= 0.3;
                        c.verticalVelocity *= 0.9;
                    }
                    
                    if (c.age < c.maxAge * 0.75) {
                        // Dynamic puff generation
                        let puffInterval = 5;
                        if (updraftLift > 0.5) puffInterval = 2;
                        else if (updraftLift > 0.3) puffInterval = 3;
                        else if (growthStage === 'mature') puffInterval = 4;
                        
                        if (c.age % puffInterval === 0) {
                            const puffCount = (updraftLift > 0.5 && growthStage === 'developing') ? 3 : (updraftLift > 0.5 ? 2 : 1);
                            
                            for (let p = 0; p < puffCount; p++) {
                                const a = Math.random() * Math.PI * 2;
                                const d = Math.sqrt(c.puffs.length) * 0.6 + Math.random() * 1.5;
                                
                                // Height affected by updraft and stage
                                const baseH = c.height + c.age * effectiveGrowthRate;
                                const h = baseH + updraftLift * 5 + (growthStage === 'mature' ? 2 : 0);
                                
                                const dark = Math.min(0.65, (c.age / 200) + c.condensationLevel * 0.3 + (growthStage === 'mature' ? 0.15 : 0));
                                
                                // Create dense, overlapping structure like real cumulus
                                const layerCount = (growthStage === 'mature' || dark > 0.4) ? 3 : 2;
                                for (let layer = 0; layer < layerCount; layer++) {
                                    const angleOffset = (layer * Math.PI * 2) / layerCount;
                                    const radiusOffset = layer * 0.4;
                                    const heightOffset = layer * 0.6 - 0.3;
                                    
                                    const puff = this.makePuff(
                                        Math.cos(a + angleOffset) * (d + radiusOffset), 
                                        h + heightOffset, 
                                        Math.sin(a + angleOffset) * (d + radiusOffset), 
                                        1.8 + Math.random() * 2.8 + updraftLift * 1.2 + (growthStage === 'mature' ? 0.8 : 0), 
                                        dark + layer * 0.08,
                                        c.turbulence
                                    );
                                    c.puffs.push(puff);
                                    c.grp.add(puff);
                                }
                                c.height = h;
                            }
                        }
                    }
                    
                    if (c.age > c.maxAge) {
                        c.dying = true;
                        c.puffs.forEach(p => {
                            if (p && p.material) p.material.opacity *= 0.97;
                        });
                    }
                    
                    // Enhanced animation with turbulence
                    c.puffs.forEach((p, i) => {
                        if (p) {
                            p.rotation.y += 0.0002 + c.turbulence * 0.0005;
                            p.rotation.z += c.turbulence * 0.0003;
                            
                            // Updraft effect on existing puffs
                            const puffLift = this.getUpdraftAt(c.x, c.z) * 0.01;
                            p.position.y += Math.sin(t * 0.0003 + i) * 0.003 + puffLift;
                            
                            // Turbulent motion
                            if (c.turbulence > 0.2) {
                                p.position.x += Math.sin(t * 0.0005 + i) * c.turbulence * 0.02;
                                p.position.z += Math.cos(t * 0.0005 + i) * c.turbulence * 0.02;
                            }
                        }
                    });
                    
                    if (c.dying && c.puffs[0] && c.puffs[0].material && c.puffs[0].material.opacity < 0.05) {
                        c.puffs.forEach(p => {
                            if (p) {
                                if (p.geometry) p.geometry.dispose();
                                if (p.material) p.material.dispose();
                            }
                        });
                        this.group.remove(c.grp);
                        return false;
                    }
                    
                    return true;
                });
            }

            getMature() {
                return this.clouds.filter(c => (c.stage === 'cumulonimbus' || c.stage === 'towering_cumulus') && !c.dying && c.mass > 3);
            }
        }

        class Precipitation {
            constructor(windFieldRef, cloudSystemRef) {
                this.windFieldRef = windFieldRef;
                this.cloudSystemRef = cloudSystemRef;
                this.max = 3000;
                this.drops = [];
                this.vel = [];
                this.types = [];
                this.enableShafts = true;
                
                const geo = new THREE.BufferGeometry();
                this.pos = new Float32Array(this.max * 3);
                this.sizes = new Float32Array(this.max);
                this.colors = new Float32Array(this.max * 3);
                
                for (let i = 0; i < this.max; i++) {
                    this.drops.push({ active: false });
                    this.vel.push({ y: 0, size: 0 });
                    this.types.push('rain');
                    this.pos[i * 3] = 0;
                    this.pos[i * 3 + 1] = -1000;
                    this.pos[i * 3 + 2] = 0;
                    this.sizes[i] = 0;
                    this.colors[i * 3] = 1;
                    this.colors[i * 3 + 1] = 1;
                    this.colors[i * 3 + 2] = 1;
                }

                geo.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                geo.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                geo.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                
                const canvas = document.createElement('canvas');
                canvas.width = 8;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                
                const grad = ctx.createLinearGradient(0, 0, 0, 32);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.3, 'rgba(220, 240, 255, 0.9)');
                grad.addColorStop(0.7, 'rgba(180, 210, 240, 0.6)');
                grad.addColorStop(1, 'rgba(150, 180, 210, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 8, 32);
                
                const mat = new THREE.PointsMaterial({
                    size: 0.6,
                    transparent: true,
                    opacity: 0.95,
                    map: new THREE.CanvasTexture(canvas),
                    depthWrite: false,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });

                this.rain = new THREE.Points(geo, mat);
                AppState.scene.add(this.rain);
                
                this.createStreakSystem();

                // Group for visual rainshafts
                this.rainshaftGroup = new THREE.Group();
                AppState.scene.add(this.rainshaftGroup);
            }

            createStreakSystem() {
                this.streakGeometry = new THREE.BufferGeometry();
                const streakPositions = new Float32Array(200 * 6);
                this.streakGeometry.setAttribute('position', new THREE.BufferAttribute(streakPositions, 3));
                
                const streakMaterial = new THREE.LineBasicMaterial({
                    color: 0xaaccff,
                    transparent: true,
                    opacity: 0.3,
                    linewidth: 1
                });
                
                this.streakLines = new THREE.LineSegments(this.streakGeometry, streakMaterial);
                AppState.scene.add(this.streakLines);
            }

            // resize rain buffers to new capacity
            resize(newMax) {
                // clamp
                newMax = Math.max(200, Math.min(3000, Math.floor(newMax)));
                if (newMax === this.max) return;
                // preserve active drops up to newMax
                const oldMax = this.max;
                const oldPos = this.pos;
                const oldSizes = this.sizes;
                const oldColors = this.colors;
                const oldDrops = this.drops;
                const oldVel = this.vel;
                const oldTypes = this.types;

                this.max = newMax;
                this.drops = [];
                this.vel = [];
                this.types = [];
                this.pos = new Float32Array(this.max * 3);
                this.sizes = new Float32Array(this.max);
                this.colors = new Float32Array(this.max * 3);

                for (let i = 0; i < this.max; i++) {
                    if (i < oldMax && oldDrops[i] && oldDrops[i].active) {
                        // copy
                        const idx = i * 3;
                        this.drops.push({ active: true });
                        this.vel.push(oldVel[i]);
                        this.types.push(oldTypes[i]);
                        this.pos[idx] = oldPos[idx];
                        this.pos[idx + 1] = oldPos[idx + 1];
                        this.pos[idx + 2] = oldPos[idx + 2];
                        this.sizes[i] = oldSizes[i];
                        this.colors[idx] = oldColors[idx];
                        this.colors[idx + 1] = oldColors[idx + 1];
                        this.colors[idx + 2] = oldColors[idx + 2];
                    } else {
                        this.drops.push({ active: false });
                        this.vel.push({ y: 0, size: 0 });
                        this.types.push('rain');
                        const idx = i * 3;
                        this.pos[idx] = 0;
                        this.pos[idx + 1] = -1000;
                        this.pos[idx + 2] = 0;
                        this.sizes[i] = 0;
                        this.colors[idx] = 1;
                        this.colors[idx + 1] = 1;
                        this.colors[idx + 2] = 1;
                    }
                }

                // update geometry attribute buffers
                this.rain.geometry.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                this.rain.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.rain.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.rain.geometry.attributes.position.needsUpdate = true;
                this.rain.geometry.attributes.size.needsUpdate = true;
                this.rain.geometry.attributes.color.needsUpdate = true;
                this.streakGeometry.attributes.position.needsUpdate = true;
            }

            getTemperature(altitude) {
                // Standard atmosphere: ~15¬∞C at sea level, decreases ~6.5¬∞C per km
                const seaLevelTemp = 15;
                const lapseRate = 6.5;
                return seaLevelTemp - (altitude / 1000) * lapseRate;
            }

            determinePrecipType(temperature, altitude) {
                // Complex precipitation type determination
                if (temperature < -5) {
                    // Snow
                    return 'snow';
                } else if (temperature < 0 && altitude > 15) {
                    // Ice pellets/sleet
                    return 'sleet';
                } else if (temperature < 2 && Math.random() < 0.3) {
                    // Freezing rain
                    return 'freezing_rain';
                } else {
                    // Rain
                    return 'rain';
                }
            }

            spawn(cloud) {
                if (!cloud) return;
                const cx = cloud.x;
                const cz = cloud.z;
                const h = cloud.height - 1;
                const radius = Math.max(5, cloud.radius * 0.8); // local shaft radius

                for (let i = 0; i < this.max; i++) {
                    if (!this.drops[i].active) {
                        const idx = i * 3;
                        // Localized within a circular shaft under the cloud
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * radius;
                        this.pos[idx] = cx + Math.cos(angle) * r;
                        this.pos[idx + 1] = h;
                        this.pos[idx + 2] = cz + Math.sin(angle) * r;
                        
                        const temp = this.getTemperature(h);
                        const precipType = this.determinePrecipType(temp, h);
                        this.types[i] = precipType;
                        
                        // Set properties based on type
                        let s, fallSpeed, color;
                        
                        if (precipType === 'snow') {
                            s = 1.2 + Math.random() * 2.0;
                            fallSpeed = 0.15 + (s / 4) * 0.2;
                            color = { r: 1.0, g: 1.0, b: 1.0 };
                        } else if (precipType === 'sleet') {
                            s = 0.8 + Math.random() * 1.2;
                            fallSpeed = 0.25 + (s / 3) * 0.4;
                            color = { r: 0.9, g: 0.95, b: 1.0 };
                        } else if (precipType === 'freezing_rain') {
                            s = 0.7 + Math.random() * 2.0;
                            fallSpeed = 0.3 + (s / 3) * 0.5;
                            color = { r: 0.8, g: 0.9, b: 1.0 };
                        } else {
                            s = 0.6 + Math.random() * 2.8;
                            fallSpeed = 0.35 + (s / 3) * 0.7;
                            color = { r: 0.9, g: 0.95, b: 1.0 };
                        }
                        
                        this.vel[i] = { y: fallSpeed, size: s };
                        this.sizes[i] = s * 0.2;
                        this.colors[idx] = color.r;
                        this.colors[idx + 1] = color.g;
                        this.colors[idx + 2] = color.b;
                        this.drops[i] = { active: true };
                        break;
                    }
                }
            }

            update() {
                const mature = this.cloudSystemRef.getMature();
                
                // Clear previous rainshafts
                if (this.enableShafts) {
                    while (this.rainshaftGroup.children.length > 0) {
                        const child = this.rainshaftGroup.children.pop();
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                } else {
                    // quickly remove any shafts if disabled
                    while (this.rainshaftGroup.children.length > 0) this.rainshaftGroup.remove(this.rainshaftGroup.children.pop());
                }

                if (mature.length > 0) {
                    mature.forEach((c, idx) => {
                        // Complex rainshaft: visual volumetric columns under mature clouds
                        const intensity = Math.min(1.0, (c.mass / 6) * c.condensationLevel);
                        const shaftRadius = Math.max(5, c.radius * 0.9);
                        const shaftHeight = c.height - 0.5;

                        if (this.enableShafts && intensity > 0.15 && shaftHeight > 2) {
                            const shaftGeo = new THREE.CylinderGeometry(
                                shaftRadius * 0.7,
                                shaftRadius * 1.1,
                                shaftHeight,
                                16,
                                1,
                                true
                            );
                            const shaftMat = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(0.55, 0.65, 0.8),
                                transparent: true,
                                opacity: 0.3 * intensity,
                                depthWrite: false,
                                side: THREE.DoubleSide
                            });
                            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
                            shaft.position.set(c.x, shaftHeight * 0.5, c.z);

                            // Tilt shaft slightly with low-level wind for realism
                            const nearGroundWind = this.windFieldRef.getAt(c.x, 2, c.z);
                            shaft.rotation.z = nearGroundWind.x * 0.15;
                            shaft.rotation.x = -nearGroundWind.z * 0.15;

                            this.rainshaftGroup.add(shaft);
                        }

                        // Particle precipitation intensity tied to cloud properties
                        const dropCount = 8 + Math.floor(intensity * 30);
                        for (let i = 0; i < dropCount; i++) {
                            this.spawn(c);
                        }
                    });
                }

                let active = 0;
                let streakIdx = 0;
                const streakPos = this.streakGeometry.attributes.position.array;
                
                for (let i = 0; i < this.max; i++) {
                    if (!this.drops[i].active) continue;
                    
                    const idx = i * 3;
                    const altitude = this.pos[idx + 1];
                    const w = this.windFieldRef.getAt(this.pos[idx], altitude, this.pos[idx + 2]);
                    
                    const oldY = altitude;
                    
                    // Wind effect varies by precipitation type
                    let windResistance = 1.0;
                    if (this.types[i] === 'snow') {
                        windResistance = 3.0; // Snow drifts more
                    } else if (this.types[i] === 'sleet') {
                        windResistance = 1.5;
                    }
                    
                    this.pos[idx + 1] -= this.vel[i].y;
                    this.pos[idx] += w.x * windResistance * (1 / this.vel[i].size);
                    this.pos[idx + 2] += w.z * windResistance * (1 / this.vel[i].size);
                    
                    // Temperature changes as it falls
                    const currentTemp = this.getTemperature(altitude);
                    
                    // Phase transitions
                    if (this.types[i] === 'snow' && currentTemp > 2 && altitude < 10) {
                        // Snow melting to rain
                        this.types[i] = 'rain';
                        this.vel[i].y = 0.35 + (this.vel[i].size / 3) * 0.7;
                        this.colors[idx] = 0.9;
                        this.colors[idx + 1] = 0.95;
                        this.colors[idx + 2] = 1.0;
                    }
                    
                    // Create streak lines for fast drops
                    if (streakIdx < 200 && this.vel[i].y > 0.5 && Math.random() < 0.15 && this.types[i] !== 'snow') {
                        const si = streakIdx * 6;
                        streakPos[si] = this.pos[idx];
                        streakPos[si + 1] = oldY;
                        streakPos[si + 2] = this.pos[idx + 2];
                        streakPos[si + 3] = this.pos[idx];
                        streakPos[si + 4] = this.pos[idx + 1];
                        streakPos[si + 5] = this.pos[idx + 2];
                        streakIdx++;
                    }
                    
                    if (this.pos[idx + 1] < 0.5) {
                        this.drops[i].active = false;
                        this.pos[idx] = 0;
                        this.pos[idx + 1] = -1000;
                        this.pos[idx + 2] = 0;
                        this.sizes[i] = 0;
                    } else {
                        active++;
                    }
                }
                
                for (let i = streakIdx * 6; i < 200 * 6; i++) {
                    streakPos[i] = 0;
                }
                
                this.rain.geometry.attributes.position.needsUpdate = true;
                this.rain.geometry.attributes.size.needsUpdate = true;
                this.rain.geometry.attributes.color.needsUpdate = true;
                this.streakGeometry.attributes.position.needsUpdate = true;
                return active;
            }
        }

        class Lightning {
            constructor(cloudSystemRef) {
                this.cloudSystemRef = cloudSystemRef;
                this.bolts = [];
                this.charge = 0;
                this.threshold = 100;
                this.last = 0;
                this.count = 0;
                this.flash = new THREE.PointLight(0xddeeff, 0, 200);
                AppState.scene.add(this.flash);
                this.enabled = true;
            }

            createSteppedLeader(sx, sy, sz, ex, ey, ez) {
                const segments = [];
                const steps = 25 + Math.floor(Math.random() * 10);
                let currentX = sx, currentY = sy, currentZ = sz;
                
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const targetX = sx + (ex - sx) * t;
                    const targetY = sy + (ey - sy) * t - Math.pow(t, 1.5) * 5;
                    const targetZ = sz + (ez - sz) * t;
                    
                    // Stepped leader movement
                    const stepSize = 2 + Math.random() * 3;
                    const chaos = (1 - Math.abs(t - 0.5) * 2) * 6;
                    
                    currentX += (targetX - currentX) * 0.3 + (Math.random() - 0.5) * chaos;
                    currentY += (targetY - currentY) * 0.3 + (Math.random() - 0.5) * stepSize;
                    currentZ += (targetZ - currentZ) * 0.3 + (Math.random() - 0.5) * chaos;
                    
                    segments.push(new THREE.Vector3(currentX, currentY, currentZ));
                }
                
                return segments;
            }

            createBranch(originPoint, depth = 0, maxDepth = 3) {
                if (depth >= maxDepth || Math.random() > 0.7) return;
                
                const branches = 1 + Math.floor(Math.random() * 2);
                
                for (let b = 0; b < branches; b++) {
                    const branchLength = 8 + Math.random() * 12 * (1 - depth / maxDepth);
                    const branchSteps = 6 + Math.floor(Math.random() * 6);
                    const branchPoints = [];
                    
                    let bx = originPoint.x;
                    let by = originPoint.y;
                    let bz = originPoint.z;
                    
                    const angleH = Math.random() * Math.PI * 2;
                    const angleV = (Math.random() - 0.3) * Math.PI * 0.5;
                    
                    for (let i = 0; i <= branchSteps; i++) {
                        const t = i / branchSteps;
                        const len = branchLength * t;
                        
                        bx += Math.cos(angleH) * Math.cos(angleV) * (branchLength / branchSteps) + (Math.random() - 0.5) * 2;
                        by -= Math.sin(angleV) * (branchLength / branchSteps) + Math.random() * 1.5;
                        bz += Math.sin(angleH) * Math.cos(angleV) * (branchLength / branchSteps) + (Math.random() - 0.5) * 2;
                        
                        branchPoints.push(new THREE.Vector3(bx, by, bz));
                    }
                    
                    const opacity = 0.7 - depth * 0.15;
                    const branchGeom = new THREE.BufferGeometry().setFromPoints(branchPoints);
                    const branchMat = new THREE.LineBasicMaterial({
                        color: 0xccddff,
                        transparent: true,
                        opacity: opacity,
                        linewidth: 2
                    });
                    
                    const branch = new THREE.Line(branchGeom, branchMat);
                    branch.userData.life = 0.9 - depth * 0.1;
                    AppState.scene.add(branch);
                    this.bolts.push(branch);
                    
                    // Recursive branching
                    if (Math.random() > 0.5) {
                        this.createBranch(branchPoints[Math.floor(branchPoints.length / 2)], depth + 1, maxDepth);
                    }
                }
            }

            makeBolt(sx, sy, sz, ex, ey, ez) {
                // Main channel with stepped leader
                const mainPath = this.createSteppedLeader(sx, sy, sz, ex, ey, ez);
                
                const mainGeom = new THREE.BufferGeometry().setFromPoints(mainPath);
                const mainMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1,
                    linewidth: 3
                });

                const mainBolt = new THREE.Line(mainGeom, mainMat);
                mainBolt.userData.life = 1.0;
                mainBolt.userData.isMain = true;
                AppState.scene.add(mainBolt);
                this.bolts.push(mainBolt);

                // Create glow effect
                const glowGeom = new THREE.BufferGeometry().setFromPoints(mainPath);
                const glowMat = new THREE.LineBasicMaterial({
                    color: 0xaaccff,
                    transparent: true,
                    opacity: 0.4,
                    linewidth: 5
                });
                const glow = new THREE.Line(glowGeom, glowMat);
                glow.userData.life = 0.8;
                AppState.scene.add(glow);
                this.bolts.push(glow);

                // Create complex branching from multiple points
                const branchPoints = [
                    Math.floor(mainPath.length * 0.2),
                    Math.floor(mainPath.length * 0.4),
                    Math.floor(mainPath.length * 0.6),
                    Math.floor(mainPath.length * 0.8)
                ];

                branchPoints.forEach(idx => {
                    if (Math.random() > 0.3) {
                        this.createBranch(mainPath[idx], 0, 2);
                    }
                });

                // Add return stroke (bright flash along main path)
                setTimeout(() => {
                    if (mainBolt && mainBolt.material) {
                        mainBolt.material.opacity = 1.2;
                        mainBolt.material.emissive = new THREE.Color(0xffffff);
                        mainBolt.material.emissiveIntensity = 2;
                    }
                }, 50);
            }

            strike() {
                if (!this.enabled) return;
                const mature = this.cloudSystemRef.getMature();
                if (mature.length === 0) return;
                
                const c = mature[Math.floor(Math.random() * mature.length)];
                const sx = c.x + (Math.random() - 0.5) * 10;
                const sz = c.z + (Math.random() - 0.5) * 10;
                
                // Cloud-to-ground strike
                this.makeBolt(sx, c.height + 5, sz, sx + (Math.random() - 0.5) * 25, 0.5, sz + (Math.random() - 0.5) * 25);
                
                // Occasional cloud-to-cloud
                if (Math.random() > 0.6 && mature.length > 1) {
                    const c2 = mature[Math.floor(Math.random() * mature.length)];
                    this.makeBolt(
                        sx, c.height + 3, sz,
                        c2.x + (Math.random() - 0.5) * 8, c2.height + 2, c2.z + (Math.random() - 0.5) * 8
                    );
                }
                
                this.flash.intensity = 35;
                this.flash.position.set(sx, c.height, sz);
                this.count++;
                this.last = performance.now();
                
                // Intense camera shake
                const dist = Math.sqrt(sx * sx + sz * sz);
                const shakeIntensity = Math.max(0.5, 2 - dist / 80);
                AppState.cameraControls.shake.intensity = 2 + shakeIntensity * 4;
                AppState.cameraControls.shake.duration = 0;
            }

            update(t) {
                if (!this.enabled) {
                    // decay existing bolts quickly
                    this.bolts.forEach(b => b.userData && (b.userData.life -= 0.08));
                }
                const mature = this.cloudSystemRef.getMature();
                this.charge += 0.25 * mature.length;
                
                if (this.charge > this.threshold && t - this.last > 1200 && mature.length > 0) {
                    if (Math.random() > 0.4) {
                        this.strike();
                        this.charge = Math.random() * 40;
                    }
                }

                this.flash.intensity *= 0.75;
                
                this.bolts = this.bolts.filter(b => {
                    const fadeSpeed = b.userData.isMain ? 0.15 : 0.12;
                    b.userData.life -= fadeSpeed;
                    b.material.opacity = b.userData.life;
                    
                    if (b.userData.life <= 0) {
                        AppState.scene.remove(b);
                        if (b.geometry) b.geometry.dispose();
                        if (b.material) b.material.dispose();
                        return false;
                    }
                    return true;
                });
            }
        }

        // Downburst system: creates short-lived strong downward/outward winds under intense mature clouds
        class Downburst {
            constructor(windFieldRef, cloudSystemRef) {
                this.windField = windFieldRef;
                this.cloudSystem = cloudSystemRef;
                this.events = []; // active downbursts
                this.cooldown = 0;
            }

            // schedule a downburst at (x,z) with strength and radius
            trigger(x, z, strength = 6, radius = 20, duration = 180) {
                this.events.push({
                    x, z, strength, radius, life: duration, maxLife: duration,
                    created: performance.now()
                });
            }

            // inject a transient perturbation into the wind field for low levels
            applyToWind(event) {
                // affect a subset of windField cells near ground (gy = 0..3)
                const s = event.strength;
                const r = event.radius;
                const size = this.windField.size;
                const spacing = this.windField.spacing;

                for (let gx = 0; gx < size; gx++) {
                    for (let gy = 0; gy < Math.min(4, size); gy++) {
                        for (let gz = 0; gz < size; gz++) {
                            const wx = (gx - size / 2) * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const dist = Math.sqrt((wx - event.x) ** 2 + (wz - event.z) ** 2);
                            if (dist < r) {
                                const factor = 1 - dist / r;
                                // downward gust: negative y component stored in extra prop; we convert to horizontal push outward
                                const push = s * factor * (event.life / event.maxLife);
                                // radial outward horizontal vector
                                const dx = (wx - event.x) / (dist + 0.0001);
                                const dz = (wz - event.z) / (dist + 0.0001);
                                // apply as a temporary additive perturbation to the cell
                                this.windField.field[gx][gy][gz].x += dx * push * 0.5;
                                this.windField.field[gx][gy][gz].z += dz * push * 0.5;
                            }
                        }
                    }
                }
            }

            // occasionally spawn downbursts from very mature, heavy clouds
            update(t) {
                // cooldown reduces chance spam
                if (this.cooldown > 0) this.cooldown--;

                // check mature clouds and randomly trigger events when heavy updrafts collapse
                const mature = this.cloudSystem.getMature();
                mature.forEach(c => {
                    // high mass and sudden age spike can cause collapse -> downburst chance
                    if (c.mass > 6 && Math.random() < 0.0009 && this.cooldown === 0) {
                        const x = c.x + (Math.random() - 0.5) * 6;
                        const z = c.z + (Math.random() - 0.5) * 6;
                        const strength = 6 + Math.random() * 6;
                        const radius = Math.max(12, c.radius * 0.9 + Math.random() * 8);
                        const dur = 120 + Math.floor(Math.random() * 120);
                        this.trigger(x, z, strength, radius, dur);
                        this.cooldown = 600 + Math.floor(Math.random() * 400);
                        // camera shake for dramatic effect
                        AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, 1.8);
                    }
                });

                // apply active events to wind field and age them
                for (let i = this.events.length - 1; i >= 0; i--) {
                    const ev = this.events[i];
                    // stronger effect at start
                    this.applyToWind(ev);
                    ev.life--;
                    // visual subtle ground flash: small point light for a moment when starting
                    if (ev.life === ev.maxLife - 1) {
                        const flash = new THREE.PointLight(0xaad6ff, 0.8, ev.radius * 1.6);
                        flash.position.set(ev.x, 8, ev.z);
                        AppState.scene.add(flash);
                        // fade the flash quickly
                        setTimeout(() => {
                            flash.intensity = 0.2;
                            setTimeout(() => {
                                AppState.scene.remove(flash);
                                if (flash.dispose) flash.dispose();
                            }, 300);
                        }, 120);
                    }
                    if (ev.life <= 0) this.events.splice(i, 1);
                }
            }
        }

        function setupControls() {
            // Mouse controls
            AppState.renderer.domElement.addEventListener('mousedown', e => {
                AppState.cameraControls.isDrag = true;
                AppState.cameraControls.prevMouse = { x: e.clientX, y: e.clientY };
            });

            AppState.renderer.domElement.addEventListener('mousemove', e => {
                if (!AppState.cameraControls.isDrag) return;
                const dx = e.clientX - AppState.cameraControls.prevMouse.x;
                const dy = e.clientY - AppState.cameraControls.prevMouse.y;
                AppState.cameraControls.rotation.theta -= dx * 0.005;
                AppState.cameraControls.rotation.phi -= dy * 0.005;
                AppState.cameraControls.rotation.phi = Math.max(0.1, Math.min(Math.PI / 2.2, AppState.cameraControls.rotation.phi));
                AppState.cameraControls.prevMouse = { x: e.clientX, y: e.clientY };
            });

            AppState.renderer.domElement.addEventListener('mouseup', () => {
                AppState.cameraControls.isDrag = false;
            });

            AppState.renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                AppState.cameraControls.distance = Math.max(35, Math.min(150, AppState.cameraControls.distance + e.deltaY * 0.08));
            }, { passive: false });

            // Touch controls
            let touchStartPos = null;
            let touchStartDist = null;

            AppState.renderer.domElement.addEventListener('touchstart', e => {
                if (e.touches.length === 1) {
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDist = Math.sqrt(dx * dx + dy * dy);
                }
            });

            AppState.renderer.domElement.addEventListener('touchmove', e => {
                e.preventDefault();
                
                if (e.touches.length === 1 && touchStartPos) {
                    const dx = e.touches[0].clientX - touchStartPos.x;
                    const dy = e.touches[0].clientY - touchStartPos.y;
                    AppState.cameraControls.rotation.theta -= dx * 0.005;
                    AppState.cameraControls.rotation.phi -= dy * 0.005;
                    AppState.cameraControls.rotation.phi = Math.max(0.1, Math.min(Math.PI / 2.2, AppState.cameraControls.rotation.phi));
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2 && touchStartDist) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const delta = touchStartDist - dist;
                    AppState.cameraControls.distance = Math.max(35, Math.min(150, AppState.cameraControls.distance + delta * 0.5));
                    touchStartDist = dist;
                }
            }, { passive: false });

            AppState.renderer.domElement.addEventListener('touchend', () => {
                touchStartPos = null;
                touchStartDist = null;
            });

            // Keyboard controls
            window.addEventListener('keypress', e => {
                if (e.key === 'h' || e.key === 'H') {
                    AppState.showGui = !AppState.showGui;
                    // hide/show UI panels (keep the toggle button and pause button visible)
                    ['stats', 'controls', 'info', 'graphics'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.classList.toggle('hidden', !AppState.showGui);
                    });
                    // update toggle button text (but do NOT hide the toggle button itself)
                    document.getElementById('toggle-gui').textContent = AppState.showGui ? 'üëÅÔ∏è Hide GUI' : 'üëÅÔ∏è Show GUI';
                }
            });

            document.getElementById('toggle-gui').addEventListener('click', () => {
                const e = new KeyboardEvent('keypress', { key: 'h' });
                window.dispatchEvent(e);
            });

            // Pause button
            const pauseBtn = document.getElementById('pause-btn');
            pauseBtn.addEventListener('click', () => {
                AppState.paused = !AppState.paused;
                pauseBtn.textContent = AppState.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
            });

            // Graphics UI bindings
            const shadowToggle = document.getElementById('shadow-toggle');
            const rainToggle = document.getElementById('rainshaft-toggle');
            const lightningToggle = document.getElementById('lightning-toggle');
            const particleRange = document.getElementById('particle-range');
            const cloudRange = document.getElementById('cloud-range');
            const pxRange = document.getElementById('px-range');

            shadowToggle.addEventListener('change', e => {
                Graphics.shadows = e.target.checked;
                applyGraphicsSettings();
            });
            rainToggle.addEventListener('change', e => {
                Graphics.rainshafts = e.target.checked;
                applyGraphicsSettings();
            });
            lightningToggle.addEventListener('change', e => {
                Graphics.lightning = e.target.checked;
                applyGraphicsSettings();
            });
            particleRange.addEventListener('input', e => {
                Graphics.particleDetail = Number(e.target.value);
                applyGraphicsSettings();
            });
            cloudRange.addEventListener('input', e => {
                Graphics.cloudDetail = Number(e.target.value);
                applyGraphicsSettings();
            });
            pxRange.addEventListener('input', e => {
                Graphics.pixelRatio = Number(e.target.value);
                applyGraphicsSettings();
            });

            window.addEventListener('resize', () => {
                AppState.camera.aspect = window.innerWidth / window.innerHeight;
                AppState.camera.updateProjectionMatrix();
                AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function init() {
            AppState.scene = new THREE.Scene();
            AppState.scene.background = new THREE.Color(0x5a7a95);
            AppState.scene.fog = new THREE.Fog(0x5a7a95, 100, 350);

            AppState.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            AppState.camera.position.set(0, 25, 70);

            AppState.renderer = new THREE.WebGLRenderer({ antialias: true });
            AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            AppState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            AppState.renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(AppState.renderer.domElement);

            const ambient = new THREE.AmbientLight(0x808fa0, 1.2);
            AppState.scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xfffae6, 1.5);
            sun.position.set(60, 50, 80);
            sun.castShadow = true;
            sun.shadow.camera.left = sun.shadow.camera.bottom = -70;
            sun.shadow.camera.right = sun.shadow.camera.top = 70;
            sun.shadow.mapSize.width = sun.shadow.mapSize.height = 1024;
            AppState.scene.add(sun);

            const back = new THREE.DirectionalLight(0xffd9a8, 0.8);
            back.position.set(-50, 40, -60);
            AppState.scene.add(back);

            createTerrain();
            
            AppState.windField = new WindField();
            AppState.evaporationSystem = new EvaporationSystem();
            AppState.cloudSystem = new CloudGrowth();
            AppState.rainSystem = new Precipitation(AppState.windField, AppState.cloudSystem);
            AppState.lightningSystem = new Lightning(AppState.cloudSystem);
            AppState.downburstSystem = new Downburst(AppState.windField, AppState.cloudSystem);
            
            setupControls();
        }

        let frames = 0;
        let lastFps = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now();

            if (AppState.paused) {
                // Still render the current scene so camera can be moved while paused
                AppState.renderer.render(AppState.scene, AppState.camera);
                return;
            }

            const ws = AppState.windField.update(t);
            // Apply downburst effects after base wind update so perturbations persist for this frame
            if (AppState.downburstSystem) AppState.downburstSystem.update(t);
            const windSpeed = Math.sqrt(ws.x * ws.x + ws.z * ws.z);
            
            AppState.evaporationSystem.update();
            AppState.cloudSystem.update(t);
            const activePart = AppState.rainSystem.update();
            AppState.lightningSystem.update(t);

            // small camera shake decay handling
            const shake = AppState.cameraControls.shake;
            if (shake.intensity > 0.01) {
                const s = shake.intensity;
                AppState.camera.position.x += (Math.random() - 0.5) * s;
                AppState.camera.position.y += (Math.random() - 0.5) * s * 0.6;
                AppState.camera.position.z += (Math.random() - 0.5) * s;
                shake.intensity *= 0.92;
            } else {
                shake.intensity = 0;
            }

            const ctrl = AppState.cameraControls;
            AppState.camera.position.x = ctrl.distance * Math.sin(ctrl.rotation.theta) * Math.cos(ctrl.rotation.phi);
            AppState.camera.position.y = ctrl.distance * Math.sin(ctrl.rotation.phi);
            AppState.camera.position.z = ctrl.distance * Math.cos(ctrl.rotation.theta) * Math.cos(ctrl.rotation.phi);
            AppState.camera.lookAt(0, 20, 0);

            AppState.renderer.render(AppState.scene, AppState.camera);

            frames++;
            if (t - lastFps > 1000) {
                document.getElementById('fps').textContent = frames;
                document.getElementById('particles').textContent = activePart;
                document.getElementById('clouds').textContent = AppState.cloudSystem.clouds.length;
                document.getElementById('charge').textContent = Math.floor(AppState.lightningSystem.charge);
                document.getElementById('strikes').textContent = AppState.lightningSystem.count;
                document.getElementById('wind').textContent = windSpeed.toFixed(1);
                frames = 0;
                lastFps = t;
            }
        }

        function applyGraphicsSettings() {
            // shadows
            AppState.renderer.shadowMap.enabled = Graphics.shadows;
            // also try to set castShadow on directional lights if present
            AppState.scene.traverse(obj => {
                if (obj.isDirectionalLight || obj.isSpotLight || obj.isPointLight) {
                    if (obj.castShadow !== undefined) obj.castShadow = !!Graphics.shadows;
                }
            });
            // particle count adjustment (rain)
            if (AppState.rainSystem) {
                const newMax = Math.max(200, Math.min(3000, Math.floor(Graphics.particleDetail)));
                if (newMax !== AppState.rainSystem.max && typeof AppState.rainSystem.resize === 'function') {
                    AppState.rainSystem.resize(newMax);
                } else {
                    AppState.rainSystem.max = newMax;
                }
                AppState.rainSystem.enableShafts = !!Graphics.rainshafts;
                // control visual shaft visibility
                if (AppState.rainSystem.rainshaftGroup) {
                    AppState.rainSystem.rainshaftGroup.visible = !!Graphics.rainshafts;
                }
            }
            // lightning
            if (AppState.lightningSystem) AppState.lightningSystem.enabled = !!Graphics.lightning;
            // cloud detail - control max clouds
            if (AppState.cloudSystem) {
                const newMaxClouds = Math.max(10, Math.min(200, Math.floor(Graphics.cloudDetail)));
                AppState.cloudSystem.max = newMaxClouds;
                // if there are too many clouds right now, prune oldest/dying ones
                if (AppState.cloudSystem.clouds.length > newMaxClouds) {
                    const excess = AppState.cloudSystem.clouds.length - newMaxClouds;
                    // remove oldest (largest age) or dying clouds first
                    AppState.cloudSystem.clouds.sort((a,b) => (b.dying?1:0) - (a.dying?1:0) || b.age - a.age);
                    for (let i = 0; i < excess; i++) {
                        const c = AppState.cloudSystem.clouds.pop();
                        if (c && c.grp) {
                            // dispose meshes inside group
                            c.puffs.forEach(p => {
                                if (p) {
                                    if (p.geometry) p.geometry.dispose();
                                    if (p.material) p.material.dispose();
                                }
                            });
                            AppState.cloudSystem.group.remove(c.grp);
                        }
                    }
                }
            }
            // pixel ratio
            if (AppState.renderer) {
                const pr = Math.max(0.5, Math.min(2, Number(Graphics.pixelRatio)));
                AppState.renderer.setPixelRatio(pr);
                AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        init();
        animate();
    </script>
</body>
</html>