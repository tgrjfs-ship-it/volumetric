<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Sandbox</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root{
            --ui-pad: 12px;
            --panel-w: 220px;
            --panel-radius: 10px;
            --panel-bg: rgba(0,0,0,0.68);
            --accent: #6cf;
            --muted: #9aa;
        }
        body { overflow: hidden; font-family: 'Noto Sans', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }

        /* Base panel styling */
        .ui-panel {
            position: absolute;
            background: var(--panel-bg);
            color: white;
            padding: 12px;
            border-radius: var(--panel-radius);
            font-size: 13px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            transition: transform 240ms cubic-bezier(.2,.9,.2,1), opacity 220ms cubic-bezier(.2,.9,.2,1);
            will-change: transform, opacity;
            transform-origin: 0 0;
            box-shadow: 0 8px 22px rgba(0,0,0,0.44);
            max-width: calc(var(--panel-w) + 8px);
            pointer-events: auto;
            z-index: 90;
        }
        .ui-panel.hidden {
            transform: translateY(6px) scale(0.992);
            opacity: 0.02;
            pointer-events: none;
        }

        /* Anchors - ensure non-overlap by using safe offsets */
        #stats { top: var(--ui-pad); left: var(--ui-pad); width: var(--panel-w); }
        #controls { bottom: var(--ui-pad); left: var(--ui-pad); width: var(--panel-w); font-size: 11px; }
        #info { bottom: var(--ui-pad); right: var(--ui-pad); font-size: 12px; width: 200px; text-align: center; }
        #graphics {
            position: absolute;
            right: var(--ui-pad);
            top: calc(var(--ui-pad) * 6 + 40px); /* leave space for top-right controls */
            width: var(--panel-w);
            background: var(--panel-bg);
            color: white;
            padding: 12px;
            border-radius: var(--panel-radius);
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: calc(100vh - 140px);
            overflow: auto;
            z-index: 88;
        }
        .top-right-controls > button {
            transition: transform 160ms cubic-bezier(.2,.9,.2,1), background 140ms ease, box-shadow 160ms ease;
        }
        .top-right-controls > button:active { transform: translateY(0); box-shadow: 0 4px 14px rgba(0,0,0,0.36); }

        /* Top-right grouped controls - fixed cluster to avoid overlapping the graphics panel */
        .top-right-controls {
            position: absolute;
            top: var(--ui-pad);
            right: var(--ui-pad);
            display: flex;
            gap: 8px;
            z-index: 110;
            align-items: center;
            pointer-events: auto;
        }
        .top-right-controls > button {
            background: rgba(0,0,0,0.78);
            color: white;
            border: 1px solid rgba(255,255,255,0.08);
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            min-width: 56px;
            height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 140ms ease, background 140ms ease;
        }
        .top-right-controls > button:hover { transform: translateY(-2px); background: rgba(0,0,0,0.9); }

        #toggle-gui {
            padding: 8px 10px;
        }
        #fp-toggle.active { background: rgba(108, 204, 255, 0.12); color: var(--accent); border-color: rgba(108,204,255,0.14); }

        .stat-value { color: var(--accent); font-weight: 600; }
        .hidden { display: none !important; }
        .title { color: var(--accent); font-weight: 600; margin-bottom: 10px; }

        /* Graphics rows */
        .gfx-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }
        .gfx-label { color: #ddd; font-size: 11px; min-width: 64px; }
        .gfx-row input[type="checkbox"] { cursor: pointer; }
        .gfx-row input[type="range"], .gfx-row select {
            flex: 1;
            padding: 4px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.06);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 11px;
        }
        .gfx-row select { cursor: pointer; }

        /* Reopen button when collapsed */
        #reopen-controls { display: none; }
        body.ui-collapsed #reopen-controls {
            display: block;
            position: absolute;
            left: var(--ui-pad);
            bottom: var(--ui-pad);
            padding: 8px 10px;
            border-radius: 8px;
            background: rgba(0,0,0,0.78);
            color: white;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 150;
            cursor: pointer;
            font-size: 12px;
        }

        /* Joystick zones - keep low opacity but non-overlapping with UI */
        .joy-zone {
            position: absolute;
            width: 120px;
            height: 120px;
            z-index: 60;
            touch-action: none;
            opacity: 0.0001;
        }
        #joy-look { right: calc(var(--ui-pad)); bottom: calc(var(--ui-pad) + 16px); }
        #joy-move { left: calc(var(--ui-pad)); bottom: calc(var(--ui-pad) + 16px); }

        #forward-btn {
            position: absolute;
            right: calc(var(--ui-pad));
            bottom: calc(var(--ui-pad) + 132px);
            width: 72px;
            height: 44px;
            border-radius: 8px;
            background: rgba(0,0,0,0.78);
            color: white;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 120;
            font-size: 12px;
            cursor: pointer;
            transition: all 160ms ease;
        }
        #forward-btn:hover { transform: translateY(-2px); background: rgba(0,0,0,0.9); }

        /* Responsive behavior: stack panels on narrow viewports to avoid overlap */
        @media (max-width: 900px) {
            :root{ --panel-w: 200px; }
            #graphics {
                right: 50%;
                transform: translateX(50%);
                top: calc(var(--ui-pad) + 60px);
                width: calc(90vw - 24px);
                max-height: calc(50vh);
            }
            .top-right-controls { gap: 6px; right: 8px; top: 8px; }
            #stats { left: 8px; top: 8px; width: 44vw; }
            #controls { left: 8px; bottom: 8px; width: 44vw; }
            #info { right: 8px; bottom: 8px; width: 38vw; }
            #forward-btn { right: 12px; bottom: 120px; }
            #joy-look { right: 12px; bottom: 12px; }
            #joy-move { left: 12px; bottom: 12px; }
        }

        @media (max-width: 520px) {
            .ui-panel { padding: 10px; font-size: 12px; border-radius: 8px; }
            #graphics { top: calc(var(--ui-pad) + 56px); width: calc(94vw); left: 3%; transform: none; right: auto; }
            #stats, #controls, #info { width: calc(46vw); }
            #stats { top: 6px; left: 6px; }
            #controls { bottom: 6px; left: 6px; }
            #info { bottom: 6px; right: 6px; width: 40vw; }
            .top-right-controls { right: 6px; top: 6px; }
        }

        /* Enhanced button and slider styling */
        .gfx-row input[type="range"] {
            background: linear-gradient(to right, rgba(108,204,255,0.1), rgba(108,204,255,0.2));
            height: 6px;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .gfx-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6cf, #4db8ff);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(108,204,255,0.4);
            transition: all 140ms ease;
        }
        
        .gfx-row input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            box-shadow: 0 4px 16px rgba(108,204,255,0.6);
        }
        
        .gfx-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6cf, #4db8ff);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(108,204,255,0.4);
            transition: all 140ms ease;
        }
        
        .gfx-row input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.3);
            box-shadow: 0 4px 16px rgba(108,204,255,0.6);
        }
        
        .gfx-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #6cf;
            transition: all 140ms ease;
        }
        
        .gfx-row input[type="checkbox"]:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 4px rgba(108,204,255,0.5));
        }
        
        .gfx-row input[type="checkbox"]:checked {
            filter: drop-shadow(0 0 6px rgba(108,204,255,0.8));
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="stats" class="ui-panel">
        <div class="title">‚ö° Storm Simulation</div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
            <div>FPS: <span class="stat-value" id="fps">0</span></div>
            <div>Time: <span class="stat-value" id="time-display">00:00</span></div>
            <div>Clouds: <span class="stat-value" id="clouds">0</span></div>
            <div>Rain: <span class="stat-value" id="particles">0</span></div>
            <div>Wind: <span class="stat-value" id="wind">0</span>m/s</div>
            <div>Charge: <span class="stat-value" id="charge">0</span>%</div>
            <div>Strikes: <span class="stat-value" id="strikes">0</span></div>
            <div>Frame: <span class="stat-value" id="frame-time">0</span>ms</div>
        </div>
    </div>
    <div id="controls" class="ui-panel">
        <div style="color: #6cf; font-weight: 600; margin-bottom: 8px; font-size: 12px;">Controls</div>
        <div style="color: #aaa; font-size: 11px; line-height: 1.7;">
            üñ±Ô∏è <strong>Drag</strong> to rotate<br>
            üñ≤Ô∏è <strong>Scroll</strong> to zoom<br>
            <strong>H</strong> toggle UI<br>
            <strong>SPACE</strong> pause<br>
            Touch joysticks: look & move
        </div>
    </div>
    <div id="graphics" class="ui-panel">
        <div style="color:#6cf; font-weight:600; margin-bottom:10px; font-size:12px;">‚öôÔ∏è Graphics</div>
        <div class="gfx-row">
            <label class="gfx-label">Shadows</label>
            <input id="shadow-toggle" type="checkbox" checked />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Rainshafts</label>
            <div style="color:#9aa; font-size:11px;">removed</div>
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Rain √ó</label>
            <input id="rain-intensity-range" type="range" min="0.1" max="28" step="0.1" value="1.0" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Evap √ó</label>
            <input id="evap-mult-range" type="range" min="0.2" max="20" step="0.05" value="1.0" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Lightning</label>
            <input id="lightning-toggle" type="checkbox" checked />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Particles</label>
            <input id="particle-range" type="range" min="100" max="14000" step="100" value="600" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Clouds</label>
            <input id="cloud-range" type="range" min="10" max="700" step="10" value="80" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Wind √ó</label>
            <input id="wind-range" type="range" min="0.05" max="10" step="0.05" value="1.0" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">Pixel Ratio</label>
            <input id="px-range" type="range" min="0.25" max="3" step="0.05" value="1" />
        </div>
        <div class="gfx-row">
            <label class="gfx-label">IR √ó</label>
            <input id="ir-range" type="range" min="0.1" max="40" step="0.1" value="1.0" />
        </div>
    </div>
    <div id="info" class="ui-panel">
        <div style="color: #6cf; font-weight: bold; margin-bottom: 2px;">Storm Sim v6.0</div>
        <div style="color: #888; font-size: 10px;">Advanced meteorology</div>
    </div>
    <div class="top-right-controls">
        <button id="pause-btn">‚è∏ Pause</button>
        <button id="fp-toggle">üëÅÔ∏è FP</button>
        <button id="reset-btn">üîÑ</button>
        <button id="toggle-gui">hide</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global state
        const AppState = {
            scene: null,
            camera: null,
            renderer: null,
            showGui: true,
            windField: null,
            cloudSystem: null,
            rainSystem: null,
            lightningSystem: null,
            evaporationSystem: null,
            waterBodies: [],
            paused: false,
            firstPerson: false,
            cameraControls: {
                isDrag: false,
                prevMouse: { x: 0, y: 0 },
                rotation: { yaw: 0, pitch: 0, theta: 0, phi: Math.PI / 5.5 },
                distance: 70,
                maxDistance: 800,
                move: { forward: 0, right: 0 },
                speed: 0.5,
                runMultiplier: 2.0,
                shake: { intensity: 0, duration: 0, frequency: 20, time: 0, targetOffset: { x: 0, y: 0, z: 0 } }
            }
        };

        // small helper to show/hide a persistent performance warning overlay
        (function perfWarningHelpers() {
            AppState._perfWarningEl = null;
            AppState._fpsWarnShown = false;
            AppState._rayWarnShown = false;
            window.showPerfWarning = function (msg, id = 'perf-warning', ttl = 0) {
                try {
                    if (!AppState._perfWarningEl) {
                        const el = document.createElement('div');
                        el.id = id;
                        el.style.cssText = 'position:fixed;left:50%;top:12px;transform:translateX(-50%);background:rgba(200,40,40,0.92);color:white;padding:10px 14px;border-radius:8px;z-index:9999;font-family:Segoe UI,Arial;box-shadow:0 6px 24px rgba(0,0,0,0.5);pointer-events:none';
                        document.body.appendChild(el);
                        AppState._perfWarningEl = el;
                    }
                    AppState._perfWarningEl.textContent = msg;
                    AppState._perfWarningEl.style.opacity = '1';
                    AppState._perfWarningEl.style.display = 'block';
                    if (ttl > 0) {
                        setTimeout(() => {
                            if (AppState._perfWarningEl) AppState._perfWarningEl.style.opacity = '0';
                            setTimeout(() => { if (AppState._perfWarningEl) AppState._perfWarningEl.style.display = 'none'; }, 700);
                        }, ttl);
                    }
                } catch (e) { console.warn('showPerfWarning failed', e); }
            };
            window.hidePerfWarning = function () {
                try {
                    if (AppState._perfWarningEl) {
                        AppState._perfWarningEl.style.opacity = '0';
                        setTimeout(() => { if (AppState._perfWarningEl) AppState._perfWarningEl.style.display = 'none'; }, 700);
                    }
                } catch (e) { }
            };
        })();

        // make keyboard state global so animate() and other modules can read it reliably
        window.keys = window.keys || {};

        // Graphics settings defaults
        const Graphics = {
            shadows: false,
            rainshafts: false,
            lightning: true,
            particleDetail: 300,
            cloudDetail: 50,
            pixelRatio: 1,
            volumetric: true,
            volumetricDensity: 0.45,
            volumetricResolution: 12,
            cloudRenderMode: 'volumetric',
            evapMultiplier: 1,
            hailDensity: 1.2,
            windLayerComplexity: 2.0,
            microphysicsDetail: 1.5,
            atmosphericStability: true,
            windMultiplier: 1.0,
            renderDistance: 260,
            rainIntensity: 1.0,
            evapMultiplier: 1.0,
            irMultiplier: 1.0,
            // new toggles
            rayTracing: false,
            greenhouse: 0.0, // extra global warming degrees
            performanceWarningSeen: false,
            windVectors: false,
            sun: true,
            godrays: true,
            rainbow: true,
            rainFog: true,
            simSpeed: 1.0,
            // NEW: charge accumulation multiplier for lightning system
            chargeMultiplier: 1.0,
            // NEW: V-Sync toggle - when true use renderer.setAnimationLoop which syncs to display vsync
            vsync: true,
            // NEW toggles for UI
            fog: true,
            buildingLights: true
        };

        // environmental helper: temperature (¬∞C) and humidity (0..1) estimate at position
        function sampleEnvironment(x, z, altitude = 12) {
            // simple lapse rate: 15¬∞C at sea level, -6.5¬∞C per km
            // include day/night infrared offset (DayNight.tempOffset applied globally)
            const baseSeaTemp = 30 + (window.DayNight ? (window.DayNight.tempOffset || 0) : 0);
            const temp = baseSeaTemp - (altitude / 1000) * 6.5;
            // humidity base: higher near water bodies, falloff with distance
            let h = 0.25; // background humidity
            for (const w of AppState.waterBodies || []) {
                const dist = Math.sqrt((x - w.x) ** 2 + (z - w.y) ** 2);
                const influence = Math.max(0, 1 - dist / (w.r * 2.5));
                h = Math.max(h, 0.6 * influence + 0.25);
            }
            // add small stochastic / diurnal variation based on position to avoid uniformity
            // humidity slightly decreases when hotter (day) and increases at night when cooler
            const diurnalHumidityAdj = window.DayNight ? -0.06 * Math.max(0, window.DayNight.dayStrength) + 0.04 * Math.max(0, 1 - window.DayNight.dayStrength) : 0;
            h = Math.min(1, h + Math.sin((x + z) * 0.007) * 0.05 + diurnalHumidityAdj + (Math.random() - 0.5) * 0.03);
            return { temperature: temp, humidity: h };
        }

        function createTerrain() {
            const geo = new THREE.PlaneGeometry(800, 800, 240, 240); // increased detail for better texture
            const pos = geo.attributes.position.array;
            const col = new Float32Array(pos.length);

            AppState.waterBodies = [
                { x: 0, y: 0, r: 90, d: -2.5 },
                { x: -160, y: 120, r: 70, d: -1.8 },
                { x: 200, y: -140, r: 80, d: -2.0 }
            ];

            // Mountain ranges with volcano potential
            AppState.mountainRanges = [
                // Procedurally generate a few mountain ranges with varied seeds, heights, radii and roughness
                // so lenticular clouds and orographic lift get diverse triggers.
                (() => {
                    const arr = [];
                    const base = [
                        { x:-80, z:-40 },
                        { x:120, z:100 },
                        { x:40, z:-160 },
                        { x:-200, z:20 },
                        { x:180, z:-120 }
                    ];
                    base.forEach((b, i) => {
                        const seed = Math.abs(Math.sin((b.x+37.1) * 0.012 + (b.z+91.3) * 0.007 + i) * 10000);
                        const rnd = (v,min,max) => min + (Math.abs(Math.sin(seed + v)) % 1) * (max - min);
                        const r = Math.floor(rnd(1, 40, 110));
                        const h = Math.floor(rnd(2, 10, 30));
                        const steep = 0.8 + (Math.abs(Math.sin(seed*0.21)) * 0.8);
                        arr.push({
                            x: b.x + (Math.sin(seed*0.13)*8),
                            z: b.z + (Math.cos(seed*0.17)*8),
                            r,
                            height: h,
                            steepness: steep,
                            roughness: 0.6 + Math.abs(Math.sin(seed*0.19))*0.8,
                            hasVolcano: Math.random() > 0.5
                        });
                    });
                    return arr;
                })()
            ];

            // Enhanced terrain with multiple octaves of Perlin-like noise
            for (let i = 0; i < pos.length; i += 3) {
                const x = pos[i];
                const y = pos[i + 1];
                
                // Multi-octave noise for natural terrain
                let z = 0;
                let amplitude = 3.0;
                let frequency = 0.01;
                let maxValue = 0;
                
                for (let octave = 0; octave < 4; octave++) {
                    z += Math.sin(x * frequency) * Math.cos(y * frequency * 0.8) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }
                
                z = (z / maxValue) * 4.5;
                
                // Add ridge features
                z += Math.sin(x * 0.008) * 1.5 * Math.max(0, Math.cos(y * 0.01));
                z += Math.sin(x * 0.045 + y * 0.035) * 0.8;
                
                // Plateau regions with smooth transitions
                const platVal = Math.sin((x + y) * 0.006) * 0.5 + 0.5;
                if (platVal > 0.35) z += 1.2 * (platVal - 0.35);
                
                // Mountain ranges with peaks
                for (const m of AppState.mountainRanges) {
                    const dx = x - m.x;
                    const dz = y - m.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < m.r * 1.4) {
                        const fall = Math.pow(1 - Math.min(1, dist / (m.r * 1.1)), 1.8);
                        // apply mountain-specific roughness so peaks vary more naturally
                        const peakNoise = (Math.random() - 0.5) * 2 * (m.roughness || 0.9);
                        z += m.height * fall * (0.72 + Math.random() * 0.4 + peakNoise) * m.steepness;
                        // sharp peak for volcanoes
                        if (m.hasVolcano && dist < m.r * 0.25) {
                            z += 3.0 * (1 - (dist / (m.r * 0.25)));
                        }
                    }
                }

                // Water bodies with smooth depression
                let isWater = false;
                for (const w of AppState.waterBodies) {
                    const dist = Math.sqrt((x - w.x) ** 2 + (y - w.y) ** 2);
                    if (dist < w.r) {
                        z += w.d * (1 - dist / w.r);
                        isWater = true;
                        break;
                    }
                }

                pos[i + 2] = z;
                
                // Enhanced terrain texture with more detail
                const heightFactor = Math.max(0, Math.min(1, (z + 7) / 26));
                const noise = Math.sin(x * 0.06 + y * 0.04) * 0.08 + Math.cos(x * 0.08) * 0.06;
                
                if (isWater) {
                    col[i] = 0.15 + noise * 0.05;
                    col[i + 1] = 0.38 + noise * 0.08;
                    col[i + 2] = 0.75 + noise * 0.1;
                } else if (heightFactor < 0.2) {
                    // Low grass (vibrant green)
                    col[i] = 0.18 + noise * 0.05;
                    col[i + 1] = 0.52 + noise * 0.1;
                    col[i + 2] = 0.15 + noise * 0.04;
                } else if (heightFactor < 0.5) {
                    // Mid grass to rock transition
                    const blend = (heightFactor - 0.2) / 0.3;
                    col[i] = (0.28 + noise * 0.06) * (1 - blend) + (0.42 + noise * 0.08) * blend;
                    col[i + 1] = (0.48 + noise * 0.08) * (1 - blend) + (0.38 + noise * 0.1) * blend;
                    col[i + 2] = (0.2 + noise * 0.04) * (1 - blend) + (0.32 + noise * 0.08) * blend;
                } else if (heightFactor < 0.8) {
                    // Rocky mid
                    col[i] = 0.44 + noise * 0.08;
                    col[i + 1] = 0.40 + noise * 0.06;
                    col[i + 2] = 0.32 + noise * 0.07;
                } else {
                    // Alpine / snow
                    const snowIntensity = (heightFactor - 0.8) / 0.2;
                    col[i] = 0.88 + noise * 0.04 - snowIntensity * 0.08;
                    col[i + 1] = 0.88 + noise * 0.04 - snowIntensity * 0.1;
                    col[i + 2] = 0.92 + noise * 0.03 - snowIntensity * 0.06;
                }
            }

            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.8,
                metalness: 0.08
            }));
            ground.rotation.x = -Math.PI / 2;
            // ensure ground/mountains are clearly visible and cast/receive shadows
            ground.position.y = -1.0;
            ground.castShadow = true;
            ground.receiveShadow = true;
            // make both sides renderable for safety on some devices
            ground.material.side = THREE.DoubleSide;
            AppState.scene.add(ground);
            
            // Spawn volcanoes on mountain peaks with volcano potential
            const volcanoSeed = Math.sin(12.34) * 10000; // deterministic seed for volcano generation
            for (const m of AppState.mountainRanges) {
                if (m.hasVolcano) {
                    // Use seed + mountain position to determine exact spawn variation (IMPROVED randomization)
                    const seedHash = Math.sin(volcanoSeed + m.x * 0.001 + m.z * 0.002) * 10000;
                    const shouldSpawn = (seedHash % 100) < 55; // 55% chance with seed variation
                    if (!shouldSpawn) continue;
                    // NEW: Random per-volcano seed for unique appearance
                    const uniqueSeed = Math.sin(seedHash + m.x * 0.003 + m.z * 0.005) * 1000;
                    
                    // Layered volcanic edifice: rim, inner cone, lava pool and emissive vent (SEEDED VARIATION)
                    const rimRadius = m.r * 0.42 * (0.8 + (uniqueSeed % 10) * 0.02);
                    const rimHeight = Math.max(2.2, m.height * 0.42 * (0.9 + (uniqueSeed % 20) * 0.01));
                    // outer rim (broad low slope)
                    const rimGeo = new THREE.CylinderGeometry(rimRadius * 1.1, rimRadius, rimHeight * 0.6, 28);
                    const rimMat = new THREE.MeshStandardMaterial({ color: 0x4a3426, roughness: 0.96, metalness: 0.02 });
                    const rim = new THREE.Mesh(rimGeo, rimMat);
                    rim.position.set(m.x, rimHeight * 0.28, m.z);
                    rim.castShadow = true;
                    rim.receiveShadow = true;
                    AppState.scene.add(rim);

                    // inner steep cone (SEEDED)
                    const coneGeo = new THREE.ConeGeometry(rimRadius * 0.55 * (0.85 + (uniqueSeed % 15) * 0.01), m.height * 0.9 * (0.9 + (uniqueSeed % 10) * 0.01), 20);
                    coneGeo.translate(0, m.height * 0.45, 0);
                    const coneMat = new THREE.MeshStandardMaterial({ color: 0x2e2218, roughness: 0.95 });
                    const inner = new THREE.Mesh(coneGeo, coneMat);
                    inner.position.set(m.x, rimHeight * 0.18, m.z);
                    inner.castShadow = true;
                    AppState.scene.add(inner);

                    // crater lip (SEEDED)
                    const torusGeo = new THREE.TorusGeometry(rimRadius * 0.42 * (0.9 + (uniqueSeed % 10) * 0.01), Math.max(0.6, rimRadius * 0.08 * (0.8 + (uniqueSeed % 25) * 0.01)), 16, 40);
                    const torusMat = new THREE.MeshStandardMaterial({ color: 0x2b1d16, roughness: 0.94, metalness: 0.01 });
                    const crater = new THREE.Mesh(torusGeo, torusMat);
                    crater.rotation.x = Math.PI / 2;
                    crater.position.set(m.x, rimHeight * 0.9, m.z);
                    crater.castShadow = false;
                    AppState.scene.add(crater);

                    // small lava pool as emissive hemisphere inside crater
                    const lavaGeo = new THREE.SphereGeometry(Math.max(1.4, rimRadius * 0.36 * (0.85 + (uniqueSeed % 15) * 0.01)), 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
                    const lavaMat = new THREE.MeshStandardMaterial({ color: 0xff5b22, emissive: 0xff6e33, emissiveIntensity: 1.6 * (0.9 + (uniqueSeed % 10) * 0.01), roughness: 0.6, metalness: 0.05 });
                    const lava = new THREE.Mesh(lavaGeo, lavaMat);
                    lava.position.set(m.x, rimHeight * 0.9 - 0.6, m.z);
                    lava.castShadow = false;
                    AppState.scene.add(lava);

                    // soft point light to make lava glow (SEEDED)
                    const lavaLight = new THREE.PointLight(0xff6e33, 0.8 * (0.9 + (uniqueSeed % 10) * 0.01), Math.max(18, rimRadius * 2.4));
                    lavaLight.position.set(m.x, rimHeight * 0.9, m.z);
                    AppState.scene.add(lavaLight);

                    // add subtle smoke/ember emitter hook (SourceEmitter will create visual puffs)
                    // pass mountain radius and height so emitter scales to mountain size and produces stronger pyro-convection
                    AppState.emitters.push(new SourceEmitter('volcano', m.x, m.z, Math.max(8, m.r * 0.9), Math.max(8, m.height * 1.0)));
                }
            }
        }

        // NEW: Simple water plane with animated waves (vertex displacement shader fallback)
        class WaterSurface {
            constructor() {
                const size = 800;
                this.time = 0;
                const segments = 128;
                this.geo = new THREE.PlaneGeometry(size, size, segments, segments);
                // store original positions for CPU wave displacement fallback (kept for safety)
                const pos = this.geo.attributes.position;
                this.basePos = new Float32Array(pos.array.length);
                for (let i = 0; i < pos.array.length; i++) this.basePos[i] = pos.array[i];

                this.mesh = null;

                // Create a simple vertex/fragment shader for animated waves + fresnel rim tint
                const vertexShader = `
                    uniform float uTime;
                    uniform float uWind;
                    attribute vec3 position;
                    varying vec3 vNormal;
                    varying vec3 vWorldPos;
                    varying float vHeight;
                    // classic 3-wave superposition
                    float wave(vec2 p, float amp, float freq, float speed, vec2 dir) {
                        float phase = dot(p, dir) * freq + uTime * speed;
                        return sin(phase) * amp;
                    }
                    void main() {
                        vNormal = normal;
                        vec3 pos = position;
                        // sample base x,z for waves
                        vec2 p = pos.xz;
                        float h = 0.0;
                        h += wave(p, 0.8, 0.006, 0.8, vec2(1.0, 0.2));
                        h += wave(p, 0.35, 0.018, 1.6, vec2(0.3, 1.0));
                        h += wave(p, 0.18, 0.045, 2.2, vec2(0.7, -0.4));
                        // wind coupling
                        h *= (0.7 + clamp(uWind, 0.0, 2.0) * 0.18);
                        pos.y += h;
                        vHeight = h;
                        vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                        vWorldPos = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `;
                const fragmentShader = `
                    uniform vec3 uBaseColor;
                    uniform vec3 uFresnelTint;
                    uniform float uOpacity;
                    varying vec3 vNormal;
                    varying vec3 vWorldPos;
                    varying float vHeight;
                    void main() {
                        // simple fresnel based rim and height-based spec
                        vec3 viewDir = normalize(cameraPosition - vWorldPos);
                        float fresnel = pow(1.0 - max(0.0, dot(normalize(vNormal), viewDir)), 2.0);
                        // height brighten
                        float bloom = smoothstep(0.0, 0.9, vHeight * 0.6 + fresnel * 0.6);
                        vec3 col = uBaseColor * (0.75 + bloom * 0.6);
                        // mix in a cool fresnel tint on glancing angles
                        col = mix(col, uFresnelTint, fresnel * 0.55);
                        // subtle rim light
                        float alpha = uOpacity * (0.92 + bloom * 0.16);
                        gl_FragColor = vec4(col, alpha);
                    }
                `;

                this.mat = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0.0 },
                        uWind: { value: Graphics.windMultiplier || 1.0 },
                        uBaseColor: { value: new THREE.Color(0x4aa6d6) },
                        uFresnelTint: { value: new THREE.Color(0x88cfe8) },
                        uOpacity: { value: 0.92 }
                    },
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(this.geo, this.mat);
                this.mesh.rotation.x = -Math.PI / 2;
                this.mesh.position.y = -1.6;
                this.mesh.receiveShadow = false;
                this.mesh.frustumCulled = false;
                AppState.scene.add(this.mesh);

                // fallback CPU update params retained for compatibility
                this.waveParams = [
                    { amp: 0.8, freq: 0.006, speed: 0.8, dir: [1, 0.2] },
                    { amp: 0.35, freq: 0.018, speed: 1.6, dir: [0.3, 1.0] },
                    { amp: 0.18, freq: 0.045, speed: 2.2, dir: [0.7, -0.4] }
                ];
            }

            update(dt) {
                // update shader time and wind uniform
                this.time += dt * 0.0015;
                if (this.mat && this.mat.uniforms) {
                    this.mat.uniforms.uTime.value = this.time;
                    this.mat.uniforms.uWind.value = (Graphics.windMultiplier || 1.0);
                    // small dynamic base color shift
                    const g = 0.45 + 0.08 * Math.sin(this.time * 0.9);
                    const base = new THREE.Color(0.28 + g * 0.4, 0.6 + g * 0.12, 0.75 + g * 0.06);
                    this.mat.uniforms.uBaseColor.value.copy(base);
                    this.mat.uniforms.uFresnelTint.value.setRGB(0.65 + Math.sin(this.time*0.13)*0.06, 0.85, 0.95);
                }

                // keep CPU vertex fallback for devices that may not support shaders perfectly
                // We only update a tiny amount on CPU to keep normals reasonable if shader fails
                if (!this.mesh || !this.mesh.material || !(this.mesh.material.isShaderMaterial)) {
                    const pos = this.geo.attributes.position.array;
                    const len = pos.length / 3;
                    for (let i = 0; i < len; i++) {
                        const ix = i * 3;
                        const bx = this.basePos[ix];
                        const bz = this.basePos[ix + 2];
                        let y = 0;
                        for (let w of this.waveParams) {
                            const phase = (bx * w.freq * w.dir[0] + bz * w.freq * w.dir[1]) + this.time * w.speed;
                            y += Math.sin(phase * Math.PI * 2) * w.amp;
                        }
                        const windMult = (typeof Graphics !== 'undefined' ? (Graphics.windMultiplier || 1.0) : 1.0);
                        pos[ix + 1] = -1.6 + y * Math.min(1.6, 0.7 * windMult);
                    }
                    this.geo.attributes.position.needsUpdate = true;
                    this.geo.computeVertexNormals();
                }
            }

            dispose() {
                try { this.geo.dispose(); } catch(e){}
                try { this.mat.dispose(); } catch(e){}
                try { AppState.scene.remove(this.mesh); } catch(e){}
            }
        }

        // NEW: TreeSystem - procedural trunks + canopy, dynamic sway + interaction with wind/downbursts
        class TreeSystem {
            constructor(count = 120) {
                this.trees = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.count = count;
                this.windRead = AppState.windField;
                // pooled simple geometries reused to reduce GC
                this.trunkGeo = new THREE.CylinderGeometry(0.12, 0.22, 2.6, 6);
                this.leafGeo = new THREE.SphereGeometry(1.2, 8, 6);
                this.trunkMat = new THREE.MeshStandardMaterial({ color: 0x674430, roughness: 0.9, metalness: 0.0 });
                this.leafMat = new THREE.MeshStandardMaterial({ color: 0x1f7a3c, roughness: 0.7, metalness: 0.0, transparent: true });

                this._spawnInitial();
            }

            _sampleGroundHeight(x, z) {
                // a cheap sample using same terrain functions used earlier (approx)
                // replicate similar formulas as terrain so trees sit near surface
                let y = Math.sin(x * 0.015) * Math.cos(z * 0.02) * 2.5;
                y += Math.sin(x * 0.008) * 1.2 * Math.max(0, Math.cos(z * 0.01));
                y += Math.sin(x * 0.045 + z * 0.035) * 0.6;
                y += Math.sin(x * 0.088) * Math.cos(z * 0.076) * 0.35;
                const platVal = Math.sin((x + z) * 0.006) * 0.5 + 0.5;
                if (platVal > 0.4) y += 0.8;
                // water depressions - if near water bodies, push to water edge
                for (const w of AppState.waterBodies || []) {
                    const dist = Math.hypot(x - w.x, z - w.y);
                    if (dist < w.r) {
                        y += w.d * (1 - dist / w.r);
                        break;
                    }
                }
                return y;
            }

            _spawnInitial() {
                const spread = 360;
                let attempts = 0;
                for (let i = 0; i < this.count && attempts < this.count * 8; attempts++) {
                    const x = (Math.random() * 2 - 1) * spread;
                    const z = (Math.random() * 2 - 1) * spread;
                    const groundY = this._sampleGroundHeight(x, z);
                    // avoid spawning inside large water basins
                    let overWater = false;
                    for (const w of AppState.waterBodies || []) {
                        if (Math.hypot(x - w.x, z - w.y) < w.r * 0.7) { overWater = true; break; }
                    }
                    if (overWater) continue;
                    // prefer gentle slopes (approx by sampling neighbors)
                    const hL = this._sampleGroundHeight(x - 6, z);
                    const hR = this._sampleGroundHeight(x + 6, z);
                    const slope = Math.abs(hL - hR);
                    if (slope > 3.0 && Math.random() < 0.7) continue;
                    // vary scale and canopy
                    const height = 1.6 + Math.random() * 2.4;
                    const trunk = new THREE.Mesh(this.trunkGeo, this.trunkMat);
                    const canopy = new THREE.Mesh(this.leafGeo, this.leafMat.clone());
                    canopy.material.color = new THREE.Color().setHSL(0.27 + Math.random() * 0.08, 0.35 + Math.random()*0.25, 0.18 + Math.random()*0.18);
                    canopy.scale.set(0.7 + Math.random() * 1.1, 0.6 + Math.random() * 0.8, 0.7 + Math.random() * 1.1);
                    trunk.scale.set(0.6 + Math.random()*0.9, height / 2.2, 0.6 + Math.random()*0.9);
                    trunk.position.set(0, height/2 + 0.02, 0);
                    canopy.position.set(0, height + 0.2, 0);
                    const node = new THREE.Group();
                    node.add(trunk);
                    node.add(canopy);
                    node.position.set(x, groundY + 0.02, z);
                    node.userData = {
                        sway: 0,
                        swayVel: 0,
                        stiffness: 0.02 + Math.random() * 0.06,
                        damping: 0.86 + Math.random() * 0.10,
                        maxBend: 0.26 + Math.random() * 0.42,
                        baseHeight: height,
                        trunk, canopy
                    };
                    node.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = false; } });
                    this.trees.push(node);
                    this.group.add(node);
                    i++;
                }
            }

            applyWindToTree(tree, dt) {
                // compute local mean wind from windField at tree position and low altitude
                const wx = tree.position.x;
                const wz = tree.position.z;
                const wf = this.windRead ? this.windRead.getAt(wx, 1.6, wz) : { x: 0, z: 0 };
                const windMag = Math.hypot(wf.x, wf.z) * (Graphics.windMultiplier || 1.0);
                const windDir = Math.atan2(wf.z, wf.x);
                // target sway proportional to wind magnitude but clamped by tree maxBend
                const tgt = Math.max(-tree.userData.maxBend, Math.min(tree.userData.maxBend, (Math.sin(windDir) * windMag * 0.6)));
                // spring-damper toward target
                const k = tree.userData.stiffness;
                const damp = tree.userData.damping;
                const acc = (tgt - tree.userData.sway) * k - tree.userData.swayVel * (1 - damp);
                tree.userData.swayVel += acc * (dt * 0.06);
                tree.userData.swayVel *= damp;
                tree.userData.sway += tree.userData.swayVel * (dt * 0.06);
                // apply to canopy/trunk by small rotation about X/Z axes
                const bend = tree.userData.sway;
                tree.traverse(node => {
                    if (node === tree) return;
                    node.rotation.z = bend * 0.6;
                    node.rotation.x = bend * 0.12 * (node === tree.userData.trunk ? 0.6 : 0.3);
                });
            }

            // external impulse (downburst/tornado) applies temporary strong sway
            applyImpulse(x, z, strength, radius) {
                for (const t of this.trees) {
                    const d = Math.hypot(t.position.x - x, t.position.z - z);
                    if (d > radius) continue;
                    const influence = 1 - d / radius;
                    // apply abrupt velocity to swayVel
                    t.userData.swayVel += (Math.random() - 0.5) * strength * 0.08 * influence;
                    // slight lift/tilt for dramatic effect
                    t.position.y += Math.min(0.6, strength * 0.002 * influence);
                }
            }

            update(dt) {
                // iterate trees and advance sway dynamics
                for (let i = 0; i < this.trees.length; i++) {
                    try {
                        const t = this.trees[i];
                        this.applyWindToTree(t, dt);
                        // gentle relaxation of exploded vertical offsets
                        t.position.y += (this._sampleGroundHeight(t.position.x, t.position.z) + 0.02 - t.position.y) * 0.05;
                        // canopy color subtle shift from stress (darker when strong sway)
                        const stress = Math.abs(t.userData.sway);
                        const leaf = t.userData.canopy || t.children.find(c => c.geometry === this.leafGeo);
                        if (leaf && leaf.material) {
                            const baseH = 0.27;
                            const hue = baseH - Math.min(0.04, stress * 0.12);
                            leaf.material.color.setHSL(hue, 0.38, 0.18);
                        }

                        // Handle ongoing fire if ignited by lightning
                        if (t.userData && t.userData.onFire) {
                            t.userData.fireTime = (t.userData.fireTime || 180) - (dt * 0.06 * (Graphics.simSpeed || 1));
                            // tint canopy to hot ember color and increase emissive
                            const c = t.children.find(cn => cn.geometry === this.leafGeo);
                            if (c && c.material) {
                                c.material.color.lerp(new THREE.Color(0xbb3b12), 0.06);
                                c.material.emissive = c.material.emissive || new THREE.Color(0x000000);
                                c.material.emissive.lerp(new THREE.Color(0x662200), 0.04);
                                c.material.opacity = Math.max(0.28, (c.material.opacity || 1.0) * 0.995);
                            }
                            // spawn tiny ember particles occasionally
                            if (t.userData.fireTime % 28 < 1 && Math.random() < 0.28) {
                                const pgeo = new THREE.BufferGeometry();
                                const arr = new Float32Array(3);
                                arr[0] = t.position.x + (Math.random()-0.5)*0.6;
                                arr[1] = t.position.y + 1.6 + Math.random()*0.6;
                                arr[2] = t.position.z + (Math.random()-0.5)*0.6;
                                pgeo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
                                const pmat = new THREE.PointsMaterial({ size: 0.18, color: 0xff8b33, transparent: true, opacity: 0.9 });
                                const ember = new THREE.Points(pgeo, pmat);
                                ember.userData = { life: 0.9 + Math.random() * 0.7, vy: 0.06 + Math.random()*0.06 };
                                AppState.scene.add(ember);
                                (this._embers = this._embers || []).push(ember);
                            }
                            if (t.userData.fireTime <= 0) {
                                // tree burnt down: remove canopy and reduce trunk visibility
                                try {
                                    if (t.userData.canopy) {
                                        t.userData.canopy.visible = false;
                                        if (t.userData.canopy.geometry) t.userData.canopy.geometry.dispose();
                                        if (t.userData.canopy.material) t.userData.canopy.material.dispose();
                                    }
                                } catch(e){}
                                // leave charred stump by darkening trunk
                                if (t.userData.trunk && t.userData.trunk.material) {
                                    t.userData.trunk.material.color.setRGB(0.08,0.06,0.06);
                                }
                                t.userData.onFire = false;
                            }
                        }
                    } catch(e) { continue; }
                }
                // update ember lifetimes for burning trees
                if (this._embers) {
                    for (let i = this._embers.length - 1; i >= 0; i--) {
                        const p = this._embers[i];
                        p.userData.life -= 0.02;
                        p.material.opacity *= 0.96;
                        p.position.y += p.userData.vy * 0.6;
                        if (p.userData.life <= 0) {
                            AppState.scene.remove(p);
                            if (p.geometry) p.geometry.dispose();
                            if (p.material) p.material.dispose();
                            this._embers.splice(i,1);
                        }
                    }
                }
            }

            dispose() {
                this.trees.forEach(t => {
                    t.traverse(o => { if (o.geometry) o.geometry.dispose(); if (o.material) o.material.dispose(); });
                    this.group.remove(t);
                });
                try { this.trunkGeo.dispose(); } catch(e){}
                try { this.leafGeo.dispose(); } catch(e){}
                try { this.trunkMat.dispose(); } catch(e){}
            }
        }

        // NEW: Urban / City system - lightweight building clusters with night lighting + roads, vehicles, and humans
        class UrbanSystem {
            constructor(count = 12) {
                this.cities = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.count = count;
                this.vehicles = [];
                this.pedestrians = [];
                this._spawnCities();
            }

            _sampleGroundHeight(x, z) {
                // reuse simple terrain approximation so buildings sit near the surface
                let y = Math.sin(x * 0.015) * Math.cos(z * 0.02) * 2.5;
                y += Math.sin(x * 0.008) * 1.2 * Math.max(0, Math.cos(z * 0.01));
                y += Math.sin(x * 0.045 + z * 0.035) * 0.6;
                y += Math.sin(x * 0.088) * Math.cos(z * 0.076) * 0.35;
                const platVal = Math.sin((x + z) * 0.006) * 0.5 + 0.5;
                if (platVal > 0.4) y += 0.8;
                for (const w of AppState.waterBodies || []) {
                    const dist = Math.hypot(x - w.x, z - w.y);
                    if (dist < w.r) { y += w.d * (1 - dist / w.r); break; }
                }
                return y;
            }

            _spawnCities() {
                const spread = 320;
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x2f3438, roughness: 0.85 });
                const industrialMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.9, metalness: 0.1 });
                
                for (let i = 0; i < this.count; i++) {
                    const cx = (Math.random() * 2 - 1) * spread * 0.7;
                    const cz = (Math.random() * 2 - 1) * spread * 0.7;
                    const radius = 22 + Math.random() * 50;
                    const density = 18 + Math.floor(Math.random() * 42);
                    const city = { 
                        x: cx, z: cz, radius, density, buildings: [], lights: [], 
                        group: new THREE.Group(),
                        isIndustrial: Math.random() < 0.35 // 35% chance industrial zone
                    };
                    city.group.position.set(cx, 0, cz);
                    this.group.add(city.group);

                    // Roads: main grid
                    const roadWidth = 2.0 + Math.random() * 3.2;
                    const mainRoad = new THREE.Mesh(new THREE.BoxGeometry(radius * 2.4, 0.12, roadWidth), roadMat);
                    mainRoad.position.set(0, 0.06, 0);
                    city.group.add(mainRoad);
                    const crossRoad = new THREE.Mesh(new THREE.BoxGeometry(roadWidth, 0.12, radius * 2.4), roadMat);
                    crossRoad.position.set(0, 0.06, 0);
                    city.group.add(crossRoad);

                    // Industrial zone with large warehouse buildings
                    if (city.isIndustrial) {
                        for (let w = 0; w < 6; w++) {
                            const ang = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius * 0.5 + 8;
                            const bx = Math.cos(ang) * r;
                            const bz = Math.sin(ang) * r;
                            const baseY = this._sampleGroundHeight(cx + bx, cz + bz);
                            const h = 6 + Math.random() * 12; // large warehouse heights
                            const bw = 8 + Math.random() * 18; // large footprints
                            const geo = new THREE.BoxGeometry(bw, h, bw * 0.6);
                            const bmesh = new THREE.Mesh(geo, industrialMat.clone());
                            bmesh.position.set(bx, baseY + h / 2, bz);
                            bmesh.castShadow = true;
                            bmesh.receiveShadow = true;
                            city.buildings.push(bmesh);
                            city.group.add(bmesh);
                            
                            // Industrial lights: sparse and dim
                            if (Math.random() < 0.4) {
                                const lgeo = new THREE.PlaneGeometry(bw * 0.7, h * 0.08);
                                const lmat = new THREE.MeshBasicMaterial({ color: 0xffdd99, transparent: true, opacity: 0.0, depthWrite: false });
                                const lmesh = new THREE.Mesh(lgeo, lmat);
                                const side = Math.random() > 0.5 ? 1 : -1;
                                lmesh.position.set(bx + side * (bw / 2 + 0.02), baseY + h * 0.35, bz);
                                lmesh.rotation.y = side === 1 ? -Math.PI / 2 : Math.PI / 2;
                                lmesh.userData = { baseOpacity: 0.6 + Math.random() * 0.3, flicker: Math.random() * 0.8 };
                                city.lights.push(lmesh);
                                city.group.add(lmesh);
                            }
                        }
                    } else {
                        // Residential zone with mixed buildings
                        for (let b = 0; b < density; b++) {
                            const ang = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius * (0.25 + Math.random() * 0.85);
                            const bx = Math.cos(ang) * r;
                            const bz = Math.sin(ang) * r;
                            const baseY = this._sampleGroundHeight(cx + bx, cz + bz);
                            const h = 2 + Math.floor(Math.random() * 9) + (Math.random() < 0.12 ? 8 + Math.random() * 28 : 0);
                            const bw = 1.2 + Math.random() * 3.2;
                            const geo = new THREE.BoxGeometry(bw, h, bw);
                            const col = new THREE.Color(0.16 + Math.random() * 0.3, 0.14 + Math.random() * 0.28, 0.16 + Math.random() * 0.3);
                            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.8, metalness: 0.02 });
                            const bmesh = new THREE.Mesh(geo, mat);
                            bmesh.position.set(bx, baseY + h / 2, bz);
                            bmesh.castShadow = true;
                            bmesh.receiveShadow = true;
                            city.buildings.push(bmesh);
                            city.group.add(bmesh);

                            // Windows with night lights
                            if (Math.random() < 0.65) {
                                const lightGeo = new THREE.PlaneGeometry(bw * 0.65, h * 0.14);
                                const lightMat = new THREE.MeshBasicMaterial({ color: 0xffeaa7, transparent: true, opacity: 0.0, depthWrite: false });
                                const lmesh = new THREE.Mesh(lightGeo, lightMat);
                                const side = Math.random() > 0.5 ? 1 : -1;
                                lmesh.position.set(bx + side * (bw / 2 + 0.015), baseY + h * (0.25 + Math.random() * 0.5), bz);
                                lmesh.rotation.y = side === 1 ? -Math.PI / 2 : Math.PI / 2;
                                lmesh.userData = { baseOpacity: 0.95 + Math.random() * 0.35, flicker: Math.random() * 0.6 };
                                city.lights.push(lmesh);
                                city.group.add(lmesh);
                            }
                        }
                    }

                    // Vehicles on roads
                    const vehicleCount = 4 + Math.floor(Math.random() * 8);
                    for (let v = 0; v < vehicleCount; v++) {
                        const angle = Math.random() * Math.PI * 2;
                        const R = Math.max(8, radius * (0.4 + Math.random() * 0.55));
                        const vehicleGeo = new THREE.BoxGeometry(1.0, 0.45, 1.8);
                        const vehicleCol = new THREE.Color(Math.random()*0.8+0.15, Math.random()*0.8+0.15, Math.random()*0.8+0.15);
                        const vehicleMat = new THREE.MeshStandardMaterial({ color: vehicleCol, roughness: 0.6 });
                        const vehicle = new THREE.Mesh(vehicleGeo, vehicleMat);
                        const vx = Math.cos(angle) * R;
                        const vz = Math.sin(angle) * R;
                        const vy = this._sampleGroundHeight(cx + vx, cz + vz) + 0.35;
                        vehicle.position.set(vx, vy, vz);
                        vehicle.userData = { cityCenter: { x: cx, z: cz }, radius: R, angle, speed: 0.003 + Math.random() * 0.008, offsetY: vy };
                        city.group.add(vehicle);
                        this.vehicles.push(vehicle);
                    }

                    // Pedestrians
                    const pedCount = 8 + Math.floor(Math.random() * 22);
                    for (let p = 0; p < pedCount; p++) {
                        const px = (Math.random() - 0.5) * radius * 0.95;
                        const pz = (Math.random() - 0.5) * radius * 0.95;
                        const py = this._sampleGroundHeight(cx + px, cz + pz) + 0.2;
                        const pedGeo = new THREE.SphereGeometry(0.2, 6, 6);
                        const pedMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(0.96, 0.72, 0.62), roughness: 0.9 });
                        const ped = new THREE.Mesh(pedGeo, pedMat);
                        ped.position.set(px, py, pz);
                        ped.userData = { cityCenter: { x: cx, z: cz }, roamRadius: Math.max(4, radius * 0.65), angle: Math.random() * Math.PI * 2, speed: 0.0008 + Math.random() * 0.0022 };
                        city.group.add(ped);
                        this.pedestrians.push(ped);
                    }

                    this.cities.push(city);
                }
            }

            // simple night/day update: fade lights on/off and pulse a little; also animate vehicles & pedestrians
            update(t) {
                if (!this.cities.length) return;
                const night = window.DayNight ? (window.DayNight.dayStrength < 0.15) : false;
                for (const city of this.cities) {
                    for (const l of city.lights) {
                        if (!l.material) continue;
                        // honor global building lights toggle: when enabled, allow night/day behavior; when disabled, force off
                        if (Graphics.buildingLights) {
                            if (night) {
                                const tgt = (l.userData && l.userData.baseOpacity) ? l.userData.baseOpacity * 0.9 : 0.8;
                                l.material.opacity += (tgt - (l.material.opacity || 0)) * 0.14;
                                l.material.opacity *= (0.92 + Math.sin(t * 0.001 + (l.userData.flicker || 0)) * 0.04);
                            } else {
                                l.material.opacity += (0 - (l.material.opacity || 0)) * 0.16;
                            }
                        } else {
                            // forced off
                            l.material.opacity = Math.max(0, (l.material.opacity || 0) * 0.65);
                        }
                    }
                }

                // move vehicles along their circular paths and apply simple steer to orient them
                for (let i = 0; i < this.vehicles.length; i++) {
                    const v = this.vehicles[i];
                    if (!v || !v.userData) continue;
                    v.userData.angle += v.userData.speed * (1 + Math.sin(t * 0.0003) * 0.25);
                    const cx = v.userData.cityCenter.x, cz = v.userData.cityCenter.z;
                    const R = v.userData.radius;
                    const ang = v.userData.angle;
                    const nx = Math.cos(ang) * R;
                    const nz = Math.sin(ang) * R;
                    const ny = this._sampleGroundHeight(cx + nx, cz + nz) + 0.28;
                    v.position.set(nx, ny, nz);
                    // orient by tangent
                    v.rotation.y = -ang + Math.PI/2;
                }

                // simple pedestrian wandering: circular plus jitter
                for (let i = 0; i < this.pedestrians.length; i++) {
                    const p = this.pedestrians[i];
                    if (!p || !p.userData) continue;
                    p.userData.angle += p.userData.speed * (1 + Math.cos(t * 0.0007 + i) * 0.2);
                    const cx = p.userData.cityCenter.x, cz = p.userData.cityCenter.z;
                    const R = p.userData.roamRadius;
                    const ang = p.userData.angle;
                    const nx = Math.cos(ang) * R * (0.4 + Math.random() * 0.6);
                    const nz = Math.sin(ang) * R * (0.4 + Math.random() * 0.6);
                    const ny = this._sampleGroundHeight(cx + nx, cz + nz) + 0.18;
                    p.position.set(nx, ny, nz);
                }
            }

            dispose() {
                for (const city of this.cities) {
                    city.group.traverse(o => {
                        if (o.geometry) try { o.geometry.dispose(); } catch (e) {}
                        if (o.material) try { o.material.dispose(); } catch (e) {}
                    });
                    this.group.remove(city.group);
                }
                this.cities = [];
                // dispose vehicles/peds
                this.vehicles.forEach(v => { if (v.geometry) try { v.geometry.dispose(); } catch(e){} if (v.material) try { v.material.dispose(); } catch(e){} });
                this.pedestrians.forEach(p => { if (p.geometry) try { p.geometry.dispose(); } catch(e){} if (p.material) try { p.material.dispose(); } catch(e){} });
                this.vehicles = [];
                this.pedestrians = [];
            }
        }

        // Day / Night & Infrared radiation system
        window.DayNight = {
            time: 0, // milliseconds
            dayLength: 120000, // full cycle in ms (2 minutes)
            tempAmplitude: 6, // degrees swing from night to day
            tempOffset: 0, // applied to base sea level in sampleEnvironment
            phase: 0, // 0..1 where 0=midnight, 0.5=noon
            dayStrength: 1, // 0..1 where 1=full day, 0=night
            update(deltaMs) {
                this.time = (this.time + deltaMs) % this.dayLength;
                this.phase = (this.time / this.dayLength);
                const angle = this.phase * Math.PI * 2;
                this.dayStrength = Math.max(0, Math.sin(angle) * 0.5 + 0.5);
                // new greenhouse effect: Graphics.greenhouse adds baseline warming and damps night cooling
                const gh = (typeof Graphics !== 'undefined' ? (Graphics.greenhouse || 0) : 0);
                const irMul = (typeof Graphics !== 'undefined' && Graphics.irMultiplier) ? Number(Graphics.irMultiplier) : 1.0;
                // warmer baseline from greenhouse, plus scaled diurnal amplitude
                this.tempOffset = gh + (Math.cos(angle) * this.tempAmplitude * 0.5 * irMul + (this.dayStrength - 0.5) * this.tempAmplitude * 0.5 * irMul) * Math.max(0.6, 1 - gh*0.06);
            }
        };

        // update scene lighting & fog based on day/night
        function applyDayNightToScene() {
            const d = window.DayNight || { dayStrength: 1 };
            // ambient tint: warmer in day, cooler at night
            const amb = AppState.scene.getObjectByProperty && AppState.scene.children.find(o=>o && o.type==='AmbientLight');
            if (amb && amb.color) {
                // lerp from cool night to warm day
                const dayCol = new THREE.Color(0xffffff);
                const nightCol = new THREE.Color(0x7f89a0);
                amb.color.copy(nightCol).lerp(dayCol, d.dayStrength * 0.95 + 0.05);
                amb.intensity = 0.6 + d.dayStrength * 0.9;
            }
            // directional main sun (first directional light added)
            const sun = AppState.scene.children.find(o => o && o.isDirectionalLight);
            if (sun) {
                sun.intensity = 0.6 + d.dayStrength * 1.6;
                // change sun color slightly (warmer toward dusk)
                const daySun = new THREE.Color(0xfff0d6);
                const nightSun = new THREE.Color(0xaac6ff);
                sun.color.copy(nightSun).lerp(daySun, Math.max(0, d.dayStrength));
                // move sun angle over time for subtle slope
                const ang = window.DayNight.phase * Math.PI * 2;
                const radius = 100;
                sun.position.set(Math.cos(ang) * radius * 0.9, 40 + Math.sin(ang) * 40, Math.sin(ang) * radius * 0.9);
            }
            // background/fog shifts slightly
            const dayBG = new THREE.Color(0x8fb9d6);
            const nightBG = new THREE.Color(0x243a52);
            AppState.scene.background.copy(nightBG).lerp(dayBG, Math.max(0.08, window.DayNight.dayStrength));
            AppState.scene.fog.color.copy(AppState.scene.background);
        }

        class EvaporationSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 500;
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.maxParticles * 3);
                this.sizes = new Float32Array(this.maxParticles);
                this.opacities = new Float32Array(this.maxParticles);
                
                for (let i = 0; i < this.maxParticles; i++) {
                    this.particles.push({ active: false, life: 0 });
                    this.positions[i * 3] = 0;
                    this.positions[i * 3 + 1] = -100;
                    this.positions[i * 3 + 2] = 0;
                    this.sizes[i] = 0;
                    this.opacities[i] = 0;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.opacities, 1));
                
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Multi-layer gradient for wispy vapor
                const grad1 = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                grad1.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                grad1.addColorStop(0.3, 'rgba(240, 248, 255, 0.5)');
                grad1.addColorStop(0.7, 'rgba(220, 235, 250, 0.2)');
                grad1.addColorStop(1, 'rgba(200, 220, 240, 0)');
                ctx.fillStyle = grad1;
                ctx.fillRect(0, 0, 64, 64);
                
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2.5,
                    transparent: true,
                    opacity: 0.5,
                    map: new THREE.CanvasTexture(canvas),
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.points = new THREE.Points(this.geometry, material);
                AppState.scene.add(this.points);
            }

            spawnEvaporation(x, z) {
                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) {
                        const idx = i * 3;
                        this.positions[idx] = x + (Math.random() - 0.5) * 10;
                        this.positions[idx + 1] = 0.3;
                        this.positions[idx + 2] = z + (Math.random() - 0.5) * 10;
                        
                        this.particles[i] = {
                            active: true,
                            life: 1.0,
                            vx: (Math.random() - 0.5) * 0.03,
                            vy: 0.06 + Math.random() * 0.08,
                            vz: (Math.random() - 0.5) * 0.03,
                            maxHeight: 6 + Math.random() * 10,
                            size: 0.8 + Math.random() * 1.2
                        };
                        this.sizes[i] = this.particles[i].size;
                        this.opacities[i] = 0.5;
                        break;
                    }
                }
            }

            update() {
                // More frequent evaporation
                if (Math.random() < 0.5) {
                    const water = AppState.waterBodies[Math.floor(Math.random() * AppState.waterBodies.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * water.r * 0.95;
                    this.spawnEvaporation(
                        water.x + Math.cos(angle) * radius,
                        water.y + Math.sin(angle) * radius
                    );
                }

                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) continue;
                    
                    const p = this.particles[i];
                    const idx = i * 3;
                    
                    // Expand and rise
                    this.positions[idx] += p.vx;
                    this.positions[idx + 1] += p.vy;
                    this.positions[idx + 2] += p.vz;
                    
                    p.life -= 0.008;
                    this.sizes[i] = p.size * (2 - p.life);
                    this.opacities[i] = p.life * 0.6;
                    
                    // Slow down as it rises
                    p.vy *= 0.98;
                    
                    if (p.life <= 0 || this.positions[idx + 1] > p.maxHeight) {
                        p.active = false;
                        this.positions[idx + 1] = -100;
                        this.sizes[i] = 0;
                        this.opacities[i] = 0;
                    }
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
                this.geometry.attributes.alpha.needsUpdate = true;
            }
        }

        class WindField {
            constructor() {
                this.size = 15;
                this.spacing = 8;
                this.field = [];
                this.time = 0;
                
                for (let x = 0; x < this.size; x++) {
                    this.field[x] = [];
                    for (let y = 0; y < this.size; y++) {
                        this.field[x][y] = [];
                        for (let z = 0; z < this.size; z++) {
                            this.field[x][y][z] = { x: 0, y: 0, z: 0 };
                        }
                    }
                }
            }

            update(t) {
                this.time = t * 0.0001;
                let avg = { x: 0, z: 0, c: 0 };
                
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        for (let z = 0; z < this.size; z++) {
                            const wx = (x - this.size / 2) * this.spacing;
                            const wy = y * this.spacing;
                            const wz = (z - this.size / 2) * this.spacing;
                            
                            const vx = Math.sin(wx * 0.03 + this.time) * Math.cos(wz * 0.02 + this.time * 0.5) * 2.5;
                            const vz = Math.cos(wx * 0.02 + this.time * 0.6) * Math.sin(wz * 0.03 + this.time) * 2.0;
                            
                            this.field[x][y][z] = { x: vx, y: 0, z: vz };
                            
                            if (y > 3 && y < 8) {
                                avg.x += vx;
                                avg.z += vz;
                                avg.c++;
                            }
                        }
                    }
                }
                
                return { x: avg.x / avg.c, z: avg.z / avg.c };
            }

            getAt(x, y, z) {
                // Map world coords to grid indices (floating)
                const gxF = (x / this.spacing) + this.size / 2;
                const gyF = (y / this.spacing);
                const gzF = (z / this.spacing) + this.size / 2;

                // Fast reject: completely outside the whole field
                if (gxF < 0 || gxF >= this.size || gyF < 0 || gyF >= this.size || gzF < 0 || gzF >= this.size) {
                    return { x: 0, y: 0, z: 0 };
                }

                // Integer cell indices (clamped so we can safely sample neighbors)
                const gx = Math.max(0, Math.min(this.size - 2, Math.floor(gxF)));
                const gy = Math.max(0, Math.min(this.size - 1, Math.floor(gyF))); // y uses available range
                const gz = Math.max(0, Math.min(this.size - 2, Math.floor(gzF)));

                // interpolation factor along x within the cell
                const fx = gxF - gx;

                // Safely grab cell entries (guard in case of unexpected holes)
                const c0 = (this.field[gx] && this.field[gx][gy] && this.field[gx][gy][gz]) ? this.field[gx][gy][gz] : { x: 0, y: 0, z: 0 };
                const c1 = (this.field[gx + 1] && this.field[gx + 1][gy] && this.field[gx + 1][gy][gz]) ? this.field[gx + 1][gy][gz] : c0;

                // return a small scaled wind vector (matches previous scaling)
                const base = {
                    x: (c0.x * (1 - fx) + c1.x * fx) * 0.03,
                    y: 0,
                    z: (c0.z * (1 - fx) + c1.z * fx) * 0.03
                };
                // apply global wind multiplier (keeps previous scaling but allows user tuning)
                const mult = (typeof Graphics !== 'undefined' && Graphics.windMultiplier) ? Graphics.windMultiplier : 1.0;
                return { x: base.x * mult, y: base.y * mult, z: base.z * mult };
            }
        }

        // VelocityArrows: visual debugging arrows that sample WindField and render small lines/arrows
        class VelocityArrows {
            constructor(windField, density = 10) {
                this.windField = windField;
                this.group = new THREE.Group();
                this.density = density; // how many arrows per axis (coarse)
                this._pool = [];
                this._initArrows();
                AppState.scene.add(this.group);
                this.enabled = false;
            }

            _initArrows() {
                const mat = new THREE.LineBasicMaterial({ color: 0x6cf, transparent: true, opacity: 0.9 });
                // create a grid of arrow lines (line from base to tip)
                const spacingWorld = (this.windField.size * this.windField.spacing) / this.density;
                for (let ix = 0; ix < this.density; ix++) {
                    for (let iz = 0; iz < this.density; iz++) {
                        const geom = new THREE.BufferGeometry();
                        const arr = new Float32Array(6); // start(x,y,z), end(x,y,z)
                        geom.setAttribute('position', new THREE.BufferAttribute(arr, 3));
                        const line = new THREE.Line(geom, mat.clone());
                        line.frustumCulled = false;
                        this.group.add(line);
                        this._pool.push({ line, geom, arr });
                    }
                }
            }

            update() {
                if (!this.enabled || !this.windField) {
                    this.group.visible = false;
                    return;
                }
                this.group.visible = true;
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const half = (size / 2) * spacing;
                const count = this._pool.length;
                for (let i = 0; i < count; i++) {
                    const px = (i % this.density);
                    const pz = Math.floor(i / this.density);
                    // map grid sample to world coords
                    const wx = -half + (px + 0.5) * (size * spacing) / this.density;
                    const wz = -half + (pz + 0.5) * (size * spacing) / this.density;
                    const wy = 6; // sample around low-mid level
                    const v = this.windField.getAt(wx, wy, wz) || { x: 0, z: 0 };
                    const vx = v.x * 40; // scale for visualization
                    const vz = v.z * 40;
                    const pool = this._pool[i];
                    const arr = pool.geom.attributes.position.array;
                    arr[0] = wx; arr[1] = wy; arr[2] = wz;
                    arr[3] = wx + vx; arr[4] = wy + 0.5; arr[5] = wz + vz;
                    pool.geom.attributes.position.needsUpdate = true;
                    // color by magnitude
                    const mag = Math.hypot(v.x, v.z);
                    const col = new THREE.Color().setHSL(Math.max(0, 0.58 - mag * 0.2), 0.9, 0.55);
                    pool.line.material.color.copy(col);
                    pool.line.material.opacity = Math.min(1.0, 0.25 + mag * 3.0);
                }
            }

            dispose() {
                this.group.traverse(o => {
                    if (o.geometry) try { o.geometry.dispose(); } catch(e){}
                    if (o.material) try { o.material.dispose(); } catch(e){}
                });
                try { AppState.scene.remove(this.group); } catch(e) {}
            }
        }

        // WeatherStations: spawn small station posts that sample environment and display in a small UI list
        class WeatherStations {
            constructor(count = 6) {
                this.count = count;
                this.stations = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.domList = null;
                this._createDomPanel();
                this._spawnStations();
            }

            _createDomPanel() {
                const statsPanel = document.getElementById('stats');
                if (!statsPanel) return;
                const wrapper = document.createElement('div');
                wrapper.style.marginTop = '8px';
                wrapper.style.fontSize = '11px';
                wrapper.style.color = '#cfe';
                wrapper.id = 'station-list';
                wrapper.innerHTML = '<div style="color:#6cf;font-weight:600;margin-bottom:6px;font-size:12px;">Stations</div>';
                // create empty entries
                for (let i = 0; i < this.count; i++) {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.marginBottom = '4px';
                    row.innerHTML = `<div id="st-name-${i}" style="color:#dfe">ST${i}</div><div id="st-val-${i}" style="color:#9be">‚Äî</div>`;
                    wrapper.appendChild(row);
                }
                statsPanel.appendChild(wrapper);
                this.domList = wrapper;
            }

            _spawnStations() {
                const spread = 200;
                for (let i = 0; i < this.count; i++) {
                    const x = (Math.random() * 2 - 1) * spread;
                    const z = (Math.random() * 2 - 1) * spread;
                    const y = this._sampleGroundHeight(x, z) + 0.6;
                    const poleGeo = new THREE.CylinderGeometry(0.06, 0.06, 1.2, 6);
                    const poleMat = new THREE.MeshStandardMaterial({ color: 0x333a44, roughness: 0.7 });
                    const pole = new THREE.Mesh(poleGeo, poleMat);
                    pole.position.set(x, y + 0.6, z);
                    pole.castShadow = false;
                    // small box sensor
                    const box = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.2,0.2), new THREE.MeshStandardMaterial({ color: 0xffdd88 }));
                    box.position.set(x + 0.35, y + 0.9, z);
                    box.castShadow = false;
                    const station = { x, z, pole, box, idx: i, last: 0 };
                    this.stations.push(station);
                    this.group.add(pole);
                    this.group.add(box);
                }
            }

            _sampleGroundHeight(x, z) {
                // use same cheap sampling as tree/urban systems
                let y = Math.sin(x * 0.015) * Math.cos(z * 0.02) * 2.5;
                y += Math.sin(x * 0.008) * 1.2 * Math.max(0, Math.cos(z * 0.01));
                y += Math.sin(x * 0.045 + z * 0.035) * 0.6;
                y += Math.sin(x * 0.088) * Math.cos(z * 0.076) * 0.35;
                const platVal = Math.sin((x + z) * 0.006) * 0.5 + 0.5;
                if (platVal > 0.4) y += 0.8;
                for (const w of AppState.waterBodies || []) {
                    const dist = Math.hypot(x - w.x, z - w.y);
                    if (dist < w.r) { y += w.d * (1 - dist / w.r); break; }
                }
                return y;
            }

            update(t) {
                for (const s of this.stations) {
                    // sample environment every ~600ms
                    if (t - s.last < 600) continue;
                    s.last = t;
                    const env = sampleEnvironment(s.x, s.z, 2);
                    // update box color based on temperature (cool=blue warm=orange)
                    const tempNorm = Math.max(-20, Math.min(40, env.temperature));
                    const hue = 0.65 - (tempNorm + 20) / 90 * 0.6;
                    s.box.material.color.setHSL(hue, 0.7, 0.6);
                    // update DOM entries if present
                    const nameEl = document.getElementById(`st-name-${s.idx}`);
                    const valEl = document.getElementById(`st-val-${s.idx}`);
                    if (nameEl) nameEl.textContent = `ST${s.idx} ${Math.round(s.x)},${Math.round(s.z)}`;
                    if (valEl) valEl.textContent = `${env.temperature.toFixed(1)}¬∞C ${Math.round(env.humidity*100)}%`;
                }
            }

            dispose() {
                this.group.traverse(o => { if (o.geometry) try{o.geometry.dispose();}catch(e){} if (o.material) try{o.material.dispose();}catch(e){} });
                try { AppState.scene.remove(this.group); } catch(e){}
                if (this.domList) this.domList.remove();
            }
        }

        // NEW: MountainWaveSystem - standing lee waves and small-scale lee vortices tied to mountain ranges
        class MountainWaveSystem {
            constructor(windFieldRef, cloudSystemRef) {
                this.windField = windFieldRef;
                this.cloudSystem = cloudSystemRef;
                this.time = 0;
            }
            update(t) {
                this.time = t * 0.001;
                if (!AppState.mountainRanges || !this.windField || !this.windField.field) return;
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                // for each mountain, create a linear standing wave pattern downwind
                for (const m of AppState.mountainRanges) {
                    // compute a dominant downwind direction from large-scale wind (sample center)
                    const base = this.windField.getAt(m.x, 6, m.z);
                    const windMag = Math.hypot(base.x || 0, base.z || 0);
                    if (windMag < 0.01) continue;
                    const dx = base.x, dz = base.z;
                    const ang = Math.atan2(dz, dx);
                    // wave parameters tuned by mountain height
                    const wavelength = Math.max(18, 24 - m.height);
                    const amplitude = Math.min(2.0, 0.08 * (m.height || 8));
                    // apply perturbation along a stripe extending downwind
                    for (let s = 0; s < 6; s++) {
                        // sample along ray downwind
                        const distAlong = (s + 1) * (m.r * 0.6);
                        const cx = m.x + Math.cos(ang) * distAlong;
                        const cz = m.z + Math.sin(ang) * distAlong;
                        // perturb nearby wind cells with an oscillatory vertical/updraft signature and lateral shear
                        for (let gx = 0; gx < size; gx++) {
                            for (let gy = 0; gy < Math.min(size, 8); gy++) {
                                for (let gz = 0; gz < size; gz++) {
                                    const wx = (gx - size / 2) * spacing;
                                    const wz = (gz - size / 2) * spacing;
                                    const d = Math.hypot(wx - cx, wz - cz);
                                    if (d > m.r * 0.9) continue;
                                    const influence = Math.max(0, 1 - d / (m.r * 0.9));
                                    const phase = (d / wavelength) + this.time * 0.8;
                                    const up = Math.sin(phase * Math.PI * 2) * amplitude * influence;
                                    const lateral = Math.cos(phase * Math.PI * 2) * amplitude * 0.45 * influence;
                                    const cell = this.windField.field[gx][gy][gz];
                                    if (!cell) continue;
                                    // inject an updraft marker for other systems
                                    cell.__updraft = (cell.__updraft || 0) + up * (1 + (8 - gy) * 0.06);
                                    // lateral shear perpendicular to main wind (creates rotor/lee vortex tendency)
                                    const perpX = -Math.sin(ang);
                                    const perpZ = Math.cos(ang);
                                    cell.x += perpX * lateral * 0.12;
                                    cell.z += perpZ * lateral * 0.12;
                                    // small vorticity for rotor signals
                                    cell.__vortex = (cell.__vortex || 0) + lateral * 0.006 * influence * (1 + (8 - gy)*0.03);
                                }
                            }
                        }
                    }
                }
            }
        }

        class CloudGrowth {
            constructor() {
                this.clouds = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.timer = 0;
                this.max = 50;
                this.clusterCenters = [];
                this.updrafts = [];
                this.thermalFields = []; // add thermal buoyancy columns
                this.windShearLayers = []; // wind shear feedback
            }

            // NEW: Enhanced thermal buoyancy modeling
            computeThermalBuoyancy(cloud, envTemp, altitude) {
                // cloud parcel temperature using moist adiabatic lapse (variable)
                const moistLapse = -6.5 + Math.max(0, (cloud.height - 10) * 0.1); // lapse decreases aloft
                const parcelTemp = (cloud.baseHeight || 15) - Math.abs(moistLapse) * ((cloud.height || 15) - (cloud.baseHeight || 15)) / 1000;
                // buoyancy directly from temperature difference
                const tempDiff = parcelTemp - envTemp;
                const buoyancy = 9.81 * (tempDiff / (envTemp + 273.15)); // m/s^2
                return Math.max(-0.5, Math.min(2.0, buoyancy * 0.1)); // scale to simulation units
            }

            // NEW: Wind shear-induced tilting and rotation
            computeShearTilt(cloud, windField) {
                const w_base = windField.getAt(cloud.x, cloud.cloudBase || 8, cloud.z) || { x: 0, z: 0 };
                const w_top = windField.getAt(cloud.x, cloud.height || 20, cloud.z) || { x: 0, z: 0 };
                const shear_x = w_top.x - w_base.x;
                const shear_z = w_top.z - w_base.z;
                const shearMag = Math.sqrt(shear_x * shear_x + shear_z * shear_z);
                // tilt reduces updraft efficiency slightly but adds structure
                cloud.tilt = (cloud.tilt || 0) + shearMag * 0.008;
                cloud.rotationRate = (cloud.rotationRate || 0) + shearMag * 0.015;
                return shearMag;
            }

            // NEW: Sub-grid scale turbulence energy injection
            injectTurbulenceEnergy(cloud, updraft, shear) {
                // turbulent kinetic energy (TKE) grows with updraft and shear, dissipates with entrainment
                const tke = (updraft * updraft * 0.4 + shear * shear * 0.2) * (1 - (cloud.entrainmentRate || 0.02) * 10);
                cloud.turbulence = Math.min(1.0, (cloud.turbulence || 0) * 0.92 + tke * 0.08);
                return cloud.turbulence;
            }

            createUpdraft(x, z, strength) {
                return {
                    x, z,
                    strength: strength,
                    radius: 20 + Math.random() * 15,
                    height: 0,
                    maxHeight: 35 + Math.random() * 10,
                    age: 0,
                    maxAge: 200 + Math.random() * 150,
                    active: true
                };
            }

            getUpdraftAt(x, z) {
                let totalLift = 0;
                for (const updraft of this.updrafts) {
                    if (!updraft.active) continue;
                    const dist = Math.sqrt((x - updraft.x) ** 2 + (z - updraft.z) ** 2);
                    if (dist < updraft.radius) {
                        const factor = 1 - (dist / updraft.radius);
                        totalLift += updraft.strength * factor * (updraft.age / updraft.maxAge);
                    }
                }
                return totalLift;
            }

            isOverWater(x, z) {
                for (const w of AppState.waterBodies) {
                    if (Math.sqrt((x - w.x) ** 2 + (z - w.y) ** 2) < w.r) return true;
                }
                return false;
            }

            findNearestCluster(x, z, maxDist = 25) {
                // more permissive clustering: search larger radius and prefer strongest nearby clusters
                let nearest = null;
                let minDist = Math.max(maxDist, 60); // bias to larger search area for clumping
                for (const cluster of this.clusterCenters) {
                    const dist = Math.sqrt((x - cluster.x) ** 2 + (z - cluster.z) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = cluster;
                    } else if (dist < maxDist * 1.8 && cluster.strength > (nearest && nearest.strength ? nearest.strength : 0)) {
                        // allow slightly farther, stronger cluster to attract new growth (clumping)
                        nearest = cluster;
                        minDist = dist;
                    }
                }
                return nearest;
            }

            createCluster(x, z) {
                // stronger clusters with increased attraction to produce clumping behavior
                const cluster = {
                    x, z,
                    strength: 1.0 + Math.random() * 1.2,
                    age: 0,
                    maxAge: 700 + Math.random() * 600,
                    hasUpdraft: false,
                    pull: 0.6 + Math.random() * 0.7
                };
                this.clusterCenters.push(cluster);
                return cluster;
            }

            // Replace the rainshaft point system with 3D mesh geometry
            _createInstancedShaftForCloud(cloud, intensity) {
                // Create a complex 3D funnel/shaft with segmented cylindrical meshes
                const segments = 12;
                // scale shaft radius to cloud footprint so downfall sheet matches precipitation area
                // increased base radius multiplier for larger, more intense shafts
                const shaftRadius = Math.max(6.0, (cloud.radius || 6) * (cloud.horizontalSpread || 1.0) * 1.6);
                const baseRadius = Math.max(2.8, (cloud.radius || 6) * 0.9);
                const topRadius = baseRadius * 0.22;
                const height = Math.max(8, (cloud.height || 12) - 0.5);
                
                // Create segmented shaft with dynamic radius tapering
                const shaftGroup = new THREE.Group();
                // increase segment count for smoother, taller shafts
                const segmentCount = 12;
                const segmentHeight = height / segmentCount;
                
                for (let seg = 0; seg < segmentCount; seg++) {
                    const ratio = seg / segmentCount;
                    // taper relative to computed shaftRadius for consistent scale
                    const currentRadius = shaftRadius * (1 - ratio * 0.6);
                    const nextRadius = shaftRadius * (1 - (seg + 1) / segmentCount * 0.6);
                    
                    // Create tapered cylinder for this segment
                    const geo = new THREE.CylinderGeometry(nextRadius, currentRadius, segmentHeight, segments, 1, true);
                    geo.translate(0, (seg + 0.5) * segmentHeight, 0);
                    
                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(0x85c9ff),
                        transparent: true,
                        // boost base opacity so shafts read as heavier precipitation
                        opacity: Math.max(0.12, (0.36 - ratio * 0.18) * Math.min(1.8, intensity)) * (cloud.dying ? 0.6 : 1.0),
                        metalness: 0.05,
                        roughness: 0.9,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                        emissive: new THREE.Color(0x3388bb),
                        emissiveIntensity: 0.08 * intensity
                    });
                    
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.castShadow = false;
                    mesh.receiveShadow = false;
                    mesh.userData = { segmentIndex: seg, totalSegments: segmentCount };
                    shaftGroup.add(mesh);
                }
                
                // position and bookkeeping
                shaftGroup.position.set(cloud.x, 0, cloud.z);
                shaftGroup.userData = {
                    cloudRef: cloud,
                    shaftRadius,
                    baseRadius,
                    topRadius,
                    height,
                    intensity,
                    // larger particle count proxy to support denser visual sheets
                    pcnt: Math.max(240, Math.floor(shaftRadius * 12))
                };
                
                // ensure shafts aren't culled when near frustum edges (keeps visual consistent)
                shaftGroup.frustumCulled = false;
                return shaftGroup;
            }

            makePuff(x, y, z, size, dark, turbulence = 0, cloudType = 'cumulus') {
                // use volumetric resolution from Graphics to adjust geometry detail for performance
                const res = Math.max(4, Math.floor(Graphics.volumetricResolution));
                
                // --- CIRRUS / HIGH-ALTITUDE SHEET / FIBROUS RENDERING ---
                if (cloudType && cloudType.startsWith('cirr')) {
                    // thin, stretched semi-transparent planes / streaks to emulate cirrus textures
                    const geom = new THREE.IcosahedronGeometry(size * 1.8, 3);
                    geom.scale(2.2, 0.18, 1.0);
                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(0.95, 0.96, 0.99),
                        transparent: true,
                        opacity: Graphics.volumetric ? (0.18 + dark * 0.12) * Graphics.volumetricDensity : 0.16,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                        blending: THREE.NormalBlending,
                        emissive: new THREE.Color(0.1, 0.15, 0.2),
                        emissiveIntensity: 0.08,
                        metalness: 0.0,
                        roughness: 0.95
                    });
                    const mesh = new THREE.Mesh(geom, mat);
                    mesh.position.set(x, y, z);
                    // orient as a broad horizontal sheet with a small random tilt rather than a 90¬∞ flip
                    mesh.rotation.set((Math.random() - 0.5) * 0.18, Math.random() * Math.PI, (Math.random() - 0.5) * 0.18);
                    mesh.castShadow = false;
                    mesh.receiveShadow = false;
                    // smooth transition metadata
                    mesh.userData.fade = { target: mat.opacity, speed: 0.018, life: 1.0, state: 'in' };
                    mat.opacity = 0.0;
                    return mesh;
                }

                if (Graphics.cloudRenderMode === 'particles') {
                    // Create a soft particle sprite instead of a mesh puff
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                    const baseAlpha = 0.85;
                    grad.addColorStop(0, `rgba(255,255,255,${baseAlpha})`);
                    grad.addColorStop(0.4, `rgba(240,245,255,${baseAlpha * 0.6})`);
                    grad.addColorStop(1, 'rgba(200,220,240,0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 64, 64);

                    const spriteMap = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({
                        map: spriteMap,
                        color: new THREE.Color(1, 1, 1),
                        transparent: true,
                        opacity: Graphics.volumetric ? (0.45 + dark * 0.25) * Graphics.volumetricDensity : 0.4,
                        depthWrite: false,
                        blending: THREE.NormalBlending
                    });
                    const sprite = new THREE.Sprite(material);
                    const scale = size * (0.6 + Math.random() * 0.9 + turbulence * 0.5);
                    sprite.scale.set(scale * (0.9 + Math.random() * 0.4), scale * (0.6 + Math.random() * 0.6), 1);
                    sprite.position.set(x, y, z);
                    sprite.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    // transition metadata
                    sprite.userData.fade = { target: material.opacity, speed: 0.02, life: 1.0, state: 'in' };
                    material.opacity = 0.0;
                    return sprite;
                }

                // Enhanced volumetric mesh puff with Icosahedron for smoother appearance
                const geo = new THREE.IcosahedronGeometry(size, Math.max(3, res - 1));
                
                // Highly varied shapes for realistic cumulus appearance
                const scaleX = 0.85 + Math.random() * 0.5 + turbulence * 0.15;
                const scaleY = 0.8 + Math.random() * 0.7 + turbulence * 0.25;
                const scaleZ = 0.9 + Math.random() * 0.6 + turbulence * 0.2;
                geo.scale(scaleX, scaleY, scaleZ);
                
                // Realistic cloud coloring - bright white tops, darker bases
                const heightFactor = Math.max(0, (y - 12) / 25);
                const topBrightness = 0.95 + heightFactor * 0.05;
                const baseBrightness = 0.75 - dark * 0.4;
                const b = baseBrightness + (topBrightness - baseBrightness) * heightFactor;
                
                // Use Lambert for soft, realistic lighting
                // modulate opacity by volumetric density control and optionally disable volumetric for flat puffs
                const baseOpacity = 0.45 + dark * 0.25 + turbulence * 0.1;
                const opacity = Graphics.volumetric ? baseOpacity * Graphics.volumetricDensity : Math.min(1, baseOpacity * 0.75);
                const mat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(b, b, b + 0.02),
                    transparent: true,
                    opacity: opacity,
                    depthWrite: false,
                    metalness: 0.05,
                    roughness: 0.88,
                    emissive: new THREE.Color(b * 0.08, b * 0.12, b * 0.15),
                    emissiveIntensity: 0.06 * (1 - Math.max(0, Math.min(1, dark))),
                    side: THREE.FrontSide
                });
                mat.fog = true;

                const m = new THREE.Mesh(geo, mat);
                m.position.set(x, y, z);
                m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                m.castShadow = true;
                m.receiveShadow = true;
                
                // Add density property to puff mesh userData for precipitation physics
                m.userData.density = Math.min(1.0, baseOpacity * 1.5);

                // Smooth fade-in initial state so puffs don't pop
                m.userData.fade = { target: mat.opacity, speed: 0.02 + Math.random() * 0.02, life: 1.0, state: 'in' };
                mat.opacity = 0.0;

                return m;
            }

            // NEW: Enhanced cloud type determination based on altitude and conditions
            determineCloudType(altitude, humidity, updraft, temperature, shear, convergence) {
                // High altitude clouds (>6km)
                if (altitude > 32) {
                    if (humidity > 0.4 && temperature < -20) return 'cirrus';
                    if (humidity > 0.5 && temperature < -15) return 'cirrostratus';
                    if (humidity > 0.45 && temperature < -18) return 'cirrocumulus';
                }
                
                // Low-level layered clouds (stratus family) ‚Äî prefer when low altitude, high humidity and weak updrafts,
                // or when near mountains with orographic lift producing broad laminar layers.
                if (altitude <= 12) {
                    // strong low-level saturation, weak vertical motion -> stratus
                    if (humidity > 0.78 && updraft < 0.25) return 'stratus';
                    // moderate humidity and weakly organized lift -> stratocumulus
                    if (humidity > 0.62 && updraft >= 0.2 && updraft < 0.8) return 'stratocumulus';
                }

                // Lenticular (mountain-wave) clouds: require mountains nearby and pronounced orographic updraft markers
                if (AppState.mountainRanges && AppState.mountainRanges.length > 0) {
                    // rough proximity check: sample nearest mountain distance
                    for (const m of AppState.mountainRanges) {
                        const dist = Math.hypot(m.x - (arguments[0] || 0), m.z - (arguments[2] || 0));
                        if (dist < m.r * 1.4 && updraft > 0.35 && humidity > 0.55) {
                            return 'lenticular';
                        }
                    }
                }
                
                // Mid-altitude clouds (2-6km)
                if (altitude > 18 && altitude <= 32) {
                    if (humidity > 0.75 && updraft > 0.5) return 'altocumulus';
                    if (humidity > 0.6 && updraft < 0.3 && convergence > 0.02) return 'altostratus';
                }
                
                // Low to mid-altitude with convective lift
                if (altitude > 8 && altitude <= 18) {
                    if (humidity > 0.8 && updraft > 1.2 && shear > 0.2) return 'nimbostratus';
                    if (humidity > 0.65 && updraft > 0.8) return 'stratocumulus';
                }
                
                // Strong convection (tall towers)
                if (updraft > 1.5 && humidity > 0.7 && altitude > 12 && altitude < 30) {
                    if (shear > 0.35) return 'supercell';
                    if (altitude > 24) return 'cumulonimbus';
                    return 'towering_cumulus';
                }
                
                // Default fair weather cumulus
                return 'cumulus';
            }

            // NEW: Refactored grow() method using type determination
            grow(x, z) {
                const env = sampleEnvironment(x, z, 12);
                const tempOk = env.temperature > -25 && env.temperature < 38;
                
                if (!tempOk) return null;
                
                const updraft = AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(x, z) : 0;
                const convergence = AppState.envAnalysis ? AppState.envAnalysis.computeMoistureConvergence(x, z, AppState.windField, env.humidity) : 0;
                const orographicLift = AppState.orographicSystem ? AppState.orographicSystem.computeOrographicLift(x, z) : 0;
                const shear = AppState.windShearSystem ? AppState.windShearSystem.computeShear(x, z) : 0;
                
                const baseLift = updraft * 1.4 + orographicLift * 1.2 + convergence * 1.6;
                // evaporation multiplier increases effective lift/formation tendency
                const evapMult = (typeof Graphics !== 'undefined' ? (Graphics.evapMultiplier || 1.0) : 1.0);
                const adjBaseLift = baseLift * evapMult;
                const minLift = 0.01 * (1 - Math.min(1, env.humidity));
                const humidityThreshold = 0.32 + (1 - Math.min(1, adjBaseLift * 6)) * 0.28;
                const humidityOk = env.humidity >= humidityThreshold;
                const liftOk = adjBaseLift > minLift;
                
                // Increase formation probability for stronger conditions
                const formationChance = Math.min(0.95, (humidityOk ? 0.62 : 0.06) + (liftOk ? 0.45 : 0) + convergence * 1.8 + updraft * 0.25 + (evapMult-1)*0.08);
                if (Math.random() > formationChance) {
                    // Rare high-altitude cirrus formation
                    if (env.humidity > 0.2 && Math.random() < 0.03) {
                        const envHigh = sampleEnvironment(x, z, 140);
                        if (envHigh.humidity > 0.15 && envHigh.temperature < -22) {
                            return this._formCirrus(x, z);
                        }
                    }
                    return null;
                }
                
                // NEW: Determine initial altitude based on atmospheric stability and lift
                // Cumulonimbus variants form lower; cirrus forms very high; altocumulus/altostratus in between
                // increased minimum altitude ~3x to reduce low-altitude spurious formation
                let initialAltitude = 24;
                if (updraft > 1.5 && env.humidity > 0.7) {
                    // Strong lift -> towering convection (low-forming)
                    initialAltitude = 18 + baseLift * 36;
                } else if (convergence > 0.05 && env.humidity > 0.6) {
                    // Moisture convergence -> mid-level stratiform
                    initialAltitude = 30 + Math.random() * 18;
                } else if (Math.abs(orographicLift) > 0.01 && env.humidity > 0.5) {
                    // Orographic forcing -> mid-altitude
                    initialAltitude = 24 + Math.random() * 24;
                } else {
                    // Fair weather cumulus (variable)
                    initialAltitude = 18 + Math.random() * 18;
                }
                
                const widthFactor = 1.3 + Math.random() * 0.85;
                const c = {
                    x, z, age: 0,
                    maxAge: 420 + Math.random() * 380,
                    baseHeight: Math.max(5, initialAltitude - 1.2),
                    height: null, cloudTop: null, cloudBase: null,
                    puffs: [], grp: new THREE.Group(),
                    dying: false, cluster: null,
                    growthRate: 0.045 + Math.random() * 0.05,
                    mass: 1.2 + baseLift * 2.4,
                    condensationLevel: Math.min(1, humidityOk ? 0.48 + baseLift * 0.2 : 0.14),
                    turbulence: updraft * 0.8 + Math.abs(orographicLift) * 0.6 + shear * 0.3,
                    velocity: { x: 0, z: 0 },
                    targetVelocity: { x: 0, z: 0 },
                    radius: 2.6 + Math.random() * 2.8,
                    widthFactor: widthFactor,
                    horizontalSpread: 1.15 + baseLift * 0.95,
                    mergeTimer: 0, canMerge: true,
                    verticalVelocity: Math.max(0.06, baseLift * 0.14 + updraft * 0.10),
                    buoyancy: 0.9 + baseLift * 3.2 + updraft * 2.4,
                    stage: 'cumulus', // will be overridden by determineCloudType
                    entrainmentRate: 0.015,
                    shearTilt: 0,
                    precipitation: 0,
                    hasAnvil: false,
                    anvilTimer: 0,
                    thermalEnergy: 0.3 + Math.random() * 0.4,
                    variant: null // NEW: cloud variant type
                };
                
                c.height = c.baseHeight + 0.6;
                c.cloudTop = c.baseHeight + 1.4;
                c.cloudBase = Math.max(2, c.baseHeight - 2.5);
                c.grp.position.set(x, 0, z);
                this.group.add(c.grp);
                
                // Seed initial puffs immediately so new clouds appear with full structure
                {
                    const seedCount = 6 + Math.floor(Math.min(8, Math.max(0, c.mass)));
                    // FIXED: Scale footprint by all structural factors so spawn area matches visible cloud
                    const footprint = Math.max(3.6, (c.radius || 6) * (c.horizontalSpread || 1.0) * (c.widthFactor || 1.0));
                    const spread = Math.max(1.6, footprint * (0.8 + Math.random() * 0.6));
                    for (let si = 0; si < seedCount; si++) {
                        const a = Math.random() * Math.PI * 2;
                        const px = Math.cos(a) * spread;
                        const pz = Math.sin(a) * spread;
                        const baseH = c.height || (c.baseHeight + 0.8);
                        const ph = baseH + (Math.random() - 0.4) * 1.8 + (c.condensationLevel || 0) * 3.0;
                        const dark = Math.min(0.28, 0.06 + (c.condensationLevel || 0) * 0.35 + Math.random() * 0.06);
                        const turb = Math.min(0.9, c.turbulence || 0.12);
                        const size = (1.6 + Math.random() * 2.6) * (c.stage === 'cumulonimbus' ? 1.4 : 1.0);
                        const puff = this.makePuff(px, ph, pz, size, dark, turb, undefined);
                        // NEW: Add development animation metadata to puff
                        puff.userData = puff.userData || {};
                        puff.userData.growthPhase = 0; // 0-1 for animation
                        puff.userData.targetScale = puff.scale.length();
                        puff.scale.multiplyScalar(0.4); // start small, grow in
                        c.puffs.push(puff);
                        c.grp.add(puff);
                    }
                    // give an initial stronger vertical push so the cloud develops height faster
                    c.verticalVelocity = Math.max(0.08, (c.verticalVelocity || 0) + 0.03 + (c.mass || 0) * 0.006);
                    // bump initial mass slightly to ensure growth logic activates
                    c.mass = Math.max(c.mass, 1.6 + Math.random() * 0.8);
                }
                
                if (AppState.detailedMicrophysics) {
                    AppState.detailedMicrophysics.initializeSpectrum(c);
                }
                return c;
            }

            checkMerge(cloud1, cloud2) {
                const dist = Math.sqrt((cloud1.x - cloud2.x) ** 2 + (cloud1.z - cloud2.z) ** 2);
                // more aggressive merging to create clumps: larger merge radius and more permissive age/height checks
                const mergeRadius = (cloud1.radius * cloud1.horizontalSpread + cloud2.radius * cloud2.horizontalSpread) * 1.1;
                if (dist < mergeRadius && cloud1.canMerge && cloud2.canMerge &&
                    (cloud1.age > 20 || cloud2.age > 20) &&
                    Math.abs(cloud1.height - cloud2.height) < 14) {
                    return true;
                }
                return false;
            }

            mergeClouds(cloud1, cloud2) {
                const totalMass = cloud1.mass + cloud2.mass;
                
                // Transfer mass and properties
                cloud1.mass += cloud2.mass * 0.85;
                
                // Merge radii like 3D terrain - additive volume
                const volume1 = Math.PI * cloud1.radius * cloud1.radius * cloud1.horizontalSpread;
                const volume2 = Math.PI * cloud2.radius * cloud2.radius * cloud2.horizontalSpread;
                const totalVolume = volume1 + volume2;
                cloud1.radius = Math.sqrt(totalVolume / (Math.PI * cloud1.horizontalSpread)) * 0.9;
                
                // Average width factors
                cloud1.widthFactor = (cloud1.widthFactor * cloud1.mass + cloud2.widthFactor * cloud2.mass) / totalMass;
                cloud1.horizontalSpread = (cloud1.horizontalSpread + cloud2.horizontalSpread) / 2;
                
                cloud1.maxAge += cloud2.maxAge * 0.4;
                cloud1.condensationLevel = Math.max(cloud1.condensationLevel, cloud2.condensationLevel);
                
                // Smooth position blend (like terrain heightmap merging)
                const blendFactor = cloud2.mass / totalMass;
                cloud1.x = cloud1.x * (1 - blendFactor) + cloud2.x * blendFactor;
                cloud1.z = cloud1.z * (1 - blendFactor) + cloud2.z * blendFactor;
                
                // Blend heights
                cloud1.cloudTop = Math.max(cloud1.cloudTop, cloud2.cloudTop);
                cloud1.cloudBase = Math.min(cloud1.cloudBase, cloud2.cloudBase);
                cloud1.height = cloud1.cloudTop;
                
                // Transfer puffs in a blended manner
                const transferCount = Math.min(8, cloud2.puffs.length);
                for (let i = 0; i < transferCount; i++) {
                    if (cloud2.puffs[i]) {
                        const puff = cloud2.puffs[i];
                        // Adjust puff position relative to new cloud center
                        const offsetX = cloud2.x - cloud1.x;
                        const offsetZ = cloud2.z - cloud1.z;
                        puff.position.x -= offsetX;
                        puff.position.z -= offsetZ;
                        cloud1.puffs.push(puff);
                        cloud1.grp.add(puff);
                    }
                }
                
                // Mark for removal
                cloud2.dying = true;
                cloud2.maxAge = cloud2.age + 10;
                
                // Cooldown
                cloud1.mergeTimer = 150;
                cloud1.canMerge = false;
            }

            update(t) {
                this.timer++;
                
                // Update updrafts
                this.updrafts = this.updrafts.filter(updraft => {
                    updraft.age++;
                    updraft.height = Math.min(updraft.maxHeight, updraft.height + 0.1);
                    // lateral spreading of updraft as it rises
                    updraft.radius *= (1 + 0.002);
                    updraft.strength *= 0.995; // gradual decay
                    if (updraft.age > updraft.maxAge || updraft.strength < 0.1) {
                        updraft.active = false;
                        return false;
                    }
                    return true;
                });
                
                // Update cluster centers with enhanced aging
                this.clusterCenters = this.clusterCenters.filter(cluster => {
                    cluster.age++;
                    // clusters drift slightly with wind field average
                    const w = AppState.windField.getAt(cluster.x, 10, cluster.z) || { x: 0, z: 0 };
                    cluster.x += w.x * 0.02;
                    cluster.z += w.z * 0.02;
                    // clusters persist longer and strengthen slowly if nearby clouds exist
                    const nearby = this.clouds.filter(c => Math.hypot(c.x - cluster.x, c.z - cluster.z) < (cluster.pull ? 40 * cluster.pull : 48));
                    if (nearby.length > 2) {
                        cluster.strength = Math.min(3.0, cluster.strength + 0.002 * nearby.length);
                        cluster.maxAge = Math.max(cluster.maxAge, 800);
                    } else {
                        // clusters decay faster in low-CAPE environments
                        const cape = AppState.atmosphericLayers ? AppState.atmosphericLayers.computeCALE(8, 20) : 500;
                        cluster.maxAge = Math.max(200, 400 - cape / 10);
                    }
                    
                    // Create updraft for mature clusters with probabilistic triggering
                    if (cluster.age === Math.max(30, cluster.maxAge / 8) && !cluster.hasUpdraft && Math.random() > (1 - cape / 2500)) {
                        this.updrafts.push(this.createUpdraft(cluster.x, cluster.z, 0.8 + Math.random() * 0.6));
                        cluster.hasUpdraft = true;
                    }
                    
                    return cluster.age < cluster.maxAge;
                });
                
                // Spawn new clouds with enhanced environmental checking
                if (this.timer % 20 === 0 && this.clouds.length < this.max) {
                    let attempts = 0;
                    let c = null;
                    while (!c && attempts < 6) {
                        const span = 400;
                        const spawnX = (Math.random() * 2 - 1) * span;
                        const spawnZ = (Math.random() * 2 - 1) * span;

                        // NEW: avoid spawning clouds far outside camera render distance to reduce false precipitation from distant pockets
                        const cam = AppState.camera ? AppState.camera.position : { x:0, y:0, z:0 };
                        const dx = spawnX - cam.x;
                        const dz = spawnZ - cam.z;
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        if (dist > (Graphics.renderDistance || 260) * 1.4) { attempts++; continue; }

                        // bias spawning toward existing clusters strongly so clouds clump
                        const nearCluster = this.findNearestCluster(spawnX, spawnZ, 40);
                        if (!nearCluster && Math.random() < 0.48) {
                            // sometimes create new cluster, but at higher chance to seed groups
                            this.createCluster(spawnX, spawnZ);
                        } else if (nearCluster && Math.random() < 0.8 * (nearCluster.pull || 0.6)) {
                            // if cluster nearby, nudge spawn to cluster center to produce clumping
                            const jitter = (Math.random() - 0.5) * 0.6 * nearCluster.strength;
                            spawnX = nearCluster.x + (Math.random() - 0.5) * 8 * nearCluster.pull + jitter;
                            spawnZ = nearCluster.z + (Math.random() - 0.5) * 8 * nearCluster.pull + jitter;
                        }

                        c = this.grow(spawnX, spawnZ);
                        if (c) {
                            c.cluster = nearCluster;
                            this.clouds.push(c);
                        }
                        attempts++;
                    }
                }

                // Check for cloud merging with enhanced criteria
                for (let i = 0; i < this.clouds.length; i++) {
                    for (let j = i + 1; j < this.clouds.length; j++) {
                        if (this.checkMerge(this.clouds[i], this.clouds[j])) {
                            this.mergeClouds(this.clouds[i], this.clouds[j]);
                            break;
                        }
                    }
                }

                this.clouds = this.clouds.filter(c => {
                    c.age++;
                    
                    // Update merge timer
                    if (c.mergeTimer > 0) {
                        c.mergeTimer--;
                        if (c.mergeTimer === 0) c.canMerge = true;
                    }
                    
                    // Realistic cloud movement with wind advection
                    const windAt = AppState.windField.getAt(c.x, c.height, c.z);
                    c.targetVelocity.x = windAt.x * 0.5;
                    c.targetVelocity.z = windAt.z * 0.5;
                    
                    // Smooth velocity response (inertia)
                    c.velocity.x += (c.targetVelocity.x - c.velocity.x) * 0.08;
                    c.velocity.z += (c.targetVelocity.z - c.velocity.z) * 0.08;
                    
                    c.x += c.velocity.x;
                    c.z += c.velocity.z;
                    c.grp.position.x = c.x;
                    c.grp.position.z = c.z;

                    // --- CLOUD-DRIVEN WIND FORCING ---
                    try {
                        if (AppState.windField && AppState.windField.field) {
                            // compute a local forcing strength from cloud properties
                            const cloudForce = Math.min(1.6, (c.turbulence || 0) * 0.9 + (c.mass || 0) * 0.06);
                            const influenceRadius = Math.max(6, (c.radius || 4) * (c.horizontalSpread || 1.0) * 1.6);
                            const size = AppState.windField.size;
                            const spacing = AppState.windField.spacing;
                            // iterate only cells within influenceRadius (map to grid indices)
                            const gx0 = Math.max(0, Math.floor(((c.x - influenceRadius) / spacing) + size / 2));
                            const gx1 = Math.min(size - 1, Math.floor(((c.x + influenceRadius) / spacing) + size / 2));
                            const gz0 = Math.max(0, Math.floor(((c.z - influenceRadius) / spacing) + size / 2));
                            const gz1 = Math.min(size - 1, Math.floor(((c.z + influenceRadius) / spacing) + size / 2));
                            for (let gx = gx0; gx <= gx1; gx++) {
                                for (let gz = gz0; gz <= gz1; gz++) {
                                    for (let gy = 0; gy < Math.min(6, size); gy++) {
                                        const wx = (gx - size / 2) * spacing;
                                        const wz = (gz - size / 2) * spacing;
                                        const dx = wx - c.x;
                                        const dz = wz - c.z;
                                        const dist = Math.hypot(dx, dz);
                                        if (dist > influenceRadius) continue;
                                        const influence = 1 - dist / influenceRadius;
                                        const cell = AppState.windField.field[gx][gy][gz];
                                        if (!cell) continue;
                                        // radial outflow from cloud base + rotational component from tilt/turbulence
                                        // stronger forcing scaled by cloud structure (mass, turbulence, horizontalSpread)
                                        const dirx = (dx / (dist + 0.0001));
                                        const dirz = (dz / (dist + 0.0001));
                                        // scale cloudForce with horizontalSpread and widthFactor for structural influence
                                        const structureScale = (1 + (c.horizontalSpread || 1.0) * 0.6 + (c.widthFactor || 1.0) * 0.4);
                                        const outflow = cloudForce * 0.12 * structureScale * influence; // stronger visual forcing
                                        // apply radial push (outflow), with extra effect if cloud tilt/sheer present
                                        cell.x += -dirx * outflow * (1 + (c.shearTilt || 0) * 0.9);
                                        cell.z += -dirz * outflow * (1 + (c.shearTilt || 0) * 0.9);
                                        // rotational shear from cloud rotationRate/turbulence (creates local vorticity)
                                        const rot = (c.rotationRate || 0) * 0.02 * influence * (1 + (c.turbulence || 0) * 0.8);
                                        cell.x += -dirz * rot;
                                        cell.z += dirx * rot;
                                        // mark a low-level gust signature for precipitation/visual systems
                                        if (!cell.__cloudGust) cell.__cloudGust = 0;
                                        cell.__cloudGust += outflow * 0.6;
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // swallow errors to avoid breaking cloud updates
                    }

                    // --- CLOUD-INDUCED STRONG GUST EFFECTS (camera shake & urban damage) ---
                    try {
                        // sample local near-surface wind after injections
                        const localWind = AppState.windField.getAt(c.x, 1.6, c.z) || { x: 0, z: 0 };
                        const localMag = Math.hypot(localWind.x || 0, localWind.z || 0);
                        // if near-cloud gusts exceed threshold, apply camera shake scaled by proximity/intensity
                        const gustTrigger = 1.6; // tuned threshold where effects become noticeable
                        if (localMag > gustTrigger) {
                            const proximity = Math.min(1, localMag / (gustTrigger * 2.4));
                            const shakeStrength = 0.6 + proximity * 3.4;
                            AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity || 0, shakeStrength);
                            AppState.cameraControls.shake.duration = Math.max(AppState.cameraControls.shake.duration || 0, 700);
                            AppState.cameraControls.shake.time = 0;

                            // Damage nearby urban buildings proportionally to gust strength
                            if (AppState.urbanSystem && AppState.urbanSystem.cities) {
                                const damageRadius = Math.max(12, (c.radius || 6) * 1.8 + proximity * 40);
                                for (const city of AppState.urbanSystem.cities) {
                                    for (let bi = city.buildings.length - 1; bi >= 0; bi--) {
                                        const bmesh = city.buildings[bi];
                                        if (!bmesh || !bmesh.position) continue;
                                        const dx = bmesh.position.x + city.x - c.x;
                                        const dz = bmesh.position.z + city.z - c.z;
                                        const d = Math.hypot(dx, dz);
                                        if (d < damageRadius && Math.random() < Math.min(0.4, proximity * 0.16 + (localMag - gustTrigger) * 0.08)) {
                                            // apply visible damage: darken and slightly tilt/scale the building; occasionally remove tall structures
                                            try {
                                                if (bmesh.material && bmesh.material.color) bmesh.material.color.lerp(new THREE.Color(0x332f2f), 0.28);
                                                bmesh.rotation.z += (Math.random() - 0.5) * 0.08 * proximity;
                                                bmesh.scale.y *= (0.96 + Math.random() * 0.02);
                                                // chance to collapse small buildings when gusts are extremely strong
                                                if (localMag > gustTrigger * 2.4 && Math.random() < 0.05 * proximity) {
                                                    city.group.remove(bmesh);
                                                    city.buildings.splice(bi, 1);
                                                }
                                            } catch (er) {}
                                        }
                                    }
                                }
                            }
                        }
                    } catch (e) { /* fail silently */ }

                    // --- TREE DAMAGE / BREAKING CHECK ---
                    try {
                        if (AppState.treeSystem && AppState.treeSystem.trees && AppState.windField) {
                            const breakThreshold = 1.4 + (Graphics.windMultiplier || 1.0) * 0.6; // tuned threshold
                            for (let ti = AppState.treeSystem.trees.length - 1; ti >= 0; ti--) {
                                const tr = AppState.treeSystem.trees[ti];
                                if (!tr) continue;
                                const dx = tr.position.x - c.x;
                                const dz = tr.position.z - c.z;
                                const d = Math.hypot(dx, dz);
                                if (d > Math.max(6, (c.radius || 4) * 1.8)) continue;
                                // sample local wind magnitude at near-ground
                                const w = AppState.windField.getAt(tr.position.x, 1.6, tr.position.z);
                                const wmag = Math.hypot(w.x || 0, w.z || 0);
                                // combine with cloud gust marker for episodic bursts
                                const gust = (w.__cloudGust || 0);
                                if (wmag + gust > breakThreshold && Math.random() < 0.12) {
                                    // "break" the tree: spawn a subtle debris impulse and remove tree
                                    try {
                                        // small visual impulse via treeSystem.applyImpulse for remaining trees
                                        if (AppState.treeSystem) AppState.treeSystem.applyImpulse(tr.position.x, tr.position.z, 10 + wmag * 8, 10 + Math.random() * 18);
                                        // dispose and remove tree from scene & array
                                        tr.traverse(o => {
                                            if (o.geometry) try { o.geometry.dispose(); } catch(e){}
                                            if (o.material) try { o.material.dispose(); } catch(e){}
                                        });
                                        AppState.treeSystem.group.remove(tr);
                                        AppState.treeSystem.trees.splice(ti, 1);
                                    } catch (ex) {}
                                }
                            }
                        }
                    } catch (e) {}

                    // ENHANCED: Compute thermal buoyancy with environmental temperature profile
                    const envTemp = AppState.atmosphericLayers ? AppState.atmosphericLayers.getTemperature(c.height) : (15 - c.height * 0.65);
                    const thermalBuoy = this.computeThermalBuoyancy(c, envTemp, c.height);
                    
                    // ENHANCED: Compute wind shear and tilt
                    const shearMag = this.computeShearTilt(c, AppState.windField);
                    
                    // ENHANCED: Inject turbulence energy
                    const updraftLift = AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(c.x, c.z) : 0;
                    this.injectTurbulenceEnergy(c, updraftLift, shearMag);
                    
                    // Progressive mass accumulation with microphysical feedback
                    const microphysicsBoost = AppState.detailedMicrophysics ? 
                        (AppState.detailedMicrophysics.dropletSpectra.get(c)?.liquid_water || 0) * 0.05 : 0;
                    c.mass += 0.04 + c.condensationLevel * 0.06 + updraftLift * 0.06 + microphysicsBoost;
                    
                    // Condensation ramps with environmental stability
                    const stabilityFactor = 1 - Math.max(0, (envTemp - 5) / 30); // colder = more condensation
                    c.condensationLevel = Math.min(1, c.age / 90 * stabilityFactor + (updraftLift > 0.2 ? 0.15 : 0));
                    
                    c.radius = 2 + c.mass * 0.85;
                    
                    // NEW: Update cloud variant and morphing
                    const oldVariant = c.variant;
                    c.variant = this.determineCloudVariant(c.height, c.condensationLevel, updraftLift, c.mass);
                    c.stage = c.variant || c.stage; // use variant as stage if available
                    // morphing updates
                    this.updateCloudMorphing(c);
                    
                    // ENHANCED: Stage-dependent behavior with finer transitions
                    let growthStage = 'developing';
                    const oldStage = c.stage;
                    
                    if (c.cloudTop < 18) {
                        c.stage = 'cumulus';
                        growthStage = 'developing';
                    } else if (c.cloudTop < 28 && c.mass > 2.5) {
                        c.stage = 'towering_cumulus';
                        growthStage = 'developing_to_mature';
                    } else if (c.cloudTop >= 28 && c.cloudTop < 35 && c.mass > 5) {
                        c.stage = 'cumulonimbus';
                        growthStage = 'mature';
                    } else if (c.cloudTop >= 35 && c.mass > 8 && c.condensationLevel > 0.75 && shearMag > 0.1) {
                        c.stage = 'supercell';
                        growthStage = 'mature_intense';
                        c.turbulence = Math.max(c.turbulence, 0.7);
                    }
                    
                    // Apply entrainment (mixing reduces condensation/mass slightly)
                    const entrainmentFactor = Math.max(0.01, Math.min(0.08, shearMag * 0.02));
                    c.entrainmentRate = (c.entrainmentRate || 0.02) * 0.96 + entrainmentFactor * 0.04;
                    c.condensationLevel *= (1 - c.entrainmentRate * 0.02);
                    c.mass *= (1 - c.entrainmentRate * 0.01);
                    
                    // Vertical development with environmental feedback
                    const verticalAccel = thermalBuoy + updraftLift * 0.05;
                    c.verticalVelocity += verticalAccel * 0.025;
                    c.verticalVelocity *= 0.96; // damping
                    
                    c.cloudTop += c.verticalVelocity;
                    c.height = c.cloudTop;
                    c.cloudBase += c.verticalVelocity * (0.2 + Math.random() * 0.1);

                    // Enhanced horizontal spreading based on stage and shear
                    if (c.stage === 'cumulus') {
                        c.horizontalSpread = 1.15 + c.widthFactor * 0.35 + shearMag * 0.1;
                    } else if (c.stage === 'towering_cumulus') {
                        c.horizontalSpread = 1.05 + c.widthFactor * 0.3 + shearMag * 0.08;
                    } else if (c.stage === 'cumulonimbus') {
                        c.horizontalSpread = 1.7 + c.widthFactor * 0.65 + shearMag * 0.15;
                    } else if (c.stage === 'supercell') {
                        c.horizontalSpread = 2.3 + c.widthFactor * 0.8 + shearMag * 0.2;
                    }

                    // NEW: Structural adjustments based on determined type
                    if (c.stage.includes('lenticular') || c.stage.includes('stratus') || c.stage.includes('altostratus')) {
                        // Damp vertical growth and enforce horizontal spread for layered clouds
                        c.verticalVelocity *= 0.55;
                        c.horizontalSpread = Math.max(c.horizontalSpread, c.radius * 2.8);
                        c.widthFactor = Math.min(1.0, c.widthFactor * 0.8);
                        // Layering parameters for puff creation
                        c._puffLayerHeightOffset = 0.2; // very small offset
                        c._puffLayerSpreadMultiplier = 1.8; // strong lateral spread
                        c._minPuffsPerLayer = 4; // enforce more puffs per layer for visual density
                    } else {
                        // Reset to convective defaults
                        c._puffLayerHeightOffset = 0.7;
                        c._puffLayerSpreadMultiplier = 1.0;
                        c._minPuffsPerLayer = 1;
                    }

                    // Anvil top creation with enhanced realism
                    if ((c.stage === 'cumulonimbus' || c.stage === 'supercell') && !c.dying) {
                        if (!c.hasAnvil) {
                            c.hasAnvil = false;
                            c.anvilTimer = 0;
                        }
                        // Anvil forms more readily in high-shear environments (IMPROVED: lower threshold)
                        const anvilFormChance = 0.12 * (1 + shearMag * 0.3); // INCREASED from 0.06
                        if (!c.hasAnvil && Math.random() < anvilFormChance) {
                            c.hasAnvil = true;
                            c.anvilTimer = 350 + Math.floor(Math.random() * 500);
                            // broader anvil in high-shear regimes
                            const anvilCount = 8 + Math.floor(Math.min(20, c.radius * 1.1 * (1 + shearMag))); // MORE anvil puffs
                            for (let ai = 0; ai < anvilCount; ai++) {
                                const ax = (Math.random() - 0.5) * c.radius * (2.4 + shearMag * 0.5 + Math.random() * 1.5);
                                const az = (Math.random() - 0.5) * c.radius * (2.4 + shearMag * 0.5 + Math.random() * 1.5);
                                const ay = (c.cloudTop || c.height) + 6.5 + Math.random() * 7;
                                const asize = 4.2 + Math.random() * 7.0;
                                const dark = 0.06 + Math.random() * 0.08;
                                const anvilPuff = this.makePuff(ax, ay, az, asize, dark, 0.07, 'cirrostratus');
                                anvilPuff.userData = anvilPuff.userData || {};
                                anvilPuff.userData.ice = true;
                                anvilPuff.userData.density = Math.max(0.24, Math.min(0.9, (anvilPuff.userData.density || 0.3) * 1.15));
                                const cloudTopY = (c.cloudTop || c.height || 0);
                                anvilPuff.position.set(ax, (ay - cloudTopY), az);
                                anvilPuff.userData.isAnvil = true;
                                anvilPuff.userData.localYOffset = anvilPuff.position.y;
                                // NEW: Anvil development animation
                                anvilPuff.userData.growthPhase = 0;
                                anvilPuff.userData.targetScale = anvilPuff.scale.clone();
                                anvilPuff.scale.multiplyScalar(0.3);
                                c.puffs.push(anvilPuff);
                                c.grp.add(anvilPuff);
                            }
                        }

                        if (c.hasAnvil) {
                            c.anvilTimer--;
                            // Refresh anvil structure more frequently in high-shear cases
                            const refreshChance = 0.65 + shearMag * 0.3; // INCREASED from 0.45
                            if (c.anvilTimer % 70 === 0 && Math.random() < refreshChance) {
                                const ax = (Math.random() - 0.5) * c.radius * (1.7 + shearMag * 0.3);
                                const az = (Math.random() - 0.5) * c.radius * (1.7 + shearMag * 0.3);
                                const ay = (c.cloudTop || c.height) + 6.8 + Math.random() * 5.0;
                                const asize = 2.4 + Math.random() * 4.2;
                                const anvilWisp = this.makePuff(ax, ay, az, asize, 0.04 + Math.random() * 0.07, 0.02, 'cirrostratus');
                                anvilWisp.userData = anvilWisp.userData || {};
                                anvilWisp.userData.ice = true;
                                anvilWisp.userData.density = Math.max(0.14, Math.min(0.65, (anvilWisp.userData.density || 0.2) * 0.95));
                                const cloudTopY2 = (c.cloudTop || c.height || 0);
                                anvilWisp.position.set(ax, (ay - cloudTopY2), az);
                                anvilWisp.userData.isAnvil = true;
                                anvilWisp.userData.localYOffset = anvilWisp.position.y;
                                // NEW: Anvil wisp animation
                                anvilWisp.userData.growthPhase = 0;
                                anvilWisp.userData.targetScale = anvilWisp.scale.clone();
                                anvilWisp.scale.multiplyScalar(0.2);
                                c.puffs.push(anvilWisp);
                                c.grp.add(anvilWisp);
                            }
                            // Anvil precipitation sourcing slightly enhanced by shear
                            if (AppState.rainSystem && Math.random() < (0.1 + shearMag * 0.02)) { // INCREASED from 0.065
                                try { AppState.rainSystem.spawnDropFromCloud(c); } catch(e) {}
                            }
                            if (c.anvilTimer <= 0 || Math.random() < 0.007) {
                                c.hasAnvil = false;
                            }
                        }
                    }

                    // Multi-stage growth with enhanced realism
                    let effectiveGrowthRate = c.growthRate * (1 + updraftLift * (2.5 + shearMag));
                    
                    if (c.stage === 'cumulonimbus') {
                        effectiveGrowthRate *= (1.2 + shearMag * 0.8);
                    } else if (c.stage === 'supercell') {
                        effectiveGrowthRate *= (1.5 + shearMag * 1.2);
                    }
                    
                    if (c.age < c.maxAge * 0.75) {
                        let puffInterval = 5;
                        if (updraftLift > 0.6) puffInterval = 2;
                        else if (updraftLift > 0.3) puffInterval = 3;
                        
                        if (c.age % puffInterval === 0) {
                            let puffCount = (updraftLift > 0.6 && growthStage === 'developing') ? 4 : (updraftLift > 0.5 ? 3 : 1);
                            if (c.stage === 'cumulonimbus') puffCount = Math.max(puffCount, 3);
                            if (c.stage === 'supercell') puffCount = Math.max(puffCount, 5);
                            
                            for (let p = 0; p < puffCount; p++) {
                                const a = Math.random() * Math.PI * 2;
                                const d = Math.sqrt(c.puffs.length) * 0.6 + Math.random() * 1.5;
                                
                                const baseH = c.height + c.age * effectiveGrowthRate;
                                const h = baseH + updraftLift * (6 + shearMag * 2) + (growthStage === 'mature' ? 2.5 : 0);
                                
                                const dark = Math.min(0.7, (c.age / 220) + c.condensationLevel * 0.35 + (growthStage === 'mature' ? 0.18 : 0));
                                
                                const layerCount = (c.stage === 'supercell' ? 5 : 4) + (c.stage.includes('lenticular') ? 2 : 0);
                                const baseLayerCount = (growthStage === 'mature' || dark > 0.38) ? layerCount : 2;

                                for (let layer = 0; layer < baseLayerCount; layer++) {
                                    const angleOffset = (layer * Math.PI * 2) / baseLayerCount + (Math.random() - 0.5) * 0.3;
                                    const radiusOffset = layer * 0.5 * (c._puffLayerSpreadMultiplier || 1.0);
                                    const heightOffset = layer * (c._puffLayerHeightOffset || 0.7) - 0.4;
                                    
                                    const spread = (c.radius * Math.max(1.1, c.widthFactor)) * (0.75 + Math.random() * 1.2 + shearMag * 0.3) * (c._puffLayerSpreadMultiplier || 1.0);
                                    const radial = spread * (0.8 + Math.random() * 0.7) + radiusOffset + (Math.sqrt(c.puffs.length) * 0.25);
                                    const cloudTypeForPuff = (c.stage && c.stage.startsWith('cirr')) ? c.stage : undefined;
                                    const sizeBoost = (c.stage === 'cumulonimbus' ? 1.3 : (c.stage === 'supercell' ? 1.6 : 1.0));

                                    // Spawn multiple puffs per layer if configured for dense layered structures
                                    const puffsInLayer = c._minPuffsPerLayer || 1;
                                    for (let l_idx = 0; l_idx < puffsInLayer; l_idx++) {
                                        const jitterX = (l_idx / puffsInLayer) * radial * 0.1;
                                        const jitterZ = (l_idx / puffsInLayer) * radial * 0.1;
                                        const puff = this.makePuff(
                                            Math.cos(a + angleOffset) * radial + jitterX,
                                            h + heightOffset,
                                            Math.sin(a + angleOffset) * radial + jitterZ,
                                            (1.9 + Math.random() * 3.0 + updraftLift * 1.6 + (growthStage === 'mature' ? 1.2 : 0)) * sizeBoost,
                                            dark + layer * 0.09,
                                            Math.min(0.95, c.turbulence + (c.stage === 'supercell' ? 0.3 : 0)),
                                            cloudTypeForPuff
                                        );
                                        c.puffs.push(puff);
                                        c.grp.add(puff);
                                    }
                                }
                                c.height = h;
                            }
                        }
                    }
                    
                    if (c.age > c.maxAge) {
                        c.dying = true;
                        c.puffs.forEach(p => {
                            if (!p) return;
                            p.userData = p.userData || {};
                            p.userData.dissipate = p.userData.dissipate || (0.025 + Math.random() * 0.05);
                            p.userData.vy = p.userData.vy || (0.003 + Math.random() * 0.005);
                        });
                    }
                    
                    // Enhanced animation with shear-induced tilt
                    c.puffs.forEach((p, i) => {
                        if (p) {
                            if (p.userData && p.userData.isAnvil) {
                                const localY = (p.userData.localYOffset !== undefined) ? p.userData.localYOffset : p.position.y;
                                p.position.y = (c.cloudTop || c.height || 0) + localY;
                            }

                            p.rotation.y += 0.0002 + c.turbulence * 0.0006 + shearMag * 0.0002;
                            p.rotation.z += c.turbulence * 0.0003 + c.tilt * 0.0001;
                            
                            const puffLift = AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(c.x, c.z) * 0.012 : 0;
                            p.position.y += Math.sin(t * 0.0003 + i) * 0.004 + puffLift;
                            
                            if (c.turbulence > 0.25) {
                                p.position.x += Math.sin(t * 0.0005 + i) * c.turbulence * 0.025;
                                p.position.z += Math.cos(t * 0.0005 + i) * c.turbulence * 0.025;
                            }

                            // NEW: Updraft-driven puff duplication and upward transport
                            try {
                                const localUpdraft = AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(c.x, c.z) : 0;
                                // chance to spawn a lightweight clone when updraft is significant
                                if (!p.userData._cloneCooldown) p.userData._cloneCooldown = 0;
                                if (localUpdraft > 0.6 && p.userData._cloneCooldown <= 0 && Math.random() < Math.min(0.12, localUpdraft * 0.06)) {
                                    p.userData._cloneCooldown = 28 + Math.floor(Math.random() * 40);
                                    // create small duplicate slightly offset and with upward velocity
                                    const clone = this.makePuff(
                                        p.position.x + (Math.random() - 0.5) * 0.8,
                                        p.position.y + 0.2,
                                        p.position.z + (Math.random() - 0.5) * 0.8,
                                        (p.scale ? (p.scale.x + p.scale.y) * 0.35 : 0.9) * (0.6 + Math.random() * 0.6),
                                        Math.max(0.02, (p.userData && p.userData.density ? (1 - p.userData.density * 0.2) : 0.06)),
                                        Math.min(0.6, (c.turbulence || 0) + 0.02)
                                    );
                                    // tag as updraft clone with simple rise/spread behavior
                                    clone.userData = clone.userData || {};
                                    clone.userData.updraftClone = true;
                                    clone.userData.vy = 0.02 + Math.min(0.12, localUpdraft * 0.03);
                                    clone.userData.spreadSpeed = 0.008 + Math.random() * 0.02;
                                    clone.userData.maxRise = Math.max(3.0, (c.cloudTop || c.height || 0) + 4.0);
                                    // NEW: Add growth phase animation to clones
                                    clone.userData.growthPhase = 0;
                                    clone.userData.targetScale = clone.scale.clone();
                                    clone.scale.multiplyScalar(0.5);
                                    clone.material && (clone.material.opacity = Math.min(0.9, clone.material.opacity || 0.35));
                                    c.puffs.push(clone);
                                    c.grp.add(clone);
                                }
                                // reduce cooldown
                                if (p.userData._cloneCooldown > 0) p.userData._cloneCooldown--;
                            } catch (e) {}

                            // If this puff is an updraft clone, apply upward motion and then horizontal spreading
                            if (p.userData && p.userData.updraftClone) {
                                // rise
                                p.position.y += (p.userData.vy || 0);
                                // outward spreading increases with height (simulate umbrella spreading)
                                const riseProgress = Math.max(0, (p.position.y - (c.height || 0)) / Math.max(1, (p.userData.maxRise || (c.cloudTop || c.height || 0)) - (c.height || 0)));
                                const spreadAmt = (p.userData.spreadSpeed || 0.01) * (1 + riseProgress * 3);
                                p.position.x += (Math.random() - 0.5) * spreadAmt;
                                p.position.z += (Math.random() - 0.5) * spreadAmt;
                                // gently slow vertical velocity as it reaches spread altitude
                                if (p.position.y >= (p.userData.maxRise || (c.cloudTop || c.height || 0) + 4)) {
                                    p.userData.vy *= 0.48;
                                    // start fading once fully spread
                                    if (p.material) p.material.opacity *= 0.985;
                                }
                                // remove clone when fully faded or too high
                                if ((p.material && p.material.opacity <= 0.035) || p.position.y > (p.userData.maxRise || (c.cloudTop || c.height || 0) + 8)) {
                                    p.userData._remove = true;
                                }
                            }

                            // NEW: Cloud development animation - puffs grow in as they're created
                            if (p.userData && p.userData.growthPhase !== undefined) {
                                p.userData.growthPhase = Math.min(1, p.userData.growthPhase + 0.08);
                                const growthEase = p.userData.growthPhase * p.userData.growthPhase; // ease-in
                                if (p.userData.targetScale) {
                                    p.scale.copy(p.userData.targetScale).multiplyScalar(0.3 + growthEase * 0.7);
                                }
                            }

                            // IMPROVED: Dissipation effects - more gradual, nuanced fading
                            if (c.dying) {
                                const dd = p.userData && p.userData.dissipate ? p.userData.dissipate : 0.035;
                                if (p.material && typeof p.material.opacity === 'number') {
                                    p.material.opacity = Math.max(0, (p.material.opacity || 1) - dd * 0.85);
                                }
                                if (p.scale) {
                                    // slow scale decay rather than sharp drop (smoother dissipation)
                                    const scaleFade = Math.max(0.85, 1 - dd * 1.2);
                                    p.scale.multiplyScalar(scaleFade);
                                }
                                const fallVy = p.userData && p.userData.vy ? p.userData.vy : 0.004;
                                p.position.y = Math.max(0.6, p.position.y - fallVy * 7);
                            } else {
                                // Handle smooth fade-in/out controlled by userData.fade
                                if (p.userData && p.userData.fade && p.material) {
                                    try {
                                        const fd = p.userData.fade;
                                        const cur = p.material.opacity || 0;
                                        const tgt = fd.target;
                                        const dir = fd.state === 'in' ? 1 : -1;
                                        if (fd.state === 'in') {
                                            p.material.opacity = Math.min(tgt, cur + fd.speed);
                                            // once reached, lock to target to avoid oscillation
                                            if (p.material.opacity >= tgt * 0.99) {
                                                p.material.opacity = tgt;
                                                fd.state = 'steady';
                                            }
                                        } else if (fd.state === 'out') {
                                            p.material.opacity = Math.max(0, cur - fd.speed * 1.2);
                                            if (p.material.opacity <= 0.01) {
                                                // fully faded out - mark geometry for removal
                                                p.userData._remove = true;
                                            }
                                        }
                                    } catch(e) {}
                                }
                            }

                            if (p.userData && p.userData._remove) {
                                if (p.geometry) p.geometry.dispose();
                                if (p.material) p.material.dispose();
                                c.grp.remove(p);
                                c.puffs[i] = null;
                            }
                        }
                    });

                    if (c.dying && Math.random() < 0.07) {
                        const tinyCount = 1 + Math.floor(Math.random() * 2);
                        for (let tp = 0; tp < tinyCount; tp++) {
                            const a2 = Math.random() * Math.PI * 2;
                            const radial2 = (c.radius * 0.45) * (0.65 + Math.random() * 0.9);
                            const smallP = this.makePuff(
                                Math.cos(a2) * radial2,
                                c.cloudBase + (Math.random() * 1.8),
                                Math.sin(a2) * radial2,
                                0.7 + Math.random() * 1.4,
                                0.13 + Math.random() * 0.2,
                                Math.min(0.3, c.turbulence * 0.45)
                            );
                            if (smallP.material) smallP.material.opacity = 0.3 + Math.random() * 0.15;
                            c.puffs.push(smallP);
                            c.grp.add(smallP);
                        }
                    }
                    
                    if (c.dying && c.puffs[0] && c.puffs[0].material && c.puffs[0].material.opacity < 0.04) {
                        c.puffs.forEach(p => {
                            if (p) {
                                if (p.geometry) p.geometry.dispose();
                                if (p.material) p.material.dispose();
                            }
                        });
                        AppState.cloudSystem.group.remove(c.grp);
                        return false;
                    }
                    
                    return true;
                });
            }

            getMature() {
                // Treat supercell as highest-maturity source as well; only these produce sustained/heavy precipitation
                return this.clouds.filter(c => (c.stage === 'cumulonimbus' || c.stage === 'towering_cumulus' || c.stage === 'supercell') && !c.dying && c.mass > 3);
            }

            // New: return clouds that can source precipitation including dying ones (with weaker effect)
            getPrecipSources() {
                // Return any cloud that can source precipitation.
                // Strong sources: towering convection and above; weak sources: dissipating clouds still holding moisture.
                // We now provide a continuous list including dying clouds (weaker) so precipitation systems can sample them every frame.
                return this.clouds.filter(c => {
                    if (!c || !c.grp) return false;
                    // Include cumulus clouds for light precipitation, expand mature cloud definition
                    const stage = c.stage || 'cumulus';
                    const isConvective = (stage === 'cumulus' || stage === 'towering_cumulus' || stage === 'cumulonimbus' || stage === 'supercell');
                    const hasMass = c.mass > 0.5; // lower threshold for cumulus
                    const condensationOk = c.condensationLevel > 0.1 || c.age > 30; // allow young clouds
                    const notTooOld = c.age < c.maxAge * 0.95; // keep precipitating until near end
                    
                    return isConvective && hasMass && (condensationOk || !c.dying) && notTooOld;
                });
            }

            // New: Sample puff density near a world position (x, y, z)
            getPuffDensityAt(wx, wy, wz) {
                let densitySum = 0;
                let weightSum = 0;

                for (const c of this.clouds) {
                    if (!c || !c.grp) continue;
                    
                    // Check cloud bounding box quickly
                    const cloudRadius = c.radius * c.horizontalSpread;
                    if (Math.abs(wx - c.x) > cloudRadius * 1.5 || Math.abs(wz - c.z) > cloudRadius * 1.5) continue;
                    
                    for (const puff of c.puffs) {
                        if (!puff || !puff.userData || !puff.userData.density) continue;
                        
                        const puffPos = puff.position; // local to c.grp
                        const px = puffPos.x + c.x;
                        const py = puffPos.y;
                        const pz = puffPos.z + c.z;
                        
                        // Puff radius approximation based on scale/size
                        const size = (puff.scale.x + puff.scale.y + puff.scale.z) / 3 * 0.5;
                        
                        const distSq = (wx - px)**2 + (wy - py)**2 + (wz - pz)**2;
                        const effectiveRadiusSq = (size * 1.5)**2;

                        if (distSq < effectiveRadiusSq) {
                            const dist = Math.sqrt(distSq);
                            const influence = 1 - dist / (size * 1.5);
                            
                            densitySum += puff.userData.density * influence;
                            weightSum += influence;
                        }
                    }
                }
                
                return weightSum > 0.01 ? densitySum / weightSum : 0;
            }

            // NEW: Cloud variant system based on altitude and conditions
            determineCloudVariant(altitude, humidity, updraft, mass) {
                // CUMULONIMBUS VARIANTS (tall, low-forming)
                if (altitude > 16 && altitude < 36) {
                    if (mass > 8 && updraft > 1.2) return 'cumulonimbus_calvus'; // aggressive towering top
                    if (mass > 10) return 'cumulonimbus_capillatus'; // anvil-topped
                    if (mass > 6) return 'towering_cumulus';
                }
                
                // CUMULUS VARIANTS (low-forming, 2-8 km)
                if (altitude > 2 && altitude <= 16) {
                    if (mass < 1.5 && updraft < 0.3) return 'cumulus_humilis'; // small, fair-weather
                    if (mass < 3.5 && updraft < 0.7) return 'cumulus_mediocris'; // medium development
                    if (mass >= 3.5 && updraft >= 0.7) return 'cumulus_congestus'; // deep cumulus
                    return 'cumulus';
                }
                
                // ALTOCUMULUS VARIANTS (mid-level, 6-20 km)
                if (altitude > 8 && altitude < 20) {
                    if (humidity > 0.65 && updraft > 0.5) return 'altocumulus';
                    if (humidity > 0.55) return 'altocumulus_lenticularis'; // lens-shaped, orographic
                    return 'altocumulus_translucidus'; // thin, translucent
                }
                
                // CIRRUS VARIANTS (high altitude, >20 km)
                if (altitude >= 20) {
                    if (updraft > 0.3) return 'cirrus_fibratus'; // fibrous, dense streaks
                    if (humidity > 0.3) return 'cirrus_uncinus'; // hook-shaped fallstreaks
                    return 'cirrus'; // thin wispy
                }
                
                return 'cumulus';
            }

            // NEW: Cloud morphing system - gradual structural change
            updateCloudMorphing(cloud) {
                if (!cloud.morphState) {
                    cloud.morphState = { stage: 0, targetStage: 0, morphTimer: 0 };
                }
                const morphing = cloud.morphState;
                morphing.morphTimer++;
                
                // Every 200 updates, target a new morphing stage
                if (morphing.morphTimer > 200) {
                    morphing.morphTimer = 0;
                    morphing.targetStage = (morphing.targetStage + 1) % 3;
                }
                
                // Smoothly transition stage
                morphing.stage += (morphing.targetStage - morphing.stage) * 0.02;
                
                // Apply morphing effects to puff sizes/positions
                for (let i = 0; i < cloud.puffs.length; i++) {
                    const puff = cloud.puffs[i];
                    if (!puff || !puff.userData) continue;
                    
                    // Subtle scale oscillation during morphing
                    const morphInfluence = 0.5 + 0.5 * Math.sin(morphing.stage * Math.PI * 2);
                    const baseSizeMultiplier = 0.9 + morphInfluence * 0.2;
                    
                    if (puff.scale) {
                        puff.scale.multiplyScalar(Math.pow(baseSizeMultiplier, 0.02)); // slow scale change
                    }
                    
                    // Positional drift during morphing (subtle)
                    if (Math.random() < 0.1) {
                        puff.position.x += (Math.random() - 0.5) * morphing.morphTimer * 0.0001;
                        puff.position.z += (Math.random() - 0.5) * morphing.morphTimer * 0.0001;
                    }
                }
            }
        }

        class Precipitation {
            constructor(windFieldRef, cloudSystemRef) {
                this.windFieldRef = windFieldRef;
                this.cloudSystemRef = cloudSystemRef;

                // particle pool parameters (increased for heavier precipitation)
                this.max = 3500;
                this.drops = new Array(this.max).fill(null).map(()=>({ active: false }));
                this.pos = new Float32Array(this.max * 3);
                this.vel = new Array(this.max).fill(null).map(()=>({ y:0, vx:0, vz:0 }));
                this.size = new Float32Array(this.max);
                this.type = new Array(this.max).fill('rain');
                this.age = new Uint16Array(this.max);
                this.life = new Float32Array(this.max);
                this.quality = new Float32Array(this.max);

                // NEW: fluid dynamics properties per drop
                this.dragCoeff = new Float32Array(this.max); // aerodynamic drag (0.5 for sphere, varies by type)
                this.density = new Float32Array(this.max); // water density relative to size

                // shafts (cloud-local organized precipitation columns)
                // Rainshafts disabled in favor of denser drops and instanced splashes
                this.cloudShafts = new Map();
                this.enableShafts = false; // explicitly disable rainshaft meshes
                this.rainshaftGroup = new THREE.Group();
                AppState.scene.add(this.rainshaftGroup);

                // pooled geometry + material templates for instancing (kept for compatibility but unused unless re-enabled)
                this._shaftTemplates = {
                    coneGeo: new THREE.ConeBufferGeometry(1.0, 1.0, 10, 1, true),
                    ringGeo: new THREE.RingGeometry(0.6, 1.0, 12),
                    shaftMat: new THREE.MeshBasicMaterial({ color: 0x9fd8ff, transparent: true, opacity: 0.22, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending })
                };

                // REWORKED: Use line segments for rain streaks instead of point sprites with dots
                const streakGeometry = new THREE.BufferGeometry();
                const maxStreaks = 3000;
                const streakPositions = new Float32Array(maxStreaks * 6); // 2 points per streak
                streakGeometry.setAttribute('position', new THREE.BufferAttribute(streakPositions, 3));
                
                const streakMaterial = new THREE.LineBasicMaterial({
                    color: new THREE.Color(0xc8dff5),
                    transparent: true,
                    opacity: 0.85,
                    linewidth: 1.2,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                
                this.rainStreaks = new THREE.LineSegments(streakGeometry, streakMaterial);
                this.rainStreaks.frustumCulled = false;
                AppState.scene.add(this.rainStreaks);
                this.streakMax = maxStreaks;
                this.streakCount = 0;

                this.streakGeometry = new THREE.BufferGeometry();
                const arr = new Float32Array(this.streakMax * 6);
                this.streakGeometry.setAttribute('position', new THREE.BufferAttribute(arr, 3));
                this.streakLines = new THREE.LineSegments(this.streakGeometry, streakMaterial.clone());
                this.streakLines.frustumCulled = false;
                AppState.scene.add(this.streakLines);

                // visible rain points
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                geo.setAttribute('size', new THREE.BufferAttribute(this.size, 1));

                // Build an elongated streak texture (soft vertical streak)
                const canvas = document.createElement('canvas');
                // larger canvas to allow smooth anti-aliased streak with rounded ends
                canvas.width = 32;
                canvas.height = 256;
                const ctx = canvas.getContext('2d', { alpha: true });
                // ensure strokes/rendering use rounded caps to avoid square dot artifacts
                try { ctx.lineCap = 'round'; ctx.lineJoin = 'round'; } catch(e){}
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // draw a soft narrow rounded rectangle as base streak
                const streakW = canvas.width * 0.18;
                const x = (canvas.width - streakW) * 0.5;
                const y = 0;
                const h = canvas.height;
                const r = streakW * 0.6; // rounded ends

                ctx.save();
                // vertical gradient for smooth fade
                const grad = ctx.createLinearGradient(0, y, 0, y + h);
                grad.addColorStop(0.0, 'rgba(255,255,255,1.0)');
                grad.addColorStop(0.15, 'rgba(220,240,255,0.95)');
                grad.addColorStop(0.4, 'rgba(170,210,235,0.7)');
                grad.addColorStop(0.75, 'rgba(120,170,210,0.3)');
                grad.addColorStop(1.0, 'rgba(120,170,210,0.0)');
                ctx.fillStyle = grad;

                // rounded rect path
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + streakW - r, y);
                ctx.quadraticCurveTo(x + streakW, y, x + streakW, y + r);
                ctx.lineTo(x + streakW, y + h - r);
                ctx.quadraticCurveTo(x + streakW, y + h, x + streakW - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fill();

                // Add subtle longitudinal soft streaks (lighter blending) to imply shear without square artifacts
                ctx.globalCompositeOperation = 'lighter';
                for (let i = 0; i < 6; i++) {
                    const g = ctx.createLinearGradient(x - 2 + i * 2, 0, x + streakW + 2 + i * 2, canvas.height);
                    const alpha = 0.015 + Math.random() * 0.03;
                    g.addColorStop(0, `rgba(255,255,255,${alpha})`);
                    g.addColorStop(0.5, `rgba(255,255,255,${alpha * 0.6})`);
                    g.addColorStop(1, `rgba(255,255,255,0)`);
                    ctx.fillStyle = g;
                    ctx.fillRect(x - 6 + i * 1.8, 0, streakW + 12, canvas.height);
                }

                // gentle blur pass using shadow to soften edges (cheap approximation)
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255,255,255,0.02)';
                ctx.shadowColor = 'rgba(170,200,230,0.35)';
                ctx.shadowBlur = 6;
                ctx.fillRect(x, y, streakW, canvas.height);
                ctx.restore();

                const streakTex = new THREE.CanvasTexture(canvas);
                streakTex.format = THREE.RGBAFormat;
                streakTex.needsUpdate = true;

                // Use Points material but configured for elongated streak sprites with sizeAttenuation,
                // higher base opacity and additive blending for heavier, realistic streaks.
                this.material = new THREE.PointsMaterial({
                    size: 2.2,
                    map: streakTex,
                    transparent: true,
                    opacity: 0.92,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexColors: false,
                    sizeAttenuation: true,
                    alphaTest: 0.01
                });

                this.rain = new THREE.Points(geo, this.material);
                AppState.scene.add(this.rain);
                // Keep points visible as streak sprites; size will be modulated by drop size at runtime.

                // create a larger, more visible streak system and de-emphasize point sprites
                this.streakMax = 2000; // increased streak capacity for longer continuous streaks
                this.createStreakSystem();

                // microphysics tuning (adjusted for heavier precipitation)
                this.params = {
                    globalSlowFactor: 0.75,   // moderate slow-down but not too low (keeps heavy look)
                    coalesceProb: 0.015,      // higher chance to merge -> bigger drops
                    breakProb: 0.001,        // fragmentation of very large drops remains rare
                    splashParticles: 40,      // more splashes for heavier impacts
                    evaporationRate: 0.0006   // slight reduction so drops survive longer
                };
                // make the system more aggressive for realistic heavy precipitation visuals
                this.params.coalesceProb *= 1.9; // more coalescence -> larger drops
                this.params.splashParticles = Math.min(80, Math.floor(this.params.splashParticles * 1.6));
                this.params.evaporationRate *= 0.72; // slower evaporation yields heavier rain to ground

                // temporary working arrays for spawn loops
                this._spawnScratch = { idxList: [] };

                // pooled shaft mesh instances (reused across clouds)
                this._shaftPool = [];
            }

            createStreakSystem() {
                // allocate a larger line segments buffer for long rain streaks
                this.streakGeometry = new THREE.BufferGeometry();
                const arr = new Float32Array(this.streakMax * 6); // each streak uses two points (start/end)
                this.streakGeometry.setAttribute('position', new THREE.BufferAttribute(arr, 3));
                // Use a thin semi-transparent line for bulk streaks but pair with sprite streaks for volume
                this.streakMaterial = new THREE.LineBasicMaterial({
                    color: new THREE.Color(0x9fd8ff),
                    transparent: true,
                    opacity: 0.42,
                    linewidth: 1
                });
                this.streakLines = new THREE.LineSegments(this.streakGeometry, this.streakMaterial);
                this.streakLines.frustumCulled = false;
                AppState.scene.add(this.streakLines);
            }

            // NEW: Function to dynamically update shaft visuals
            _updateShaftVisuals(shaft, cloud, intensity, heightFactor, turbFactor) {
                // defensive removal: if cloud is missing or being removed, clear shaft immediately
                try {
                    if (!shaft || !shaft.userData) return;
                    if (!cloud || cloud.dying || !cloud.grp) {
                        // remove and dispose safely
                        try { this.rainshaftGroup.remove(shaft); } catch(e){}
                        try {
                            if (shaft.geometry) shaft.geometry.dispose();
                            if (shaft.material) shaft.material.dispose();
                        } catch (e) {}
                        // ensure map entry cleared if present
                        try { this.cloudShafts.delete(cloud); } catch(e){}
                        return;
                    }
                } catch (er) {
                    return;
                }

                if (!shaft.geometry || !shaft.material) return;

                const currentHeight = cloud.cloudTop || 18;
                const cloudBase = cloud.cloudBase || 8;
                
                // Adjust opacity based on intensity and cloud properties (stronger, faster lerp)
                const targetOpacity = Math.min(0.9, 0.16 + intensity * 0.45) * (cloud.dying ? 0.5 : 1.0);
                shaft.material.opacity += (targetOpacity - (shaft.material.opacity || 0)) * 0.24;
                
                // Animate points within the shaft (simulating falling motion)
                const posAttr = shaft.geometry.attributes.position;
                const pPos = posAttr.array;
                const count = shaft.userData.pcnt || Math.max(160, pPos.length / 3);
                const shaftRadius = (shaft.userData.shaftRadius || 8) * 1.35; // slightly expanded visual radius
                
                // simulate falling effect by moving points vertically and resetting them at top
                for (let pi = 0; pi < count; pi++) {
                    const idx = pi * 3;
                    let y = pPos[idx + 1];
                    // normalize position between ground (0) and cloud base (baseHeight)
                    const frac = (y - 0) / (currentHeight - 0); // Use full height for fraction
                    
                    // faster fall speed for higher intensity (stronger rain) and a stronger visual trail
                    const fallSpeed = 0.9 + Math.min(1.8, intensity * 0.6);
                    y -= fallSpeed * 0.06 * (0.8 + frac * 0.25);
                    
                    // wrap around to the top base
                    if (y < 0.8) {
                        y = currentHeight + 2 + (Math.random() * 4); // start meaningfully above cloud base for denser sheet
                        // re-randomize horizontal position with larger spread for fuller sheets
                        const angle = (pi * 2.37 + Math.random() * 1.2) % (Math.PI * 2);
                        const radius = (Math.random() * 1.1 + 0.2) * shaftRadius * (0.6 + 0.8 * (1 - Math.abs(0.5 - frac)));
                        pPos[idx] = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.06;
                        pPos[idx + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.06;
                    }
                    pPos[idx + 1] = y;
                }
                posAttr.needsUpdate = true;
                
                // Update container position (should follow cloud)
                shaft.position.x += (cloud.x - shaft.position.x) * 0.14;
                shaft.position.z += (cloud.z - shaft.position.z) * 0.14;
            }

            resize(newMax) {
                newMax = Math.max(200, Math.min(3000, Math.floor(newMax)));
                if (newMax === this.max) return;
                const oldMax = this.max;
                const oldPos = this.pos;
                const oldSize = this.size;
                const oldDrops = this.drops;
                const oldVel = this.vel;
                const oldType = this.type;
                const oldAge = this.age;
                const oldLife = this.life;
                const oldQual = this.quality;

                this.max = newMax;
                this.drops = new Array(this.max).fill(null).map(()=>({ active: false }));
                this.pos = new Float32Array(this.max * 3);
                this.size = new Float32Array(this.max);
                this.vel = new Array(this.max).fill(null).map(()=>({ y:0, vx:0, vz:0 }));
                this.type = new Array(this.max).fill('rain');
                this.age = new Uint16Array(this.max);
                this.life = new Float32Array(this.max);
                this.quality = new Float32Array(this.max);

                for (let i=0;i<this.max;i++) {
                    if (i < oldMax && oldDrops[i] && oldDrops[i].active) {
                        const idx = i * 3;
                        this.drops[i] = { active: true };
                        this.pos[idx] = oldPos[idx];
                        this.pos[idx+1] = oldPos[idx+1];
                        this.pos[idx+2] = oldPos[idx+2];
                        this.size[i] = oldSize[i];
                        this.vel[i] = oldVel[i] || { y:0, vx:0, vz:0 };
                        this.type[i] = oldType[i];
                        this.age[i] = oldAge[i];
                        this.life[i] = oldLife[i];
                        this.quality[i] = oldQual[i] || 1.0;
                    } else {
                        const idx = i * 3;
                        this.pos[idx] = 0; this.pos[idx+1] = -1000; this.pos[idx+2] = 0;
                        this.size[i] = 0;
                        this.age[i] = 0;
                        this.life[i] = 0;
                        this.quality[i] = 0;
                    }
                }

                this.rain.geometry.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                this.rain.geometry.setAttribute('size', new THREE.BufferAttribute(this.size, 1));
                this.rain.geometry.attributes.position.needsUpdate = true;
                this.rain.geometry.attributes.size.needsUpdate = true;
            }

            // helper: temperature-based type choice with microphysical bias
            determinePrecipType(altitude, localTempOverride=null) {
                const temp = this.getTemperature(altitude);
                const t = (localTempOverride !== null) ? localTempOverride : temp;
                if (t < -8) return 'snow';
                if (t < -2 && altitude > 14) return 'sleet';
                if (t < 1 && Math.random() < 0.18) return 'freezing_rain';
                return 'rain';
            }

            getTemperature(altitude) {
                // reuse earlier simple lapse in existing class
                const seaLevelTemp = 15 + (window.DayNight ? (window.DayNight.tempOffset || 0) : 0);
                const lapseRate = 6.5;
                return seaLevelTemp - (altitude / 1000) * lapseRate;
            }

            // spawn a single drop with microphysics-driven initial conditions based on cloud
            spawnDropFromCloud(cloud) {
                // Replace point-drop spawning with a volumetric rainfall sheet / shaft tied to the cloud.
                // If a shaft already exists for this cloud, update its intensity/position; otherwise create one.
                if (!cloud) return;
                try {
                    // compute a visually appropriate shaft footprint (match cloud radius / spread)
                    const footprint = Math.max(4.0, (cloud.radius || 6) * (cloud.horizontalSpread || 1.0) * (cloud.widthFactor || 1.0));
                    const shaftRadius = footprint * 1.2;
                    const shaftHeight = Math.max(6, (cloud.cloudTop || cloud.height || 18));
                    const intensity = Math.min(1.0, Math.max(0.06, (cloud.condensationLevel || 0.4) * Math.min(4, (cloud.mass || 1) / 4)));

                    let shaft = this.cloudShafts.get(cloud);
                    if (!shaft) {
                        // create grouped layered translucent shells to approximate a volumetric continuous sheet
                        shaft = new THREE.Group();
                        const segmentCount = 10;
                        for (let s = 0; s < segmentCount; s++) {
                            const t = s / Math.max(1, segmentCount - 1);
                            const segRadius = shaftRadius * (0.9 + (Math.sin(t * Math.PI) * 0.06));
                            const segHeight = shaftHeight * (0.9 + t * 0.3);
                            const geo = new THREE.CylinderGeometry(segRadius, segRadius * 0.85, Math.max(0.6, segHeight / segmentCount), 36, 1, true);
                            geo.translate(0, -segHeight * 0.5 + s * (segHeight / segmentCount), 0);
                            const mat = new THREE.MeshStandardMaterial({
                                color: new THREE.Color(0x92cfe8),
                                transparent: true,
                                opacity: 0.08 + intensity * 0.36 * (1 - t * 0.6),
                                depthWrite: false,
                                side: THREE.DoubleSide,
                                blending: THREE.AdditiveBlending,
                                roughness: 0.9,
                                metalness: 0.02
                            });
                            const mesh = new THREE.Mesh(geo, mat);
                            mesh.frustumCulled = false;
                            shaft.add(mesh);
                        }
                        shaft.userData.pcnt = Math.max(160, Math.floor(shaftRadius * 9));
                        shaft.userData.intensity = intensity;
                        shaft.position.set(cloud.x || 0, 0, cloud.z || 0);
                        shaft.frustumCulled = false;
                        this.rainshaftGroup.add(shaft);
                        this.cloudShafts.set(cloud, shaft);
                    } else {
                        // update existing shaft position and per-segment opacity to reflect new intensity
                        shaft.position.x = cloud.x;
                        shaft.position.z = cloud.z;
                        shaft.userData.intensity = intensity;
                        for (let i = 0; i < shaft.children.length; i++) {
                            const ch = shaft.children[i];
                            if (ch && ch.material) {
                                const t = i / Math.max(1, shaft.children.length - 1);
                                ch.material.opacity = Math.max(0.03, 0.08 + intensity * 0.36 * (1 - t * 0.6));
                            }
                        }
                    }
                } catch (err) {
                    // fallback: keep function safe ‚Äì silently ignore failures
                    console.warn('spawnDropFromCloud -> shaft spawn failed', err);
                }
            }

            // NEW: spawn actual precipitation particles into the particle pool from a cloud (visible drops/streaks)
            spawn(cloud) {
                if (!cloud) return;
                try {
                    // Find an inactive slot and seed a drop at a random position within the cloud footprint
                    const footprint = Math.max(3.0, (cloud.radius || 6) * (cloud.horizontalSpread || 1.0));
                    // attempt to spawn multiple drops per call for visible effect
                    const spawnCount = 2 + Math.floor(Math.min(6, (cloud.mass || 1) * 0.5));
                    for (let s = 0; s < spawnCount; s++) {
                        for (let i = 0; i < this.max; i++) {
                            if (!this.drops[i].active) {
                                const idx = i * 3;
                                // local sample within cloud footprint biased toward dense puffs
                                const angle = Math.random() * Math.PI * 2;
                                const radius = Math.random() * footprint * (0.3 + Math.random() * 0.9);
                                const x = cloud.x + Math.cos(angle) * radius + (Math.random()-0.5)*0.6;
                                const z = cloud.z + Math.sin(angle) * radius + (Math.random()-0.5)*0.6;
                                // Ensure drops are not visibly spawned inside dense puff geometry:
                                // sample puff density at candidate location and, if high, place the initial Y just below the cloud base
                                const sampleY = Math.max(1.0, (cloud.height || cloud.cloudTop || 18) - (Math.random() * Math.min(6, footprint * 0.12)));
                                let initialY = sampleY;
                                try {
                                    const puffDensity = (AppState.cloudSystem && typeof AppState.cloudSystem.getPuffDensityAt === 'function')
                                        ? AppState.cloudSystem.getPuffDensityAt(x, sampleY, z)
                                        : 0;
                                    // if the density indicates the point is inside or too close to puffs, start drops just below cloud base
                                    if (puffDensity > 0.12) {
                                        initialY = Math.max(0.9, (cloud.cloudBase || (cloud.baseHeight || 8)) - 0.6);
                                    }
                                } catch (e) {
                                    initialY = sampleY;
                                }
                                const y = initialY;
                                this.pos[idx] = x;
                                this.pos[idx + 1] = y;
                                this.pos[idx + 2] = z;
                                // initial vertical speed depends on drop size and cloud updraft
                                const baseSize = Math.min(1.8, 0.6 + (cloud.condensationLevel || 0.35) * 2.4 + Math.random() * 0.9);
                                this.size[i] = baseSize;
                                this.vel[i].y = 0.6 + Math.random() * 0.6 + (baseSize * 0.2);
                                this.vel[i].vx = (Math.random() - 0.5) * 0.08;
                                this.vel[i].vz = (Math.random() - 0.5) * 0.08;
                                this.type[i] = this.determinePrecipType(cloud.height || 12);
                                this.drops[i].active = true;
                                this.age[i] = 0;
                                this.life[i] = 1.0;
                                this.quality[i] = 1.0;
                                this.dragCoeff[i] = 0.47;
                                this.density[i] = 1.0;
                                break;
                            }
                        }
                    }
                    // Ensure geometry attribute updates are flagged so new drops are rendered immediately
                    if (this.rain && this.rain.geometry && this.rain.geometry.attributes.position) {
                        this.rain.geometry.attributes.position.needsUpdate = true;
                        if (this.rain.geometry.attributes.size) this.rain.geometry.attributes.size.needsUpdate = true;
                    }
                } catch (err) {
                    console.warn('Precipitation.spawn failed', err);
                }
            }

            // generate splash small particles on ground impact (visual only, lightweight)
            createSplash(x, z, normalVel) {
                const count = Math.min(this.params.splashParticles, 8 + Math.floor(Math.random()*20));
                const g = new THREE.BufferGeometry();
                const arr = new Float32Array(count*3);
                for (let i=0;i<count;i++) {
                    arr[i*3] = x + (Math.random()-0.5)*1.2;
                    arr[i*3+1] = 0.6 + Math.random()*1.4;
                    arr[i*3+2] = z + (Math.random()-0.5)*1.2;
                }
                g.setAttribute('position', new THREE.BufferAttribute(arr, 3));
                const mat = new THREE.PointsMaterial({ size: 0.18 + Math.random()*0.42, color: 0xcfe6ff, transparent: true, opacity: 0.95, depthWrite:false, blending: THREE.AdditiveBlending });
                const p = new THREE.Points(g, mat);
                p.userData = { life: 0.22 + Math.random()*0.36, vy: 0.12 + Math.abs(normalVel)*0.06 };
                AppState.scene.add(p);
                (this._splashPool = this._splashPool || []).push(p);

                // Removed expanding ring/shockwave for heavy impacts to reduce shockwave visuals.
            }

            // create a pooled instanced shaft mesh for a cloud (kept but only used if enableShafts true)
            _createInstancedShaftForCloud(cloud, intensity) {
                // Replace instanced cone/ring geometry with a solid vertical column of points
                // arranged along height and random-radius jitter to avoid ring banding artifacts.
                const pcnt = 160;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(pcnt * 3);

                const baseHeight = Math.max(1.2, (cloud.height || 12) - 0.3);
                // compute a shaft radius that matches the cloud precipitation footprint
                const shaftRadius = Math.max(3.6, (cloud.radius || 6) * (cloud.horizontalSpread || 1.0) * 1.12);

                // Fill positions as a continuous column (no perfectly circular rings)
                for (let pi = 0; pi < pcnt; pi++) {
                    const frac = pi / Math.max(1, pcnt - 1);
                    // spread vertically from near-ground up to cloud base/top fractionally
                    const y = baseHeight * (0.06 + frac * 0.94) + (Math.sin(pi * 0.21) * 0.02); // tiny vertical jitter
                    // use a non-uniform radial distribution with randomized angle to avoid visible ring seams
                    const angle = (pi * 2.37 + Math.random() * 0.8) % (Math.PI * 2);
                    const radius = (Math.random() * 0.9 + 0.1) * shaftRadius * (0.4 + 0.6 * (1 - Math.abs(0.5 - frac)));
                    // make geometry local: positions relative to shaft group origin (0,0,0)
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.02;
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.02;
                    pPos[pi * 3] = x;
                    pPos[pi * 3 + 1] = y;
                    pPos[pi * 3 + 2] = z;
                }

                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));

                // Use a soft points material (depthWrite=false prevents harsh z-fighting/ring artifacts)
                const baseCol = new THREE.Color(0x9fd8ff);
                const pMat = new THREE.PointsMaterial({
                    size: 0.28,
                    color: baseCol,
                    transparent: true,
                    opacity: Math.min(0.55, 0.12 + intensity * 0.45) * (cloud.dying ? 0.55 : 1.0),
                    depthWrite: false,
                    blending: THREE.NormalBlending,
                    sizeAttenuation: true
                });

                const points = new THREE.Points(pGeo, pMat);
                points.userData = {
                    cloudRef: cloud,
                    pcnt,
                    baseHeight,
                    shaftRadius,
                    // store that geometry is local-space and must be positioned at cloud center
                    local: true
                };
                // position the shaft group at cloud location so the local radius matches cloud footprint
                points.position.set(cloud.x || 0, 0, cloud.z || 0);
                // avoid frustum culling so shafts near camera update reliably
                points.frustumCulled = false;
                return points;
            }

            // Enhanced fluid dynamics for rain drops
            computeFluidDynamics(i, dt) {
                const idx = i * 3;
                const v = this.vel[i];
                const y = this.pos[idx + 1];
                const size = this.size[i];
                
                // Compute Reynolds number-like parameter for realistic drag
                const terminalVelRef = 0.3 + Math.sqrt(size) * 0.2; // reference terminal velocity
                const currentFallSpeed = Math.sqrt(v.y * v.y); // current fall speed
                
                // Fluid drag: dv/dt = -0.5 * rho_air * Cd * A * v^2 / m
                // Simplified: drag increases with relative velocity
                const dragMult = 1.0;
                const dragCoeff = this.dragCoeff[i] || 0.47; // sphere drag coefficient default
                const refArea = size * size; // cross-sectional area proportional to size^2
                const airDensity = Math.max(0.1, 1.225 * Math.exp(-y / 8.0)); // air density decreases with altitude
                
                // Compute drag acceleration based on fluid dynamics
                const dragAccel = (0.5 * airDensity * dragCoeff * refArea * (v.y * v.y)) / Math.max(0.1, size * size); // normalize by mass
                v.y = Math.max(0.04, v.y - dragAccel * dt * 0.02); // apply drag, maintain minimum fall speed
                
                // Wind resistance (horizontal drag)
                const windDrag = 0.98 * (1 - dragAccel * 0.0001); // wind also experiences drag
                v.vx *= windDrag;
                v.vz *= windDrag;
                
                // Pressure gradient forces from wind field (local acceleration)
                const w = this.windFieldRef.getAt(this.pos[idx], y, this.pos[idx+2]);
                const pressureGradient = 0.15; // sensitivity to pressure gradients
                v.vx += (w.x || 0) * pressureGradient * (1.0 / (1 + size)); // smaller drops respond more to wind
                v.vz += (w.z || 0) * pressureGradient * (1.0 / (1 + size));
                
                // Coriolis-like effect (slight deflection based on velocity & altitude)
                const coriolisFactor = 0.0001 * Math.max(0, (12 - y) / 12); // stronger at low altitude
                const temp = v.vx;
                v.vx += v.vz * coriolisFactor;
                v.vz -= temp * coriolisFactor;
                
                // Gravity (always present)
                v.y += 0.15 * dt; // gravity acceleration (9.81 m/s^2 scaled)
            }

            // called each frame
            update() {
                // gather precipitation sources
                const sources = (this.cloudSystemRef.getPrecipSources ? this.cloudSystemRef.getPrecipSources() : this.cloudSystemRef.getMature()) || [];

                // cleanup obsolete shafts
                for (const [cloud, shaftObj] of this.cloudShafts) {
                    const shouldRemove = (!cloud) || (cloud.dying === true) || (cloud.grp == null && (cloud.age || 0) > 20);
                    if (shouldRemove) {
                        if (shaftObj) {
                            try { this.rainshaftGroup.remove(shaftObj.mesh || shaftObj); } catch(e) {}
                            if (shaftObj.mesh) {
                                shaftObj.mesh.geometry.dispose();
                                if (shaftObj.mesh.material) shaftObj.mesh.material.dispose();
                            } else if (shaftObj.geometry) {
                                shaftObj.geometry.dispose();
                                if (shaftObj.material) shaftObj.material.dispose();
                            }
                        }
                        this.cloudShafts.delete(cloud);
                    }
                }

                // Create organized precipitation bands (mesoscale features)
                if (!this._precipBands) this._precipBands = [];
                this._precipBands = this._precipBands.filter(band => {
                    band.age++;
                    // Bands move and influence local spawn rates
                    band.x += band.vx;
                    band.z += band.vz;
                    return band.age < band.maxAge;
                });
                if (sources.length > 2 && Math.random() < 0.002) {
                    const avgC = sources[Math.floor(sources.length / 2)];
                    this._precipBands.push({
                        x: avgC.x, z: avgC.z, vx: 0.28, vz: 0.06,
                        radius: 35 + Math.random() * 40, strength: 1.2 + Math.random() * 1.8,
                        age: 0, maxAge: 800 + Math.random() * 600
                    });
                }

                // spawn continuous precipitation with band enhancement
                for (let ci = 0; ci < sources.length; ci++) {
                    const c = sources[ci];
                    if (!c) continue;

                    // NEW: Wind shear influence on precipitation tilt & organization
                    const shearMag = AppState.windShearSystem ? AppState.windShearSystem.computeShear(c.x, c.z) : 0;
                    if (AppState.windShearSystem) AppState.windShearSystem.applyShearToCloud(c, shearMag);

                    // compute intensity factors
                    const heightFactor = Math.max(0.85, 1 + ((c.height||12) - 12) * 0.045);
                    const maturityFactor = Math.min(2.8, 0.6 + (c.condensationLevel || 0.2) * 2.1);
                    let stageFactor = 0.4;
                    if (c.stage === 'towering_cumulus') stageFactor = 1.05;
                    else if (c.stage === 'cumulonimbus') stageFactor = 1.55;
                    else if (c.stage === 'supercell') stageFactor = 2.4;
                    
                    // NEW: CAPE boost (stronger updrafts in unstable atmosphere)
                    const cape = AppState.atmosphericLayers ? AppState.atmosphericLayers.computeCALE(c.cloudBase || 8, c.height) : 0;
                    const capeBoost = Math.min(1.5, 0.8 + (cape / 1500));
                    
                    const dyingFactor = c.dying ? 0.26 : 1.0;
                    const turbFactor = 1 + (c.turbulence || 0) * 0.9;
                    // apply global rain intensity multiplier from UI
                    let intensity = Math.max(0, Math.min(8.0, ((c.mass || 0) / 5) * maturityFactor * heightFactor * stageFactor * dyingFactor * turbFactor * capeBoost * 1.1 * (Graphics.rainIntensity || 1)));

                    // NEW FIX: Dampen intensity if visual size proxy is small, despite high mass/LWC.
                    const minRadiusForHeavy = 8.0;
                    const minSpreadForHeavy = 1.5;
                    let visualSizeScale = Math.min(1.0, (c.radius || 4) / minRadiusForHeavy); 
                    visualSizeScale *= Math.min(1.0, (c.horizontalSpread || 1.0) / minSpreadForHeavy);

                    intensity *= Math.max(0.2, visualSizeScale); // Apply dampening, minimum 0.2 factor to prevent total shutdown

                    // enhance intensity if cloud is in a precipitation band
                    for (const band of this._precipBands) {
                        const dist = Math.hypot(c.x - band.x, c.z - band.z);
                        if (dist < band.radius) {
                            const boost = band.strength * (1 - dist / band.radius) * 1.3;
                            intensity = Math.min(5.2, intensity + boost);
                        }
                    }

                    // spawn drops scaled by intensity (increased rates for heavy systems)
                    const areaFactor = Math.max(0.6, ((c.radius||4) * (c.horizontalSpread||1))/5);
                    const spawnBase = Math.floor(Math.min(180, Math.max(2, intensity * 42 * areaFactor)));
                    const spawnMultiplier = c.dying ? (0.22 + Math.random()*0.32) : (0.75 + Math.random()*0.85);
                    const toSpawn = Math.max(1, Math.floor(spawnBase * spawnMultiplier));
                    for (let s=0; s<toSpawn; s++) {
                        // ensure drops are seeded from dense puff regions to avoid rain falling from visually thin pockets
                        try {
                            const sampleX = c.x + (Math.random()-0.5) * c.radius * (c.horizontalSpread || 1.0);
                            const sampleZ = c.z + (Math.random()-0.5) * c.radius * (c.horizontalSpread || 1.0);
                            const sampleY = Math.max(1, (c.height || 18) - 0.6);
                            const density = AppState.cloudSystem && typeof AppState.cloudSystem.getPuffDensityAt === 'function' ? AppState.cloudSystem.getPuffDensityAt(sampleX, sampleY, sampleZ) : 0.5;
                            // require a minimum local puff density or reduce spawn chance strongly
                            if (density > 0.08 || Math.random() < Math.min(0.22, density + 0.06)) {
                                // spawn actual precipitation particles (drops/streaks) instead of only creating shafts
                                this.spawn(c);
                            }
                        } catch (e) {
                            this.spawn(c);
                        }
                    }

                    // --- Downfall Sheet System Implementation ---
                    // Use this.enableShafts (Graphics.rainshafts) to control visibility
                    if (this.enableShafts && intensity > 0.6) { // lower threshold so moderate precipitation shows sheets
                        let shaft = this.cloudShafts.get(c);
                        if (!shaft) {
                            // compute shaft radius to match cloud precipitation footprint
                            const computedRadius = Math.max(4.0, (c.radius || 6) * (c.horizontalSpread || 1.0) * 1.12);
                            shaft = this._createInstancedShaftForCloud(c, intensity);
                            // update shaft userData to explicit computed radius for consistent updates
                            if (shaft && shaft.userData) {
                                shaft.userData.shaftRadius = computedRadius;
                                // set particle count scaling to radius so visual density matches area
                                shaft.userData.pcnt = Math.max(120, Math.floor(computedRadius * 8));
                            }
                            this.rainshaftGroup.add(shaft);
                            this.cloudShafts.set(c, shaft);
                        }
                        // Update existing shaft visual parameters based on current intensity and computed radius
                        this._updateShaftVisuals(shaft, c, intensity, heightFactor, turbFactor);
                    } else if (this.cloudShafts.has(c)) {
                        // Fade out shaft if intensity drops or shafts are disabled
                        const shaft = this.cloudShafts.get(c);
                        if (shaft && shaft.material) shaft.material.opacity = Math.max(0, shaft.material.opacity * 0.9);
                        // for grouped shafts, iterate children materials if present
                        if (shaft && shaft.children && shaft.children.length) {
                            shaft.children.forEach(child => { if (child.material) child.material.opacity = Math.max(0, (child.material.opacity || 0) * 0.9); });
                        }
                        if (shaft && shaft.children && shaft.children.length && shaft.children.every(ch => ch.material && ch.material.opacity < 0.01)) {
                            this.rainshaftGroup.remove(shaft);
                            this.cloudShafts.delete(c);
                            if (shaft.geometry) shaft.geometry.dispose();
                            if (shaft.material) shaft.material.dispose();
                        }
                    }
                }

                // Advanced microphysics interactions (increased iteration count for complex dynamics)
                for (let iter=0; iter<Math.min(320, Math.floor(this.max*0.04)); iter++) {
                    const a = Math.floor(Math.random()*this.max);
                    if (!this.drops[a].active) continue;

                    // Size-dependent collision: larger drops collide more readily
                    const kernelScale = Math.pow(this.size[a], 1.2) * 0.08;
                    
                    if (Math.random() < (this.params.coalesceProb * kernelScale)) {
                        const b = Math.floor(Math.random()*this.max);
                        if (a === b || !this.drops[b].active) continue;
                        const ax = this.pos[a*3], ay = this.pos[a*3+1], az = this.pos[a*3+2];
                        const bx = this.pos[b*3], by = this.pos[b*3+1], bz = this.pos[b*3+2];
                        const dd = (ax-bx)*(ax-bx)+(ay-by)*(ay-by)+(az-bz)*(az-bz);
                        const collisionRadius = Math.max(0.4, (this.size[a] + this.size[b]) * 0.6);
                        
                        if (dd < collisionRadius * collisionRadius) {
                            // conservative volume merger with growth
                            const vol_a = Math.pow(this.size[a], 3);
                            const vol_b = Math.pow(this.size[b], 3);
                            const newSize = Math.cbrt(vol_a + vol_b) * 1.12;
                            this.size[a] = Math.min(6.0, newSize);
                            // velocity update weighted by mass (size cubed)
                            const wA = vol_a / (vol_a + vol_b + 0.0001);
                            this.vel[a].y = this.vel[a].y * wA + this.vel[b].y * (1 - wA);
                            this.vel[a].vx = this.vel[a].vx * wA + this.vel[b].vx * (1 - wA);
                            this.vel[a].vz = this.vel[a].vz * wA + this.vel[b].vz * (1 - wA);
                            // quality averages with small loss (edge dissipation)
                            this.quality[a] = Math.max(0.35, (this.quality[a]*wA + this.quality[b]*(1-wA)) * 0.94);
                            this.drops[b].active = false;
                            this.pos[b*3+1] = -1000;
                        }
                    }

                    // Enhanced warm-rain process: rapid coalescence in warm clouds with high-lwc
                    if (this.getTemperature(this.pos[a*3+1]) > 10 && this.size[a] > 1.4 && Math.random() < 0.012) {
                        const b = Math.floor(Math.random()*this.max);
                        if (a !== b && this.drops[b].active) {
                            const ax = this.pos[a*3], ay = this.pos[a*3+1], az = this.pos[a*3+2];
                            const bx = this.pos[b*3], by = this.pos[b*3+1], bz = this.pos[b*3+2];
                            const dd = (ax-bx)*(ax-bx)+(ay-by)*(ay-by)+(az-bz)*(az-bz);
                            if (dd < 0.3) {
                                const newSize = Math.min(5.0, this.size[a] * 1.22 + this.size[b] * 0.8);
                                this.size[a] = newSize;
                                this.drops[b].active = false;
                                this.pos[b*3+1] = -1000;
                            }
                        }
                    }

                    // ENHANCED: Bergeron process (ice-crystal growth at expense of water)
                    if ((this.type[a] === 'snow' || this.type[a] === 'sleet') && this.getTemperature(this.pos[a*3+1]) < -8 && Math.random() < 0.008) {
                        const b = Math.floor(Math.random()*this.max);
                        if (a !== b && this.drops[b].active && (this.type[b] === 'rain' || this.type[b] === 'sleet')) {
                            const ax = this.pos[a*3], ay = this.pos[a*3+1], az = this.pos[a*3+2];
                            const bx = this.pos[b*3], by = this.pos[b*3+1], bz = this.pos[b*3+2];
                            const dd = (ax-bx)*(ax-bx)+(ay-by)*(ay-by)+(az-bz)*(az-bz);
                            if (dd < 0.7) {
                                // ice grows, water droplet shrinks significantly
                                const iceGrowth = this.size[b] * 0.55;
                                this.size[a] = Math.min(4.5, this.size[a] + iceGrowth);
                                this.size[b] *= 0.35;
                                this.quality[a] = Math.min(2.0, this.quality[a] + this.quality[b] * 0.6);
                                // type promotion
                                if (this.size[a] > 2.8) this.type[a] = 'hail';
                            }
                        }
                    }

                    // ENHANCED: Ice-crystal aggregation at higher frequency
                    if ((this.type[a] === 'snow' || this.type[a] === 'graupel') && this.getTemperature(this.pos[a*3+1]) < -12 && Math.random() < 0.01) {
                        const b = Math.floor(Math.random()*this.max);
                        if (a !== b && this.drops[b].active && (this.type[b] === 'snow' || this.type[b] === 'graupel')) {
                            const ax = this.pos[a*3], ay = this.pos[a*3+1], az = this.pos[a*3+2];
                            const bx = this.pos[b*3], by = this.pos[b*3+1], bz = this.pos[b*3+2];
                            const dd = (ax-bx)*(ax-bx)+(ay-by)*(ay-by)+(az-bz)*(az-bz);
                            if (dd < 0.8) {
                                // aggregate: size grows as cubic-root sum, density increases
                                const aggSize = Math.cbrt(Math.pow(this.size[a],3) + Math.pow(this.size[b],3)) * 1.08;
                                this.size[a] = Math.min(4.2, aggSize);
                                this.quality[a] = Math.min(2.2, this.quality[a] * 1.2 + this.quality[b] * 0.5);
                                this.drops[b].active = false;
                                this.pos[b*3+1] = -1000;
                            }
                        }
                    }
                }

                // virga: rain that evaporates before reaching ground in dry layers
                // We now flag virga drops and force them to fade out above ground, spawn light vapor from evaporation,
                // and prevent ground splashes for these drops.
                const virgaChecks = Math.max(8, Math.floor(this.max * 0.006));
                for (let vi = 0; vi < virgaChecks; vi++) {
                    const i = Math.floor(Math.random() * this.max);
                    if (!this.drops[i].active) continue;
                    const y = this.pos[i*3+1];
                    const wx = this.pos[i*3], wz = this.pos[i*3+2];
                    const env = sampleEnvironment(wx, wz, y);
                    // virga forms in dry air (humidity < ~40%) and moderately high altitudes where evaporation outpaces fall
                    if (env.humidity < 0.40 && y > 2.6 && y < 14 && this.size[i] < 1.6) {
                        // mark as virga so downstream logic treats it specially
                        this.drops[i].virga = true;
                        // accelerate evaporation / visual fade for virga
                        const evapFactor = 0.42 + Math.random() * 0.32;
                        this.size[i] *= 0.96 + evapFactor * 0.03; // reduced size decay for softer fade
                        this.life[i] *= 0.94; // slightly slower life decay
                        // spawn a subtle evaporation plume at that location (if evaporation system exists)
                        try {
                            if (AppState.evaporationSystem && typeof AppState.evaporationSystem.spawnEvaporation === 'function') {
                                // spawn only occasionally to avoid spam
                                if (Math.random() < 0.24) AppState.evaporationSystem.spawnEvaporation(wx, wz);
                            }
                        } catch (e) {}
                        // when small enough, remove without producing splash
                        if (this.size[i] < 0.10 || this.life[i] < 0.08) {
                            this.drops[i].active = false;
                            this.pos[i*3+1] = -1000;
                        }
                    }
                }

                // movement, advection, wind response, environment coupling with FLUID DYNAMICS
                let activeCount = 0;
                let streakIdx = 0;
                const streakPos = this.streakGeometry.attributes.position.array;
                const dt = 0.016; // approximate per-frame dt

                for (let i=0;i<this.max;i++) {
                    if (!this.drops[i].active) continue;
                    const idx = i*3;
                    let y = this.pos[idx+1];
                    const w = this.windFieldRef.getAt(this.pos[idx], y, this.pos[idx+2]) || { x:0, z:0 };

                    // FLUID DYNAMICS: Apply realistic aerodynamic forces
                    this.computeFluidDynamics(i, dt);

                    // New: drag & aerodynamics by type & size with fluid model
                    let dragMult = 1.0;
                    if (this.type[i] === 'snow') dragMult = 3.4;
                    else if (this.type[i] === 'sleet') dragMult = 2.0;
                    else if (this.type[i] === 'freezing_rain') dragMult = 0.92;
                    else dragMult = 1.1;

                    const windInfluence = dragMult * (1.0 / (this.size[i] + 0.08));
                    this.pos[idx] += (w.x * windInfluence) * 1.0 + this.vel[i].vx * 0.36;
                    this.pos[idx+2] += (w.z * windInfluence) * 1.0 + this.vel[i].vz * 0.36;
                    this.pos[idx+1] -= this.vel[i].y;

                    const updraft = (AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(this.pos[idx], this.pos[idx+2]) : 0);
                    const windCell = this.windFieldRef.getAt(this.pos[idx], y, this.pos[idx+2]);
                    const downburstSig = windCell && windCell.__downburst ? windCell.__downburst : 0;
                    const vortexSig = windCell && windCell.__vortex ? windCell.__vortex : 0;
                    if (updraft > 0.02) {
                        this.pos[idx+1] += updraft * (0.04 / (0.5 + this.size[i])) * (0.9 + Math.random()*0.8);
                    }
                    // NEW VIRGA LIFT: If virga, apply buoyant lift as it evaporates
                    if (this.drops[i].virga) {
                        const buoyancy = 0.005 + (1.0 - this.life[i]) * 0.012; // lift increases as it vanishes
                        this.pos[idx+1] += buoyancy * (1 + (w.y||0));
                        this.vel[i].y *= 0.85; // damp gravity
                        // make horizontal movement more turbulent
                        this.vel[i].vx += (Math.random() - 0.5) * 0.008;
                        this.vel[i].vz += (Math.random() - 0.5) * 0.008;
                    }
                    if (downburstSig > 0.002) {
                        this.vel[i].y *= (1 + downburstSig * 0.28);
                    }
                    if (Math.abs(vortexSig) > 0.002) {
                        const angle = Math.atan2(this.pos[idx+2], this.pos[idx]);
                        this.vel[i].vx += Math.sin(angle + Math.PI/2) * Math.abs(vortexSig) * 0.12;
                        this.vel[i].vz += Math.cos(angle + Math.PI/2) * Math.abs(vortexSig) * 0.12;
                    }

                    const env = sampleEnvironment(this.pos[idx], this.pos[idx+2], y);
                    const tempFactor = 1 - Math.min(1, Math.max(-5, this.getTemperature(y) + 15) / 35);
                    const humidityFactor = Math.max(0, env.humidity - 0.7);
                    const evap = this.params.evaporationRate * tempFactor * (1 - humidityFactor * 0.8) * (1.2 - Math.min(1.8, this.quality[i] || 1.0)) * (1 + (this.size[i] < 0.6 ? 1.3 : 0));
                    this.size[i] -= evap;
                    if (this.size[i] <= 0.08) {
                        this.drops[i].active = false;
                        this.pos[idx+1] = -1000;
                        continue;
                    }

                    const currentTemp = this.getTemperature(y);
                    if (this.type[i] === 'snow' && currentTemp > 2.8 && y < 6) {
                        this.type[i] = 'rain';
                        this.vel[i].y = Math.max(0.24, this.vel[i].y * 0.70) * this.params.globalSlowFactor;
                    } else if (this.type[i] === 'sleet' && currentTemp > 4 && y < 8) {
                        this.type[i] = 'rain';
                        this.vel[i].y = Math.max(0.20, this.vel[i].y * 0.68) * this.params.globalSlowFactor;
                    }

                    // REWORKED: Use line segments for rain streaks (no dots)
                    if (streakIdx < this.streakMax && this.vel[i].y > 0.72 && this.type[i] === 'rain' && this.size[i] > 0.45 && Math.random() < 0.50 && !this.drops[i].virga) {
                        const trailLen = Math.min(12, 3 + Math.floor(this.size[i] * 1.8 + this.vel[i].y * 6));
                        const si = streakIdx * 6;
                        // start at drop position
                        streakPos[si]   = this.pos[idx];
                        streakPos[si+1] = y;
                        streakPos[si+2] = this.pos[idx+2];
                        // draw true downward streak: end point below the drop (short, smoother streak)
                        streakPos[si+3] = this.pos[idx];
                        streakPos[si+4] = this.pos[idx+1] - Math.min(12, trailLen + this.vel[i].y * 6) * 0.45;
                        streakPos[si+5] = this.pos[idx+2];
                        streakIdx++;
                    }

                    // ground collision & splashes
                    if (this.pos[idx+1] < 0.6 || this.age[i] > 2000) {
                        // If this drop was flagged as virga, never produce ground splashes and simply remove quietly.
                        if (!this.drops[i].virga) {
                            if (this.size[i] > 0.6 && Math.random() < Math.min(0.98, this.size[i]*0.45)) {
                                // stronger splash for larger drops and higher fall speed
                                this.createSplash(this.pos[idx], this.pos[idx+2], this.vel[i].y);
                            }
                        } else {
                            // optional light evaporation puff on final fade for virga (very rare)
                            try {
                                if (AppState.evaporationSystem && Math.random() < 0.12) {
                                    AppState.evaporationSystem.spawnEvaporation(this.pos[idx], this.pos[idx+2]);
                                }
                            } catch(e) {}
                        }
                        this.drops[i].active = false;
                        this.pos[idx] = 0; this.pos[idx+1] = -1000; this.pos[idx+2] = 0;
                        this.size[i] = 0;
                        continue;
                    }

                    this.age[i]++;
                    this.life[i] = Math.max(0, 1 - this.age[i]/2200);

                    activeCount++;
                }

                // clear unused streak slots
                for (let k = streakIdx*6; k < this.streakMax*6; k++) streakPos[k] = 0;
                this.streakGeometry.attributes.position.needsUpdate = true;

                // animate & cleanup splash particles
                if (this._splashPool && this._splashPool.length) {
                    for (let i = this._splashPool.length - 1; i >= 0; i--) {
                        const p = this._splashPool[i];
                        if (!p) { this._splashPool.splice(i,1); continue; }
                        p.userData.life -= 0.015;
                        p.material.opacity = Math.max(0, p.material.opacity - 0.035);
                        const posAttr = p.geometry.attributes.position;
                        const arr = posAttr.array;
                        for (let j=0;j<arr.length;j+=3) {
                            arr[j+1] += (p.userData.vy || 0) * 0.24;
                            arr[j] += (Math.random()-0.5)*0.04;
                            arr[j+2] += (Math.random()-0.5)*0.04;
                        }
                        p.geometry.attributes.position.needsUpdate = true;
                        if (p.userData.life <= 0) {
                            AppState.scene.remove(p);
                            if (p.geometry) p.geometry.dispose();
                            if (p.material) p.material.dispose();
                            this._splashPool.splice(i,1);
                        }
                    }
                }

                // animate splash rings
                if (this._splashRings && this._splashRings.length) {
                    for (let i = this._splashRings.length - 1; i >= 0; i--) {
                        const r = this._splashRings[i];
                        r.userData.life -= 0.012 + Math.random()*0.02;
                        const prog = 1 - Math.max(0, r.userData.life || 0);
                        const s = 1 + prog * (r.userData.maxScale || 1.0) * 2.6;
                        r.scale.set(s, s, s);
                        if (r.material) r.material.opacity = Math.max(0, (0.65 * (1 - prog)));
                        if (r.userData.life <= 0) {
                            AppState.scene.remove(r);
                            if (r.geometry) r.geometry.dispose();
                            if (r.material) r.material.dispose();
                            this._splashRings.splice(i,1);
                        }
                    }
                }

                this.rain.geometry.attributes.position.needsUpdate = true;
                this.rain.geometry.attributes.size.needsUpdate = true;
                this.streakGeometry.attributes.position.needsUpdate = true;

                return activeCount;
            }
        }

        // Fallback/patch: ensure Precipitation has _createInstancedShaftForCloud method at runtime
        if (typeof Precipitation !== 'undefined' && !Precipitation.prototype._createInstancedShaftForCloud) {
            Precipitation.prototype._createInstancedShaftForCloud = function(cloud, intensity) {
                // Lightweight soft-point shaft to avoid missing function errors and visual ring artifacts
                const pcnt = 120;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(pcnt * 3);

                const baseHeight = Math.max(1.2, (cloud.height || 12) - 0.3);
                const shaftRadius = Math.max(3.6, (cloud.radius || 6) * (cloud.horizontalSpread || 1.0) * 1.12);

                for (let pi = 0; pi < pcnt; pi++) {
                    const frac = pi / Math.max(1, pcnt - 1);
                    const y = baseHeight * (0.06 + frac * 0.94) + (Math.sin(pi * 0.21) * 0.02);
                    const angle = (pi * 2.37 + Math.random() * 0.8) % (Math.PI * 2);
                    const radius = (Math.random() * 0.9 + 0.1) * shaftRadius * (0.4 + 0.6 * (1 - Math.abs(0.5 - frac)));
                    // local coordinates so group.position aligns with cloud center
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.02;
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.02;
                    pPos[pi * 3] = x;
                    pPos[pi * 3 + 1] = y;
                    pPos[pi * 3 + 2] = z;
                }

                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const pMat = new THREE.PointsMaterial({
                    size: 0.28,
                    color: new THREE.Color(0x9fd8ff),
                    transparent: true,
                    opacity: Math.min(0.55, 0.12 + intensity * 0.45) * (cloud.dying ? 0.55 : 1.0),
                    depthWrite: false,
                    blending: THREE.NormalBlending,
                    sizeAttenuation: true
                });

                const points = new THREE.Points(pGeo, pMat);
                points.userData = { cloudRef: cloud, pcnt, baseHeight, shaftRadius, seed: Math.random() * 1000 };
                points.position.set(cloud.x || 0, 0, cloud.z || 0);
                points.frustumCulled = false;
                return points;
            };
        }

        class Lightning {
            constructor(cloudSystemRef) {
                this.cloudSystemRef = cloudSystemRef;
                this.bolts = [];
                this.charge = 0;
                // Raise threshold and make accumulation slower so strikes are less frequent
                this.threshold = 200;
                this.last = 0;
                this.count = 0;
                this.flash = new THREE.PointLight(0xeef5ff, 0, 300); // increased range
                AppState.scene.add(this.flash);
                this.enabled = true;
                // store per-cloud charge reservoirs
                this._cloudCharge = new WeakMap();
                this.ambientFlash = null; // scene-wide brief bright flash for dramatic effect
            }

            createSteppedLeader(sx, sy, sz, ex, ey, ez) {
                const segments = 35 + Math.floor(Math.random() * 15); // more segments for detail
                let currentX = sx, currentY = sy, currentZ = sz;
                const path = [];
                
                for (let i = 0; i < segments; i++) {
                    const t = i / segments;
                    const targetX = sx + (ex - sx) * t;
                    const targetY = sy + (ey - sy) * t - Math.pow(t, 1.4) * 8; // deeper sag
                    const targetZ = sz + (ez - sz) * t;
                    
                    const stepSize = 2.5 + Math.random() * 3.5;
                    const chaos = (1 - Math.abs(t - 0.5) * 2) * 8;
                    
                    currentX += (targetX - currentX) * 0.25 + (Math.random() - 0.5) * chaos;
                    currentY += (targetY - currentY) * 0.25 + (Math.random() - 0.5) * stepSize;
                    currentZ += (targetZ - currentZ) * 0.25 + (Math.random() - 0.5) * chaos;
                    
                    path.push(new THREE.Vector3(currentX, currentY, currentZ));
                }
                
                return path;
            }

            createBranch(originPoint, depth = 0, maxDepth = 3) {
                if (depth >= maxDepth || Math.random() > 0.7) return;
                
                const branches = 1 + Math.floor(Math.random() * 2);
                
                for (let b = 0; b < branches; b++) {
                    const branchLength = 8 + Math.random() * 12 * (1 - depth / maxDepth);
                    const branchSteps = 6 + Math.floor(Math.random() * 6);
                    const branchPoints = [];
                    
                    let bx = originPoint.x;
                    let by = originPoint.y;
                    let bz = originPoint.z;
                    
                    const angleH = Math.random() * Math.PI * 2;
                    const angleV = (Math.random() - 0.3) * Math.PI * 0.5;
                    
                    for (let i = 0; i <= branchSteps; i++) {
                        const t = i / branchSteps;
                        const len = branchLength * t;
                        
                        bx += Math.cos(angleH) * Math.cos(angleV) * (branchLength / branchSteps) + (Math.random() - 0.5) * 2;
                        by -= Math.sin(angleV) * (branchLength / branchSteps) + Math.random() * 1.5;
                        bz += Math.sin(angleH) * Math.cos(angleV) * (branchLength / branchSteps) + (Math.random() - 0.5) * 2;
                        
                        branchPoints.push(new THREE.Vector3(bx, by, bz));
                    }
                    
                    const opacity = 0.7 - depth * 0.15;
                    const branchGeom = new THREE.BufferGeometry().setFromPoints(branchPoints);
                    const branchMat = new THREE.LineBasicMaterial({
                        color: 0xccddff,
                        transparent: true,
                        opacity: opacity,
                        linewidth: 2
                    });
                    
                    const branch = new THREE.Line(branchGeom, branchMat);
                    branch.userData.life = 0.9 - depth * 0.1;
                    AppState.scene.add(branch);
                    this.bolts.push(branch);
                    
                    // Recursive branching
                    if (Math.random() > 0.5) {
                        this.createBranch(branchPoints[Math.floor(branchPoints.length / 2)], depth + 1, maxDepth);
                    }
                }
            }

            makeBolt(sx, sy, sz, ex, ey, ez) {
                // Main channel with stepped leader and multiple glow layers
                const mainPath = this.createSteppedLeader(sx, sy, sz, ex, ey, ez);
                
                // Core bright white
                const mainGeom = new THREE.BufferGeometry().setFromPoints(mainPath);
                const mainMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1.0,
                    linewidth: 4
                });
                const mainBolt = new THREE.Line(mainGeom, mainMat);
                mainBolt.userData.life = 1.0;
                mainBolt.userData.isMain = true;
                AppState.scene.add(mainBolt);
                this.bolts.push(mainBolt);

                // Multiple glow layers for depth
                for (let g = 0; g < 3; g++) {
                    const glowGeom = new THREE.BufferGeometry().setFromPoints(mainPath);
                    const glowColor = [0xccddff, 0x99bbff, 0x6699ff][g];
                    const glowMat = new THREE.LineBasicMaterial({
                        color: glowColor,
                        transparent: true,
                        opacity: [0.5, 0.35, 0.2][g],
                        linewidth: [14, 10, 6][g]
                    });
                    const glow = new THREE.Line(glowGeom, glowMat);
                    glow.userData.life = 0.85 + g * 0.05;
                    AppState.scene.add(glow);
                    this.bolts.push(glow);
                }

                // Enhanced branching with more natural spread
                const sampleCount = Math.max(5, Math.floor(mainPath.length * 0.25));
                for (let bI = 0; bI < sampleCount; bI++) {
                    const idx = Math.floor((bI / sampleCount) * mainPath.length * (0.5 + Math.random() * 0.8));
                    if (Math.random() > 0.15) {
                        this.createBranch(mainPath[Math.max(1, Math.min(mainPath.length-2, idx))], 0, 3 + (Math.random() < 0.25 ? 1 : 0));
                    }
                }

                // Scene-wide bright flash for impact
                if (!this.ambientFlash) {
                    this.ambientFlash = { intensity: 0.6, duration: 0, maxDuration: 80 };
                    const ambLight = new THREE.PointLight(0xeef5ff, 0.3, 500);
                    ambLight.position.set((sx + ex) / 2, (sy + ey) / 2, (sz + ez) / 2);
                    AppState.scene.add(ambLight);
                    this.ambientFlash.light = ambLight;
                } else {
                    this.ambientFlash.intensity = Math.min(1.0, this.ambientFlash.intensity + 0.4);
                    this.ambientFlash.duration = 0;
                }
            }

            // New helper to pulse multiple strikes quickly (count >=1)
            pulseStrike(sx, sy, sz, ex, ey, ez, count = 2, spacingMs = 90) {
                // immediate strike
                this.makeBolt(sx, sy, sz, ex, ey, ez);
                // schedule additional quick pulses with slight jitter
                for (let p = 1; p < count; p++) {
                    setTimeout(() => {
                        const jitter = (p * 0.6);
                        const ox = (Math.random() - 0.5) * 6 * jitter;
                        const oz = (Math.random() - 0.5) * 6 * jitter;
                        const oy = (Math.random() - 0.5) * 2 * jitter;
                        this.makeBolt(sx + ox, sy + oy, sz + oz, ex + (Math.random()-0.5)*8, ey + (Math.random()-0.5)*1.2, ez + (Math.random()-0.5)*8);
                    }, spacingMs * p);
                }
            }

            strike() {
                if (!this.enabled) return;
                const mature = this.cloudSystemRef.getMature();
                if (mature.length === 0) return;
                
                const c = mature[Math.floor(Math.random() * mature.length)];
                const sx = c.x + (Math.random() - 0.5) * 10;
                const sz = c.z + (Math.random() - 0.5) * 10;
                
                // bias strikes to form hot-spots: 60% chance to re-strike near last strike location
                if (this.lastStrikeLocation && Math.random() < 0.6) {
                    const dx = (Math.random() - 0.5) * 35;
                    const dz = (Math.random() - 0.5) * 35;
                    this.lastStrikeLocation.x += dx;
                    this.lastStrikeLocation.z += dz;
                } else {
                    this.lastStrikeLocation = { x: sx, z: sz };
                }
                
                const strikeX = this.lastStrikeLocation.x;
                const strikeZ = this.lastStrikeLocation.z;
                
                // decide pulse count
                const basePulse = (c.mass > 7 || c.stage === 'supercell') ? 3 : 2;
                const pulseCount = basePulse + Math.floor(Math.random() * 2);

                // Ground-to-cloud pulsing
                this.pulseStrike(
                    strikeX, c.height + 5, strikeZ,
                    strikeX + (Math.random() - 0.5) * 25, 0.5, strikeZ + (Math.random() - 0.5) * 25,
                    pulseCount,
                    90
                );
                
                // Create explosion effect at strike location
                this.createExplosion(strikeX, 0.5, strikeZ, c.height + 5, pulseCount);
                
                // Occasional cloud-to-cloud
                if (Math.random() > 0.6 && mature.length > 1) {
                    const c2 = mature[Math.floor(Math.random() * mature.length)];
                    this.pulseStrike(
                        strikeX, c.height + 3, strikeZ,
                        c2.x + (Math.random() - 0.5) * 8, c2.height + 2, c2.z + (Math.random() - 0.5) * 8,
                        Math.max(2, Math.floor(pulseCount / 1.5)),
                        110
                    );
                }
                
                this.flash.intensity = 35;
                this.flash.position.set(strikeX, c.height, strikeZ);
                this.count++;
                this.last = performance.now();
                
                // Distance-based camera shake
                const cam = AppState.camera.position;
                const dist = Math.sqrt((strikeX - cam.x)**2 + (c.height - cam.y)**2 + (strikeZ - cam.z)**2);
                const maxDist = 150;
                const proximity = Math.max(0, 1 - dist / maxDist);
                const baseIntensity = 0.5 + proximity * 4.0;
                
                const s = 1.2 + baseIntensity * 2.5;
                AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, s);
                AppState.cameraControls.shake.duration = Math.max(AppState.cameraControls.shake.duration, 600);
                AppState.cameraControls.shake.time = 0;
            }

            createExplosion(x, y, z, cloudHeight, intensity = 1) {
                // Radial shockwave removed ‚Äî keep explosion particles and subtle effects only.
 
                // Explosion particles (fast radial burst)
                const expGeo = new THREE.BufferGeometry();
                const pcount = 80 + Math.floor(intensity * 40);
                const epos = new Float32Array(pcount * 3);
                const evel = new Float32Array(pcount * 3);
                for (let i = 0; i < pcount; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const elev = (Math.random() - 0.3) * Math.PI * 0.5;
                    const r = Math.random() * 2.2;
                    epos[i*3] = x + Math.cos(ang) * r;
                    epos[i*3+1] = y + Math.random() * 2.6;
                    epos[i*3+2] = z + Math.sin(ang) * r;
                    const speed = 0.8 + Math.random() * (1.6 * intensity);
                    evel[i*3] = Math.cos(ang) * Math.cos(elev) * speed;
                    evel[i*3+1] = Math.sin(elev) * speed * (1.2 + Math.random() * 0.8);
                    evel[i*3+2] = Math.sin(ang) * Math.cos(elev) * speed;
                }
                expGeo.setAttribute('position', new THREE.BufferAttribute(epos, 3));
                expGeo.setAttribute('velocity', new THREE.BufferAttribute(evel, 3));
                const expMat = new THREE.PointsMaterial({
                    size: 0.32 + intensity * 0.18,
                    color: 0xffdd88,
                    transparent: true,
                    opacity: 0.95,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                const exp = new THREE.Points(expGeo, expMat);
                exp.userData = { life: 0.35 + intensity * 0.15, vel: evel, gravity: 0.12 };
                AppState.scene.add(exp);
                this.bolts.push(exp);

                // Lightning upstrike to cloud (thin bright column)
                const upstrike = new THREE.BufferGeometry();
                const upPts = [];
                const steps = 12 + Math.floor(intensity * 6);
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const chaosX = (Math.random() - 0.5) * (1 + t * 2);
                    const chaosZ = (Math.random() - 0.5) * (1 + t * 2);
                    upPts.push(new THREE.Vector3(
                        x + chaosX,
                        y + t * cloudHeight,
                        z + chaosZ
                    ));
                }
                upstrike.setFromPoints(upPts);
                const upMat = new THREE.LineBasicMaterial({
                    color: 0xffffcc,
                    transparent: true,
                    opacity: 0.95 * intensity,
                    linewidth: 2
                });
                const upLine = new THREE.Line(upstrike, upMat);
                upLine.userData = { life: 0.26, isExplosion: true };
                AppState.scene.add(upLine);
                this.bolts.push(upLine);

                // Shock wave ground effect: crater radial dust
                if (Math.random() < 0.7) {
                    const dustGeo = new THREE.BufferGeometry();
                    const dustCnt = 60 + Math.floor(intensity * 30);
                    const dpos = new Float32Array(dustCnt * 3);
                    for (let i = 0; i < dustCnt; i++) {
                        const a = Math.random() * Math.PI * 2;
                        const r = Math.random() * (3 + intensity * 2);
                        dpos[i*3] = x + Math.cos(a) * r;
                        dpos[i*3+1] = y + (Math.random() - 0.5) * 0.4 + 0.5;
                        dpos[i*3+2] = z + Math.sin(a) * r;
                    }
                    dustGeo.setAttribute('position', new THREE.BufferAttribute(dpos, 3));
                    const dustMat = new THREE.PointsMaterial({
                        size: 0.18 + Math.random() * 0.32,
                        color: 0xccbbaa,
                        transparent: true,
                        opacity: 0.65,
                        depthWrite: false,
                        blending: THREE.NormalBlending,
                        sizeAttenuation: true
                    });
                    const dust = new THREE.Points(dustGeo, dustMat);
                    dust.userData = { life: 0.4, isExplosion: true };
                    AppState.scene.add(dust);
                    this.bolts.push(dust);
                }

                // Add intense downburst gust at strike location
                if (AppState.downburstSystem) {
                    AppState.downburstSystem.trigger(x, z, 8 + intensity * 4, 16 + intensity * 8, 140 + Math.floor(intensity * 60));
                    // notify trees of impulse for visual coupling
                    if (AppState.treeSystem) AppState.treeSystem.applyImpulse(x, z, 8 + intensity * 4, 36 + intensity * 6);
                }

                // Ignite nearby trees: set onFire flag for trees within radius proportional to intensity
                try {
                    if (AppState.treeSystem && AppState.treeSystem.trees) {
                        const igniteRadius = Math.max(6, 6 + intensity * 6);
                        for (const tr of AppState.treeSystem.trees) {
                            const d = Math.hypot(tr.position.x - x, tr.position.z - z);
                            if (d < igniteRadius && Math.random() < Math.min(0.9, 0.25 + (igniteRadius - d) / igniteRadius * 0.85)) {
                                tr.userData.onFire = true;
                                tr.userData.fireTime = 160 + Math.floor(Math.random() * 160);
                                // make canopy hotter immediately
                                const canopy = tr.userData.canopy || tr.children.find(c => c.geometry === AppState.treeSystem.leafGeo);
                                if (canopy && canopy.material) {
                                    canopy.material.color.lerp(new THREE.Color(0xde5b22), 0.45);
                                    canopy.material.emissive = new THREE.Color(0x441100);
                                }
                            }
                        }
                    }
                } catch (e) {}
            }

            update(t) {
                if (!this.enabled) {
                    // decay existing bolts quickly
                    this.bolts.forEach(b => b.userData && (b.userData.life -= 0.08));
                }
                const mature = this.cloudSystemRef.getMature();

                // Per-cloud charge separation model:
                // Each cloud accumulates a bipolar reservoir proportional to mass, condensation and updraft/turbulence.
                let totalCharge = 0;
                for (const c of this.cloudSystemRef.clouds) {
                    if (!c) continue;
                    // Only accumulate charge for deep convective storms (cumulonimbus and supercell)
                    if (c.stage !== 'cumulonimbus' && c.stage !== 'supercell') {
                        // ensure weaker clouds don't retain large charge reservoirs
                        const prevZero = this._cloudCharge.get(c) || 0;
                        const decayed = prevZero * 0.92;
                        this._cloudCharge.set(c, decayed);
                        // include small decayed residual but primarily ignore for global potential
                        totalCharge += Math.abs(decayed) * 0.12;
                        continue;
                    }
                    // compute local separation tendency for qualifying clouds
                    const updraft = (AppState.updraftSystem ? AppState.updraftSystem.getUpdraftAt(c.x, c.z) : 0);
                    const separation = (c.mass || 0) * (c.condensationLevel || 0) * (0.4 + (c.turbulence || 0)) * (1 + updraft * 0.8);
                    // sign: positive for main convective cores, reduce sign for dissipating clouds
                    const sign = c.dying ? -0.4 : 1.0;
                    const prev = this._cloudCharge.get(c) || 0;
                    // accumulate with slight randomness for variability
                    const delta = separation * 0.035 * (0.65 + Math.random() * 0.5) * sign;
                    const newCharge = prev * 0.96 + delta;
                    this._cloudCharge.set(c, newCharge);
                    totalCharge += Math.abs(newCharge);
                }

                // global charge is aggregated absolute reservoir (mimics region-wide potential)
                // reduce scaling so totalCharge must accumulate longer to reach threshold
                // apply UI charge multiplier for faster/slower accumulation
                const mult = (typeof Graphics !== 'undefined' ? (Graphics.chargeMultiplier || 1.0) : 1.0);
                this.charge = Math.max(0, Math.min(1000, totalCharge * 3.0 * Number(mult)));

                // compute a readable charge percentage relative to the threshold (used for triggering and UI)
                // percent = (charge / threshold) * 100, clamped to reasonable range
                this.chargePercent = Math.max(0, Math.min(999, Math.floor((this.charge / Math.max(1, this.threshold)) * 100)));

                // Attempt discharge if threshold exceeded (either absolute charge or percent >=100) and mature convection present
                // NOTE: cooldown requirement reduced so strikes can happen as soon as charge condition meets threshold
                if ((this.charge > this.threshold || this.chargePercent >= 100) && mature.length > 0) {
                    // choose a cloud with high local charge to strike from
                    let sourceCloud = null;
                    let bestCharge = 0;
                    for (const c of this.cloudSystemRef.clouds) {
                        const qc = Math.abs(this._cloudCharge.get(c) || 0);
                        if (qc > bestCharge) { bestCharge = qc; sourceCloud = c; }
                    }
                    if (sourceCloud && Math.random() > 0.35) {
                        // Prefer CG strikes if cloud has strong positive reservoir else attempt inter-cloud
                        const sx = sourceCloud.x + (Math.random() - 0.5) * 12;
                        const sz = sourceCloud.z + (Math.random() - 0.5) * 12;
                        // decide pulse count based on local charge and cloud intensity
                        const basePulse = (sourceCloud.mass > 7 || sourceCloud.stage === 'supercell') ? 3 : 2;
                        // bias to more pulses when charge is large
                        const pulseCount = basePulse + Math.floor(Math.random() * (1 + Math.min(3, Math.floor(Math.abs(bestCharge) / 4))));
                        if (Math.random() < 0.66) {
                            // cloud-to-ground pulsing
                            this.pulseStrike(
                                sx, sourceCloud.height + 4 + Math.random() * 6, sz,
                                sx + (Math.random() - 0.5) * 20, 0.5, sz + (Math.random() - 0.5) * 20,
                                pulseCount,
                                90
                            );
                        } else {
                            const targets = this.cloudSystemRef.clouds.filter(cc => cc !== sourceCloud && Math.hypot(cc.x - sourceCloud.x, cc.z - sourceCloud.z) < 120);
                            if (targets.length > 0) {
                                const c2 = targets[Math.floor(Math.random() * targets.length)];
                                this.pulseStrike(
                                    sx, sourceCloud.height + 3, sz,
                                    c2.x + (Math.random() - 0.5) * 8, c2.height + 2, c2.z + (Math.random() - 0.5) * 8,
                                    Math.max(2, Math.floor(pulseCount / 1.5)),
                                    110
                                );
                            } else {
                                // fallback ground pulsing
                                this.pulseStrike(
                                    sx, sourceCloud.height + 4, sz,
                                    sx + (Math.random() - 0.5) * 20, 0.5, sz + (Math.random() - 0.5) * 20,
                                    pulseCount,
                                    100
                                );
                            }
                        }

                        // On strike: clear the main cloud's charge and reduce neighbors.
                        const prevSrc = this._cloudCharge.get(sourceCloud) || 0;
                        this._cloudCharge.set(sourceCloud, 0);
                        for (const nb of this.cloudSystemRef.clouds) {
                            if (!nb || nb === sourceCloud) continue;
                            const d = Math.hypot(nb.x - sourceCloud.x, nb.z - sourceCloud.z);
                            if (d < 180) {
                                const factor = Math.max(0, 1 - d / 180);
                                const prev = this._cloudCharge.get(nb) || 0;
                                this._cloudCharge.set(nb, prev * (1 - 0.7 * factor));
                            }
                        }

                        this.flash.intensity = 35;
                        this.flash.position.set(sx, sourceCloud.height, sz);
                        this.count++;
                        this.last = performance.now();

                        // camera shake scaled to strike proximity & the charge strength
                        const cam = AppState.camera.position;
                        const dist = Math.sqrt((sx - cam.x)**2 + (sourceCloud.height - cam.y)**2 + (sz - cam.z)**2);
                        const maxDist = 180;
                        const proximity = Math.max(0, 1 - dist / maxDist);
                        const baseIntensity = 0.8 + proximity * 3.6;
                        const s = 1.0 + baseIntensity * (Math.min(5, Math.abs(bestCharge)) / 4.0);
                        AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, s);
                        AppState.cameraControls.shake.duration = Math.max(AppState.cameraControls.shake.duration, 700);
                        AppState.cameraControls.shake.time = 0;
                    }
                }

                // Flash decay and bolt life update same as before
                this.flash.intensity *= 0.75;

                // update bolts and transient spark particles with type-aware fading/size pulsing
                for (let i = this.bolts.length - 1; i >= 0; i--) {
                    const b = this.bolts[i];
                    if (!b || !b.userData) continue;
                    // different decay for lines vs points
                    const isLine = b.type && b.type.indexOf('Line') >= 0;
                    const fadeSpeed = (b.userData.isMain ? 0.14 : (b.userData.life ? 0.12 : 0.08));
                    b.userData.life -= fadeSpeed * (isLine ? 1.0 : 0.9);
                    // gentle flicker for glow
                    if (b.material) {
                        const flick = 1 + (Math.random() - 0.5) * 0.08;
                        b.material.opacity = Math.max(0, (b.material.opacity || 1) * (0.92 + 0.06 * (b.userData.life || 0)) * flick);
                    }
                    if ((b.userData.life || 0) <= 0) {
                        AppState.scene.remove(b);
                        if (b.geometry) b.geometry.dispose();
                        if (b.material) b.material.dispose();
                        this.bolts.splice(i, 1);
                    } else {
                        // animate small sparks points to drift/fall slightly
                        if (b.type && b.type.indexOf('Points') >= 0 && b.geometry && b.geometry.attributes.position) {
                            const arr = b.geometry.attributes.position.array;
                            for (let k = 0; k < arr.length; k += 3) {
                                arr[k] += (Math.random() - 0.5) * 0.02 * (1 + (1 - b.userData.life));
                                arr[k+1] -= 0.02 * (0.5 + Math.random() * 0.6) * (1 - b.userData.life);
                                arr[k+2] += (Math.random() - 0.5) * 0.02 * (1 + (1 - b.userData.life));
                            }
                            b.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }
            }
        }

        // Rainbow visual system (optical arcs tied to sun position & moisture)
        class RainbowSystem {
            constructor() {
                this.enabled = true;
                this.arcs = new THREE.Group();
                AppState.scene.add(this.arcs);
                this.sunDir = new THREE.Vector3(1, 1, 0).normalize();
                this.persistent = []; // keep light-weight line/mesh artifacts
            }

            update(t) {
                if (!this.enabled) {
                    // fade and clear
                    this.arcs.traverse(o => {
                        if (o.material) {
                            o.material.opacity *= 0.88;
                        }
                    });
                    // remove fully faded
                    this.arcs.children = this.arcs.children.filter(c => (c.material && c.material.opacity > 0.02) || !c.material);
                    return;
                }

                // Rainbows require sun behind the camera and moisture in front (use low-level downburst / rain shaft density)
                // We compute a simple proxy: average shaft opacity and recent precipitation presence
                let moistureScore = 0;
                if (AppState.rainSystem) {
                    // look at a subset of shafts or drops to approximate humidity columns
                    if (AppState.rainSystem.cloudShafts) {
                        for (const [cloud, shaft] of AppState.rainSystem.cloudShafts) {
                            if (!shaft || !shaft.material) continue;
                            moistureScore += shaft.material.opacity || 0;
                        }
                    }
                    // also consider rain drops count
                    const activeDrops = AppState.rainSystem ? AppState.rainSystem.max - AppState.rainSystem.drops.filter(d=>!d.active).length : 0;
                    moistureScore += Math.min(1, activeDrops / 800);
                }

                // Get sun direction from scene directional light (sun)
                const sunObj = AppState.scene.children.find(o => o && o.isDirectionalLight);
                if (sunObj) {
                    this.sunDir.copy(sunObj.position).normalize();
                }

                // Determine if viewing geometry supports rainbow (sun low behind camera approx)
                const camVec = new THREE.Vector3();
                AppState.camera.getWorldDirection(camVec);
                // rainbow forms opposite the sun relative to camera: check dot between sunDir and cam forward, want sun behind camera (dot < -0.2)
                const sunBehind = this.sunDir.dot(camVec) < -0.2;

                // spawn or update arcs if moisture is sufficient and sun is behind
                if (moistureScore > 0.12 && sunBehind) {
                    // build 1 or 2 arcs based on intensity
                    const arcCount = moistureScore > 0.6 ? 2 : 1;
                    // reuse or create arcs
                    while (this.arcs.children.length < arcCount) {
                        const ring = this._createRainbowArc();
                        this.arcs.add(ring);
                    }

                    // update position/orientation to be centered opposite sun and at a comfortable distance
                    const baseDir = this.sunDir.clone().negate().setY(0).normalize();
                    const up = new THREE.Vector3(0,1,0);
                    const right = new THREE.Vector3().crossVectors(up, baseDir).normalize();
                    const center = new THREE.Vector3().copy(AppState.camera.position).add(baseDir.clone().multiplyScalar(140)).setY(24);

                    for (let i = 0; i < this.arcs.children.length; i++) {
                        const arc = this.arcs.children[i];
                        const scale = 1.0 + i * 0.35;
                        arc.position.copy(center);
                        arc.lookAt(AppState.camera.position);
                        arc.scale.setScalar(1.0 + i * 0.18);
                        arc.material.opacity = Math.min(0.95, (0.12 + moistureScore * 0.88) * (1.0 - i * 0.35) );
                        // slight pulsation & chromatic dispersion emulation
                        arc.rotation.z = Math.sin(t * 0.0007 + i) * 0.02;
                        arc.material.needsUpdate = true;
                    }
                } else {
                    // fade out arcs
                    this.arcs.traverse(o => { if (o.material) o.material.opacity *= 0.92; });
                    // remove very faint
                    this.arcs.children = this.arcs.children.filter(c => (c.material && c.material.opacity > 0.02));
                }
            }

            _createRainbowArc() {
                // create a simple semi-circular ribbon using a strip of vertices and vertex colors for spectral gradient
                const seg = 96;
                const radius = 60;
                const inner = radius * 0.88;
                const outer = radius * 1.04;
                const positions = [];
                const colors = [];
                for (let i = 0; i <= seg; i++) {
                    const t = i / seg; // 0..1 across arc from left to right
                    const angle = Math.PI * (0.05 + 0.9 * t); // semi arc
                    // outer
                    positions.push(Math.cos(angle) * outer, Math.sin(angle) * outer, 0);
                    // inner
                    positions.push(Math.cos(angle) * inner, Math.sin(angle) * inner, 0);

                    // spectral color gradient across the thickness (approx ROYGBIV)
                    const spec = new THREE.Color();
                    // map t to approximate wavelength
                    const col = new THREE.Color().setHSL(0.66 - t * 0.66, 0.95, 0.6);
                    colors.push(col.r, col.g, col.b);
                    colors.push(col.r * 0.85, col.g * 0.85, col.b * 0.85);
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                // create a two-sided transparent material that uses vertex colors
                const mat = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.0,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                // create a triangle strip via Index buffer
                const indices = [];
                for (let i = 0; i < seg; i++) {
                    const a = i * 2;
                    const b = a + 1;
                    const c = a + 2;
                    const d = a + 3;
                    indices.push(a, c, b);
                    indices.push(c, d, b);
                }
                geometry.setIndex(indices);
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.renderOrder = 1000;
                return mesh;
            }
        }

        // Radar overlay (2D screen-space) - simple precipitation intensity map derived from precipitation particles
        class RadarOverlay {
            constructor() {
                this.enabled = true;
                this.canvas = document.createElement('canvas');
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '50%';
                this.canvas.style.top = '12px';
                this.canvas.style.transform = 'translateX(-50%)';
                this.canvas.style.width = '420px';
                this.canvas.style.height = '120px';
                this.canvas.width = 420;
                this.canvas.height = 120;
                this.canvas.style.zIndex = 200;
                this.canvas.style.pointerEvents = 'none';
                this.ctx = this.canvas.getContext('2d');
                document.body.appendChild(this.canvas);
                this.fade = 0.87;
            }
            update() {
                if (!this.enabled) {
                    this.canvas.style.display = 'none';
                    return;
                }
                this.canvas.style.display = 'block';
                const ctx = this.ctx;
                ctx.fillStyle = 'rgba(8,8,14,0.12)';
                ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
                // grid
                ctx.strokeStyle = 'rgba(255,255,255,0.04)';
                for (let i=1;i<6;i++){ ctx.beginPath(); ctx.moveTo(i*(this.canvas.width/6),0); ctx.lineTo(i*(this.canvas.width/6),this.canvas.height); ctx.stroke(); }
                // sample precipitation density from rainSystem drops and shafts to build heatmap
                const map = new Float32Array(this.canvas.width * this.canvas.height);
                if (AppState.rainSystem) {
                    for (let i=0;i<AppState.rainSystem.max;i++) {
                        if (!AppState.rainSystem.drops[i].active) continue;
                        const x = AppState.rainSystem.pos[i*3];
                        const z = AppState.rainSystem.pos[i*3+2];
                        // project world x,z to radar coords (center map on camera)
                        const relX = Math.floor((x - AppState.camera.position.x) / 2 + this.canvas.width/2);
                        const relY = Math.floor((z - AppState.camera.position.z) / 2 + this.canvas.height/2);
                        if (relX < 0 || relX >= this.canvas.width || relY < 0 || relY >= this.canvas.height) continue;
                        const idx = relY * this.canvas.width + relX;
                        map[idx] = Math.min(1, map[idx] + Math.min(1, AppState.rainSystem.size[i] * 0.18));
                    }
                    // also sample shafts
                    for (const [c, shaft] of AppState.rainSystem.cloudShafts) {
                        if (!c) continue;
                        const rx = Math.floor((c.x - AppState.camera.position.x) / 2 + this.canvas.width/2);
                        const ry = Math.floor((c.z - AppState.camera.position.z) / 2 + this.canvas.height/2);
                        for (let oy=-6; oy<=6; oy++) {
                            for (let ox=-6; ox<=6; ox++) {
                                const sx = rx + ox; const sy = ry + oy;
                                if (sx<0||sx>=this.canvas.width||sy<0||sy>=this.canvas.height) continue;
                                const id = sy*this.canvas.width+sx;
                                map[id] = Math.min(1, map[id] + (shaft.userData && shaft.userData.intensity? shaft.userData.intensity*0.45 : 0.35));
                            }
                        }
                    }
                }
                // draw heatmap with color ramp
                for (let y=0;y<this.canvas.height;y++) {
                    for (let x=0;x<this.canvas.width;x++) {
                        const v = map[y*this.canvas.width + x] || 0;
                        if (v < 0.02) continue;
                        // color ramp: green -> yellow -> red -> magenta
                        let col;
                        if (v < 0.35) col = `rgba(${Math.floor(80+v*140)},${Math.floor(180*v*1.2+60)},50,${Math.min(0.9,v)})`;
                        else if (v < 0.7) col = `rgba(230,${Math.floor(180*(1-(v-0.35)/0.35))},40,${Math.min(0.95,v)})`;
                        else col = `rgba(240,80,${Math.floor(200*(v-0.7)/0.3)},${Math.min(1.0,v)})`;
                        ctx.fillStyle = col;
                        ctx.fillRect(x,y,1,1);
                    }
                }
                // overlay legend
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = '11px Noto Sans, sans-serif';
                ctx.fillText('Radar (precip intensity)', 8, 12);
            }
            dispose() {
                this.canvas.remove();
            }
        }

        // Volcano & Industrial emitters produce smoke/pyro cloud seeds (pyrocumulus)
        class SourceEmitter {
            // size ~= lateral scale of emitter (used to scale geometry and emission strength)
            // height is used as an approximate source altitude baseline
            constructor(type='factory', x=60, z=-40, size=8, height=10) {
                this.type = type;
                this.x = x; this.z = z;
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.timer = 0;
                this.puffs = [];
                // visual marker (small building/volcano)
                // accept size/height parameters to scale volcanic edifice and pyro emissions
                this.size = size || 8;
                this.height = height || 10;
                if (type === 'volcano') {
                    // scale geometric source dimensions by provided size/height
                    const baseRadius = Math.max(6, this.size * 1.0);
                    const coneRadius = Math.max(4.5, this.size * 0.75);
                    const coneHeight = Math.max(6, this.height * 0.9);
                    const rimRadius = Math.max(3.5, this.size * 0.5);

                    const baseMat = new THREE.MeshStandardMaterial({ color: 0x3b2b24, roughness: 0.95 });
                    const flankMat = new THREE.MeshStandardMaterial({ color: 0x2f241f, roughness: 0.92 });
                    const rimMat = new THREE.MeshStandardMaterial({ color: 0x2a1d16, roughness: 0.96 });

                    const baseGeo = new THREE.CylinderGeometry(baseRadius * 1.1, baseRadius * 1.3, Math.max(3, this.size * 0.35), 28);
                    const baseMesh = new THREE.Mesh(baseGeo, baseMat);
                    baseMesh.position.set(x, Math.max(1.6, this.size * 0.25), z);
                    baseMesh.castShadow = true;
                    baseMesh.receiveShadow = true;
                    this.group.add(baseMesh);

                    const flankGeo = new THREE.ConeGeometry(coneRadius, coneHeight, 28);
                    const flank = new THREE.Mesh(flankGeo, flankMat);
                    flank.position.set(x, Math.max(2.6, coneHeight * 0.5), z);
                    flank.castShadow = true;
                    this.group.add(flank);

                    const rimGeo = new THREE.TorusGeometry(rimRadius, Math.max(0.5, rimRadius * 0.08), 12, 40);
                    const rim = new THREE.Mesh(rimGeo, rimMat);
                    rim.rotation.x = Math.PI / 2;
                    rim.position.set(x, Math.max(2.6, coneHeight * 0.92), z);
                    rim.castShadow = false;
                    this.group.add(rim);

                    const lavaGeo = new THREE.PlaneGeometry(Math.max(4, rimRadius * 1.2), Math.max(10, coneHeight * 0.9), 6, 1);
                    const lavaMat = new THREE.MeshStandardMaterial({ color: 0xff5b22, emissive: 0xff6e33, emissiveIntensity: 1.6, roughness: 0.5, metalness: 0.12 });
                    const lava = new THREE.Mesh(lavaGeo, lavaMat);
                    lava.rotation.x = -Math.PI / 2;
                    lava.position.set(x, Math.max(2.2, coneHeight * 0.9 - 0.6), z - Math.min(2.4, rimRadius * 0.3));
                    lava.receiveShadow = false;
                    this.group.add(lava);

                    const lavaLight = new THREE.PointLight(0xff7a33, 1.1 + (this.size * 0.02), Math.max(18, rimRadius * 2.4));
                    lavaLight.position.set(x, Math.max(2.6, coneHeight * 0.92), z);
                    AppState.scene.add(lavaLight);
                    this._lavaLight = lavaLight;
                } else {
                    const box = new THREE.BoxGeometry(6,4,6);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a });
                    const b = new THREE.Mesh(box, mat); b.position.set(x,2,z);
                    this.group.add(b);
                }
            }
            update(t) {
                this.timer++;
                // volcano: frequent pulsing pyro-emissions (stronger and more likely to form pyrocumulus variants)
                if (this.type === 'volcano' && this.timer % Math.max(8, Math.floor(28 - this.size * 0.6)) === 0) {
                    // scale strength and radii by emitter size so large volcanoes produce stronger pyro-convection
                    const sizeScale = Math.max(1.0, this.size / 8);
                    const strength = 1.6 * sizeScale + Math.random() * (2.2 * sizeScale);
                    const jitter = Math.max(1.2, Math.min(6, this.size * 0.12));
                    const baseX = this.x + (Math.random() - 0.5) * jitter;
                    const baseZ = this.z + (Math.random() - 0.5) * jitter;
                    
                    // NEW: Spawn actual pyro clouds via CloudGrowth system instead of raw puffs
                    const pyroCloud = AppState.cloudSystem.grow(baseX, baseZ);
                    if (pyroCloud) {
                        // force pyro characteristics: darker, turbulent, aggressive
                        const sourceAlt = Math.max(4, (this.height || 10) * 0.6 + Math.random() * (this.height || 10) * 0.6);
                        pyroCloud.baseHeight = Math.max(3, sourceAlt - 1.2);
                        pyroCloud.height = sourceAlt + 2 + Math.random() * 4;
                        pyroCloud.cloudBase = Math.max(2, sourceAlt - 2);
                        pyroCloud.cloudTop = sourceAlt + 8 + Math.random() * 12;
                        pyroCloud.mass = Math.max(2.8, 1.2 + strength * 0.9);
                        pyroCloud.condensationLevel = Math.min(1, 0.55 + strength * 0.15);
                        pyroCloud.turbulence = Math.max(0.65, 0.3 + strength * 0.25);
                        pyroCloud.growthRate *= (1.4 + sizeScale * 0.6);
                        pyroCloud.verticalVelocity = 0.12 + strength * 0.08;
                        pyroCloud.buoyancy = 1.2 + strength * 0.8;
                        // darken for pyro signature (ash/smoke tint)
                        pyroCloud.puffs.forEach(p => {
                            if (p && p.material) {
                                p.material.color.lerp(new THREE.Color(0.22, 0.18, 0.15), 0.65);
                                if (p.material.emissive) p.material.emissive.lerp(new THREE.Color(0x440000), 0.45);
                            }
                        });
                        // mark as pyro cloud for special handling (enhanced convection)
                        pyroCloud._isPyroCloud = true;
                    }
                    
                    // also spawn a strong updraft pulse centered on volcano
                    AppState.cloudSystem.updrafts.push({
                        x: baseX,
                        z: baseZ,
                        strength: 1.8 * sizeScale + strength * 0.7,
                        radius: Math.max(18, Math.floor(26 * sizeScale + Math.random() * (this.size * 1.4))),
                        height: 0,
                        maxHeight: Math.max(20, this.height * 1.6),
                        age: 0,
                        maxAge: 220 + Math.floor(Math.random() * 480 * sizeScale),
                        active: true
                    });
                }

                // industrial/factory emission cadence (less intense)
                if (this.type !== 'volcano' && this.timer % (this.type === 'factory' ? 78 : 120) === 0) {
                    const strength = 0.5 + Math.random()*0.9;
                    const w = AppState.cloudSystem.makePuff(this.x + (Math.random()-0.5)*2, 4 + Math.random()*2, this.z + (Math.random()-0.5)*2, 2 + Math.random()*3, 0.06 + Math.random()*0.08, 0.18, 'cumulus');
                    w.userData = w.userData || {};
                    w.userData.updraftClone = true;
                    w.userData.vy = 0.02 + Math.random()*0.02;
                    AppState.cloudSystem.updrafts.push({ x: this.x, z: this.z, strength: 0.38 + strength*0.4, radius: 12 + Math.random()*10, age:0, maxAge: 120 + Math.floor(Math.random()*120) });
                }

                // update ember lifetimes
                if (this._embers) {
                    for (let i=this._embers.length-1;i>=0;i--) {
                        const eb = this._embers[i];
                        eb.userData.life -= 0.01;
                        eb.material.opacity *= 0.97;
                        eb.position.y += (eb.userData.vy || 0) * 0.6;
                        if (eb.userData.life <= 0) {
                            AppState.scene.remove(eb);
                            if (eb.geometry) eb.geometry.dispose();
                            if (eb.material) eb.material.dispose();
                            this._embers.splice(i,1);
                        }
                    }
                }

                // gentle pulsing of lava/emissive vent if present
                if (this._lavaLight) {
                    this._lavaLight.intensity = 0.6 + 0.6 * (0.6 + 0.4 * Math.sin(this.timer * 0.06)) * (1 + (this.size / 14));
                    this._lavaLight.position.y = Math.max(2.4, (this.height || 10) * 0.92) + Math.sin(this.timer * 0.02) * 0.08;
                }
            }
            dispose() {
                this.group.traverse(o=>{ if (o.geometry) try{o.geometry.dispose();}catch(e){} if (o.material) try{o.material.dispose();}catch(e){} });
                try{ AppState.scene.remove(this.group); }catch(e){}
            }
        }

        // Improved sunlight scattering: small volumetric tint and aerosols applied in sun effects update (cheap approximation)
        function applySunScattering() {
            if (!AppState._sunGlare || !AppState._godrays) return;
            // compute scattering based on sun elevation and greenhouse/aerosol proxy
            const sun = AppState.scene.children.find(o => o && o.isDirectionalLight);
            if (!sun) return;
            const elevation = Math.max(-1, Math.min(1, sun.position.y / 80));
            // aerosol derived from greenhouse slider (more greenhouse -> slightly hazier)
            const a = Math.min(1, 0.08 + (Graphics.greenhouse || 0) * 0.02);
            // adjust godray intensity and color temperature slightly
            const base = 0.12 + Math.max(0, -Math.min(0, elevation))*0.28;
            AppState._godrays.material.color.setHSL(0.12 + (1-elevation)*0.03, 0.6, 0.64);
            AppState._godrays.userData.baseOpacity = Math.min(0.45, base * (1 + a));
            // scene fog tint shift for golden hours
            const day = window.DayNight ? window.DayNight.dayStrength : 1;
            const warm = new THREE.Color().setHSL(0.09, 0.36, 0.7);
            const cool = new THREE.Color().setHSL(0.55,0.25,0.45);
            AppState.scene.fog.color.copy(cool).lerp(warm, Math.max(0, day * elevation));
            // small ambient color bias
            const amb = AppState.scene.getObjectByProperty && AppState.scene.children.find(o=>o && o.type==='AmbientLight');
            if (amb) amb.color.copy(new THREE.Color(0x99aabb)).lerp(new THREE.Color(0xffe6c8), Math.max(0, elevation*0.8));
        }

        // Downburst system: creates short-lived strong downward/outward winds under intense mature clouds
        class Downburst {
            constructor(windFieldRef, cloudSystemRef) {
                this.windField = windFieldRef;
                this.cloudSystem = cloudSystemRef;
                this.events = []; // active downbursts
                this.cooldown = 0;
                
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }

            // schedule a downburst at (x,z) with strength and radius
            trigger(x, z, strength = 6, radius = 20, duration = 180) {
                const event = {
                    x, z, strength, radius, life: duration, maxLife: duration,
                    created: performance.now(),
                    // add vorticity and impulse vectors for richer dynamics
                    vortexSpin: (Math.random() > 0.5 ? 1 : -1) * (0.6 + Math.random() * 1.4),
                    coreRadius: Math.max(6, radius * (0.25 + Math.random() * 0.45)),
                    visuals: new THREE.Group() // Group for associated meshes/particles
                };
                
                // --- Downburst Foot / Outflow Visualization ---
                
                // 1. Ground splash (expanding particle ring for dust/mist)
                const splashParticles = this.createSplashParticles(event);
                event.visuals.add(splashParticles);
                
                // 2. Persistent outflow boundary (ring geometry that fades)
                const ringGeo = new THREE.RingGeometry(event.coreRadius * 0.8, event.radius * 0.9, 32);
                const baseCol = new THREE.Color(0xc8d0e0);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: baseCol, 
                    transparent: true, 
                    opacity: 0.15 * (strength / 10), 
                    side: THREE.DoubleSide, 
                    depthWrite: false, 
                    blending: THREE.AdditiveBlending 
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(0, 0.4, 0); // relative to event.visuals group
                ring.userData.maxScale = 3 + strength * 0.3;
                ring.userData.type = 'outflow_ring';
                event.visuals.add(ring);
                
                event.visuals.position.set(x, 0, z);
                this.group.add(event.visuals);

                this.events.push(event);
            }

            createSplashParticles(event) {
                const particleCount = 200;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(particleCount * 3);
                const pVel = new Float32Array(particleCount * 3);
                const pLife = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * event.radius * 0.6;
                    
                    pPos[i*3] = Math.cos(angle) * r;
                    pPos[i*3+1] = 0.5;
                    pPos[i*3+2] = Math.sin(angle) * r;
                    
                    pVel[i*3] = Math.cos(angle) * (1 + Math.random() * event.strength * 0.1);
                    pVel[i*3+1] = 0.2 + Math.random() * 0.8; // upward kick
                    pVel[i*3+2] = Math.sin(angle) * (1 + Math.random() * event.strength * 0.1);
                    
                    pLife[i] = 1.0;
                }
                
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                pGeo.setAttribute('velocity', new THREE.BufferAttribute(pVel, 3));
                pGeo.setAttribute('life', new THREE.BufferAttribute(pLife, 1));
                
                const pMat = new THREE.PointsMaterial({
                    size: 0.8 + event.strength * 0.05,
                    color: 0xc8d0e0, // dusty light grey/blue
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const points = new THREE.Points(pGeo, pMat);
                points.userData = { 
                    type: 'splash_particles', 
                    strength: event.strength, 
                    maxLife: event.maxLife 
                };
                return points;
            }

            // inject a transient perturbation into the wind field for low levels
            applyToWind(event) {
                // affect a subset of windField cells near ground (gy = 0..4)
                const s = event.strength;
                const r = event.radius;
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const now = performance.now();

                for (let gx = 0; gx < size; gx++) {
                    for (let gy = 0; gy < Math.min(6, size); gy++) {
                        for (let gz = 0; gz < size; gz++) {
                            const wx = (gx - size / 2) * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const dx = wx - event.x;
                            const dz = wz - event.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < r) {
                                const radialFactor = 1 - dist / r;
                                const lifeFactor = Math.max(0.08, event.life / event.maxLife);
                                // outward radial push stronger near start, weaker at edges
                                const radialPush = s * radialFactor * lifeFactor * (1 + (4 - gy) * 0.18);
                                // add rotational (vortex) component, stronger near coreRadius
                                const vortexInfluence = Math.max(0, 1 - dist / Math.max(1, event.coreRadius));
                                const spin = event.vortexSpin * 0.9 * vortexInfluence * lifeFactor * (1 + (4 - gy) * 0.08);
                                // compute unit radial and tangential vectors
                                const inv = 1 / (dist + 0.0001);
                                const ux = dx * inv;
                                const uz = dz * inv;
                                // tangential perpendicular vector
                                const tx = -uz;
                                const tz = ux;
                                // apply combined radial + tangential perturbation
                                this.windField.field[gx][gy][gz].x += ux * radialPush * 0.6 + tx * spin * 0.8;
                                this.windField.field[gx][gy][gz].z += uz * radialPush * 0.6 + tz * spin * 0.8;
                                // add a small downward signal stored in cell for precipitation/visuals to read
                                if (!this.windField.field[gx][gy][gz].__downburst) this.windField.field[gx][gy][gz].__downburst = 0;
                                this.windField.field[gx][gy][gz].__downburst += radialPush * 0.06 * (1 + (5 - gy) * 0.06);
                                // also inject a short-lived vorticity marker
                                if (!this.windField.field[gx][gy][gz].__vortex) this.windField.field[gx][gy][gz].__vortex = 0;
                                this.windField.field[gx][gy][gz].__vortex += Math.sign(event.vortexSpin) * vortexInfluence * lifeFactor * 0.02;
                            }
                        }
                    }
                }
            }

            // occasionally spawn downbursts from very mature, heavy clouds
            update(t) {
                // cooldown reduces chance spam
                if (this.cooldown > 0) this.cooldown--;

                // check mature clouds and randomly trigger events when heavy updrafts collapse
                const mature = this.cloudSystem.getMature();
                mature.forEach(c => {
                    // high mass and sudden age spike can cause collapse -> downburst chance
                    if (c.mass > 6 && Math.random() < 0.0012 && this.cooldown === 0) {
                        const x = c.x + (Math.random() - 0.5) * 8;
                        const z = c.z + (Math.random() - 0.5) * 8;
                        const strength = 6 + Math.random() * 10;
                        const radius = Math.max(12, c.radius * 1.0 + Math.random() * 18);
                        const dur = 100 + Math.floor(Math.random() * 220);
                        this.trigger(x, z, strength, radius, dur);
                        this.cooldown = 700 + Math.floor(Math.random() * 400);
                        // stronger camera shake for larger downbursts
                        AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, 0.9 + strength * 0.18);
                    }
                });

                // apply active events to wind field and age them
                for (let i = this.events.length - 1; i >= 0; i--) {
                    const ev = this.events[i];
                    
                    // --- Visual Update ---
                    const progress = ev.life / ev.maxLife;
                    ev.visuals.traverse(obj => {
                        if (obj.userData.type === 'outflow_ring' && obj.material) {
                            const scale = 1 + (ev.maxLife - ev.life) * (obj.userData.maxScale || 3) / ev.maxLife;
                            obj.scale.set(scale, scale, scale);
                            // Initial heavy opacity, fading quickly
                            obj.material.opacity = Math.max(0.01, (progress * 0.8 + 0.2) * (ev.strength / 10) * 0.15);
                        } else if (obj.userData.type === 'splash_particles' && obj.geometry) {
                            const positions = obj.geometry.attributes.position.array;
                            const velocities = obj.geometry.attributes.velocity.array;
                            const lives = obj.geometry.attributes.life.array;
                            let allDead = true;
                            
                            for (let j = 0; j < positions.length / 3; j++) {
                                if (lives[j] > 0) {
                                    positions[j*3] += velocities[j*3] * 0.01;
                                    positions[j*3+1] += velocities[j*3+1] * 0.01;
                                    positions[j*3+2] += velocities[j*3+2] * 0.01;
                                    // Gravity/air resistance
                                    velocities[j*3+1] -= 0.05 * 0.01;
                                    
                                    lives[j] -= 0.005;
                                    
                                    if (positions[j*3+1] < 0.5) lives[j] = 0; // hit ground
                                    
                                    if (lives[j] > 0) allDead = false;
                                    
                                    // Fade based on particle life
                                    obj.material.opacity = Math.min(0.8, progress) * (lives[j] / 1.0) * 0.8; 
                                } else {
                                    // hide dead particle
                                    positions[j*3+1] = -1000;
                                }
                            }
                            obj.geometry.attributes.position.needsUpdate = true;
                            // If main event is dying, ensure particles fade and die out
                            if (ev.life < 10 && allDead) {
                                ev.life = 0;
                            }
                        }
                    });

                    // apply multiple passes per frame to create a broad transient gust and an inner core collapse
                    this.applyToWind(ev);
                    // inner core pulse that decays faster
                    if (ev.life > ev.maxLife * 0.6) {
                        // create a strong inner core impulse for the first part
                        const corePulse = {
                            x: ev.x + (Math.random() - 0.5) * (ev.coreRadius * 0.2),
                            z: ev.z + (Math.random() - 0.5) * (ev.coreRadius * 0.2),
                            strength: ev.strength * 0.6,
                            radius: Math.max(4, ev.coreRadius * 0.8),
                            life: 6,
                            maxLife: 6,
                            vortexSpin: ev.vortexSpin * (0.6 + Math.random() * 0.6)
                        };
                        this.applyToWind(corePulse);
                    }
                    // visual subtle ground flash at creation
                    if (ev.life === ev.maxLife - 1) {
                        const flash = new THREE.PointLight(0xaad6ff, 0.9, ev.radius * 1.6);
                        flash.position.set(ev.x, 8, ev.z);
                        AppState.scene.add(flash);
                        setTimeout(() => {
                            flash.intensity = 0.25;
                            setTimeout(() => {
                                AppState.scene.remove(flash);
                                if (flash.dispose) flash.dispose();
                            }, 300);
                        }, 80);
                    }
                    ev.life--;
                    if (ev.life <= 0) {
                        // Dispose visuals
                        ev.visuals.traverse(obj => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.group.remove(ev.visuals);
                        this.events.splice(i, 1);
                    }
                }
            }
        }

        // NEW: Birds flocking system (lightweight boids)
        class Birds {
            constructor(count = 28) {
                this.group = new THREE.Group();
                this.birds = [];
                this.count = count;
                this.target = new THREE.Vector3(0, 18, 0);
                const geo = new THREE.PlaneGeometry(0.8, 0.5);
                for (let i = 0; i < count; i++) {
                    const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.08 + Math.random()*0.12,0.7,0.55), side: THREE.DoubleSide });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set((Math.random()-0.5)*150, 12 + Math.random()*18, (Math.random()-0.5)*150);
                    m.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.14, (Math.random()-0.2)*0.02, (Math.random()-0.5)*0.14) };
                    m.rotation.y = Math.random()*Math.PI*2;
                    this.birds.push(m);
                    this.group.add(m);
                }
                this.group.frustumCulled = false;
                AppState.scene.add(this.group);
            }
            update(dt) {
                const tgt = this.target;
                for (let b of this.birds) {
                    const v = b.userData.vel;
                    // simple cohesion toward center + separation from high wind cells
                    const toTarget = new THREE.Vector3(tgt.x - b.position.x, tgt.y - b.position.y, tgt.z - b.position.z).multiplyScalar(0.0015);
                    v.add(toTarget);
                    // sample local wind, gently steer
                    const w = AppState.windField ? AppState.windField.getAt(b.position.x, Math.max(1, b.position.y), b.position.z) : {x:0,z:0};
                    v.x += (w.x || 0) * 0.02;
                    v.z += (w.z || 0) * 0.02;
                    // clamp
                    v.x = Math.max(-0.6, Math.min(0.6, v.x));
                    v.y = Math.max(-0.2, Math.min(0.2, v.y));
                    v.z = Math.max(-0.6, Math.min(0.6, v.z));
                    b.position.addScaledVector(v, dt * 0.06);
                    // simple banking/rotation
                    b.lookAt(b.position.x + v.x*8, b.position.y + v.y*6, b.position.z + v.z*8);
                }
            }
            dispose() {
                this.group.traverse(o=>{ if (o.geometry) try{o.geometry.dispose();}catch(e){} if (o.material) try{o.material.dispose();}catch(e){} });
                try{ AppState.scene.remove(this.group); }catch(e){}
            }
        }

        // NEW: RainFog system ‚Äî low, screen-space/faux volumetric fog that increases with precipitation intensity
        class RainFog {
            constructor() {
                this.group = new THREE.Group();
                this.domes = []; // active fog domes
                this.maxDomes = 6;
                this.t = 0;
                AppState.scene.add(this.group);
            }

            sampleIntensity() {
                // approximate precipitation intensity by sampling rainSystem active drops
                if (!AppState.rainSystem) return 0;
                let active = 0;
                const max = AppState.rainSystem.max || 2500;
                for (let i = 0; i < Math.min(800, max); i += 12) {
                    if (AppState.rainSystem.drops && AppState.rainSystem.drops[i] && AppState.rainSystem.drops[i].active) active++;
                }
                return Math.min(1, active / 10); // normalize to 0..1
            }

            update(t) {
                this.t = t;
                if (!Graphics.rainFog) {
                    // fade out domes
                    for (const d of this.domes) {
                        if (d.material) d.material.opacity *= 0.88;
                    }
                    this.domes = this.domes.filter(d => !d.material || d.material.opacity > 0.01);
                    return;
                }

                const intensity = this.sampleIntensity();
                const sources = (AppState.cloudSystem && AppState.cloudSystem.getPrecipSources) ? AppState.cloudSystem.getPrecipSources() : (AppState.cloudSystem ? AppState.cloudSystem.getMature() : []);
                
                // maintain domes over active precipitation areas
                const desiredDomes = Math.max(0, Math.floor(this.maxDomes * Math.min(1, intensity * 1.8)));
                
                // remove excess domes
                while (this.domes.length > desiredDomes) {
                    const old = this.domes.pop();
                    if (old && old.parent) this.group.remove(old);
                    if (old && old.geometry) old.geometry.dispose();
                    if (old && old.material) old.material.dispose();
                }

                // update or create domes
                for (let i = 0; i < desiredDomes; i++) {
                    let dome = this.domes[i];
                    if (!dome && sources.length > 0) {
                        dome = this._createDome();
                        this.domes[i] = dome;
                        this.group.add(dome);
                    }
                    
                    if (dome && sources.length > i) {
                        const source = sources[i];
                        // position dome at rain source
                        dome.position.set(source.x, 1.2, source.z);
                        
                        // scale dome radius to cloud footprint
                        const radius = Math.max(8, (source.radius || 6) * (source.horizontalSpread || 1.0) * 1.6);
                        dome.scale.set(radius / 10, 3.5, radius / 10); // dome height ~ 3-4 units, scaled horizontally
                        
                        // opacity based on local intensity and condensation level
                        const local = Math.min(1, intensity * (source.condensationLevel || 0.5) * (Graphics.rainIntensity || 1.0) * 1.8);
                        dome.material.opacity = Math.min(0.92, 0.04 + local * 0.65);
                        
                        // gentle animation: bobbing and breathing
                        dome.position.y += Math.sin(t * 0.0005 + i) * 0.2;
                        dome.scale.y *= 0.98 + Math.sin(t * 0.0004 + i * 0.5) * 0.06;
                    }
                }
            }

            _createDome() {
                // Create a hemispherical mesh (dome shape) that will cover the rain area
                const geoSphere = new THREE.IcosahedronGeometry(10, 3);
                // keep only top hemisphere by filtering vertices
                const posAttr = geoSphere.attributes.position;
                const positions = posAttr.array;
                // cut to hemisphere by setting bottom points to top (creates dome illusion)
                for (let i = 0; i < positions.length; i += 3) {
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = Math.abs(positions[i + 1]); // flip negative Y to positive (dome top)
                    }
                }
                posAttr.needsUpdate = true;
                geoSphere.computeVertexNormals();

                const mat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(0xb8d4e8),
                    transparent: true,
                    opacity: 0.0,
                    depthWrite: false,
                    blending: THREE.NormalBlending,
                    side: THREE.DoubleSide,
                    emissive: new THREE.Color(0x4a6a8a),
                    emissiveIntensity: 0.08
                });

                const dome = new THREE.Mesh(geoSphere, mat);
                dome.castShadow = false;
                dome.receiveShadow = false;
                dome.frustumCulled = false;
                return dome;
            }

            dispose() {
                this.domes.forEach(d => {
                    if (d.geometry) try { d.geometry.dispose(); } catch(e){}
                    if (d.material) try { d.material.dispose(); } catch(e){}
                });
                try { this.group.traverse(o => {
                    if (o.geometry) o.geometry.dispose();
                    if (o.material) o.material.dispose();
                }); this.group.parent.remove(this.group); } catch(e){}
            }
        }

        // Tornado system: attaches to supercell clouds and injects strong rotating inflow/outflow winds
        class TornadoSystem {
            constructor(windFieldRef, cloudSystemRef) {
                this.windField = windFieldRef;
                this.cloudSystem = cloudSystemRef;
                this.tornadoes = [];
                this.cooldown = 0;
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }

            spawnFromCloud(cloud) {
                // simplified and safer spawning: require strong supercell but reduce particle load and make vortex leaner
                if (!cloud || cloud.stage !== 'supercell' || cloud.dying) return;
                // require significant vertical extent and mass
                const cloudVerticalExtent = Math.max(0, (cloud.cloudTop || cloud.height) - (cloud.cloudBase || (cloud.height - 8)));
                if (cloudVerticalExtent < 12 || cloud.mass < 6.5 || cloud.condensationLevel < 0.5) return;

                const existing = this.tornadoes.find(t => t.cloud === cloud);
                if (existing) return;

                const baseRadius = 2.5 + Math.random() * 3.0;
                const height = Math.max(18, cloud.cloudTop - cloud.cloudBase + 4);

                // lightweight spiral particles (fewer, coherent)
                const debrisCount = 140;
                const dGeo = new THREE.BufferGeometry();
                const dPos = new Float32Array(debrisCount * 3);
                const dVel = new Float32Array(debrisCount * 3);
                for (let i = 0; i < debrisCount; i++) {
                    const hFrac = Math.random();
                    const r = (0.2 + (1 - hFrac) * 0.9) * baseRadius * (0.6 + Math.random() * 1.2);
                    const ang = Math.random() * Math.PI * 2;
                    dPos[i*3] = Math.cos(ang) * r;
                    dPos[i*3+1] = 0.6 + hFrac * height;
                    dPos[i*3+2] = Math.sin(ang) * r;
                    const tangential = 0.02 + (1 - hFrac) * 0.12;
                    const downward = 0.006 + hFrac * 0.02;
                    dVel[i*3] = -Math.sin(ang) * tangential;
                    dVel[i*3+1] = -downward;
                    dVel[i*3+2] = Math.cos(ang) * tangential;
                }
                dGeo.setAttribute('position', new THREE.BufferAttribute(dPos, 3));
                dGeo.setAttribute('velocity', new THREE.BufferAttribute(dVel, 3));
                const dMat = new THREE.PointsMaterial({
                    size: 0.36,
                    color: 0x88b8c8,
                    transparent: true,
                    opacity: 0.85,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                const debris = new THREE.Points(dGeo, dMat);
                const container = new THREE.Group();
                container.add(debris);
                container.position.set(cloud.x, 0, cloud.z);
                this.group.add(container);

                const tornado = {
                    cloud,
                    obj: container,
                    debris,
                    baseRadius,
                    height,
                    life: 900 + Math.random() * 900,
                    maxLife: 900 + Math.random() * 900,
                    strength: 9 + Math.random() * 8,
                    spinSign: Math.random() > 0.5 ? 1 : -1
                };
                this.tornadoes.push(tornado);
                // small camera nudge
                AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, 1.1);
                AppState.cameraControls.shake.duration = 850;
                AppState.cameraControls.shake.time = 0;
            }

            applyToWind(tornado) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const rMax = Math.min(140, tornado.baseRadius * 5.0);
                const x0 = tornado.obj.position.x;
                const z0 = tornado.obj.position.z;
                const strength = tornado.strength;

                for (let gx = 0; gx < size; gx++) {
                    for (let gy = 0; gy < Math.min(size, 10); gy++) {
                        for (let gz = 0; gz < size; gz++) {
                            const wx = (gx - size / 2) * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const dx = wx - x0;
                            const dz = wz - z0;
                            const dist = Math.hypot(dx, dz);
                            if (dist > rMax || dist < 0.001) continue;
                            const inv = 1 / (dist + 0.0001);
                            const ux = dx * inv;
                            const uz = dz * inv;
                            const tx = -uz;
                            const tz = ux;
                            const core = Math.max(0, 1 - (dist / rMax) ** 1.2);
                            const verticalFactor = 1 + (gy / Math.max(1, Math.min(12, size))) * 1.2;
                            const inflow = strength * 0.8 * core;
                            const spin = strength * 0.9 * core * tornado.spinSign;
                            const cell = this.windField.field[gx][gy][gz];
                            cell.x += (-ux * inflow + tx * spin) * 0.12 * verticalFactor;
                            cell.z += (-uz * inflow + tz * spin) * 0.12 * verticalFactor;
                            cell.__updraft = (cell.__updraft || 0) + core * 0.14 * verticalFactor;
                            cell.__vortex = (cell.__vortex || 0) + spin * 0.006 * (1 + (10 - gy) * 0.03);
                        }
                    }
                }
            }

            update(t) {
                if (!this.cloudSystem) return;
                if (this.cooldown > 0) this.cooldown--;
                if (this.cooldown === 0) {
                    const candidates = this.cloudSystem.clouds.filter(c => c.stage === 'supercell' && !c.dying && c.mass > 6.8);
                    if (candidates.length > 0 && Math.random() < 0.0035) {
                        const c = candidates[Math.floor(Math.random() * candidates.length)];
                        this.spawnFromCloud(c);
                        this.cooldown = 1200 + Math.floor(Math.random() * 900);
                    }
                }
                for (let i = this.tornadoes.length - 1; i >= 0; i--) {
                    const tno = this.tornadoes[i];
                    const cloud = tno.cloud;
                    if (cloud && !cloud.dying) {
                        const targetX = cloud.x;
                        const targetZ = cloud.z;
                        tno.obj.position.x += (targetX - tno.obj.position.x) * 0.08;
                        tno.obj.position.z += (targetZ - tno.obj.position.z) * 0.08;
                    }
                    tno.obj.rotation.y += 0.028 * tno.spinSign;
                    // update debris spiral
                    const posAttr = tno.debris.geometry.attributes.position;
                    const velAttr = tno.debris.geometry.attributes.velocity;
                    const p = posAttr.array;
                    const v = velAttr.array;
                    const count = p.length / 3;
                    for (let j = 0; j < count; j++) {
                        const idx = j * 3;
                        p[idx]     += v[idx] * (0.98 + Math.random() * 0.03);
                        p[idx + 1] += v[idx + 1] * (0.98 + Math.random() * 0.03);
                        p[idx + 2] += v[idx + 2] * (0.98 + Math.random() * 0.03);
                        const r = Math.sqrt(p[idx]*p[idx] + p[idx+2]*p[idx+2]) + 0.0001;
                        const ang = Math.atan2(p[idx+2], p[idx]) + 0.085 * tno.spinSign;
                        const baseR = Math.min(tno.baseRadius * 1.3, r + 0.02);
                        p[idx] = Math.cos(ang) * (baseR * (0.85 + 0.14 * Math.random()));
                        p[idx+2] = Math.sin(ang) * (baseR * (0.85 + 0.14 * Math.random()));
                        if (p[idx+1] < 0.6) {
                            p[idx+1] = 0.8 + Math.random() * tno.height;
                        }
                    }
                    posAttr.needsUpdate = true;
                    this.applyToWind(tno);
                    tno.life--;
                    tno.debris.material.opacity = 0.2 + Math.max(0, tno.life / tno.maxLife) * 0.7;
                    if (tno.life <= 0 || (cloud && cloud.dying)) {
                        this.group.remove(tno.obj);
                        try { tno.debris.geometry.dispose(); } catch(e){}
                        try { tno.debris.material.dispose(); } catch(e){}
                        this.tornadoes.splice(i, 1);
                    }
                }
            }
        }

        // ENHANCED ELECTROSTATIC CHARGING with feedback to cloud properties
        class ElectrostaticSystem {
            constructor(cloudSystemRef, lightningSystemRef, atmosphereRef) {
                this.cloudSystem = cloudSystemRef;
                this.lightningSystem = lightningSystemRef;
                this.atmosphere = atmosphereRef;
                this._cloudCharge = new WeakMap();
                this.cloudCharges = this._cloudCharge;
                this.chargeHistory = [];
            }
            // Triboelectric charging: graupel/hail + ice crystal interactions
            computeChargeGeneration(cloud, graupelCount) {
                if (!cloud) return 0;
                // simplified: charge grows primarily in deep convective cores, scaled by mass and turbulence
                // increase base charging sensitivity so heavier precipitation produces more charge
                const base = cloud.mass * (cloud.condensationLevel || 0.3) * 0.08;
                const turbo = (cloud.turbulence || 0) * 0.6;
                // tornado proximity amplifies local separation a bit
                let tornadoBoost = 0;
                if (AppState.tornadoSystem && AppState.tornadoSystem.tornadoes) {
                    for (const t of AppState.tornadoSystem.tornadoes) {
                        if (!t || !t.obj) continue;
                        const d = Math.hypot(t.obj.position.x - cloud.x, t.obj.position.z - cloud.z);
                        if (d < 120) tornadoBoost += Math.max(0, 0.18 * (1 - d / 120));
                    }
                }
                const graupelBoost = Math.min(1.2, graupelCount * 0.0006);
                // stronger sensitivity to graupel and turbulence for robust charge generation
                const total = base * (1 + turbo * 1.4 + tornadoBoost * 1.2 + graupelBoost * 2.0);
                return total;
            }
            applyChargeEffects(cloud) {
                if (!cloud) return;
                const charge = Math.abs(this._cloudCharge.get(cloud) || 0);
                const chargeInfluence = Math.min(0.35, charge / 130);
                cloud.buoyancy = (cloud.buoyancy || 0.5) * (1 + chargeInfluence * 0.12);
                if (charge > 90 && Math.random() < 0.018) {
                    cloud.condensationLevel = Math.min(1.0, (cloud.condensationLevel || 0.5) + 0.06);
                }
            }
            update(t, precipSystem, graupelCount) {
                for (const cloud of this.cloudSystem.clouds || []) {
                    if (!cloud) continue;
                    // Only deep convective clouds accumulate strongly
                    if (cloud.stage !== 'cumulonimbus' && cloud.stage !== 'supercell') {
                        const prevZero = this._cloudCharge.get(cloud) || 0;
                        this._cloudCharge.set(cloud, prevZero * 0.94);
                        continue;
                    }
                    const delta = this.computeChargeGeneration(cloud, graupelCount);
                    const prev = this._cloudCharge.get(cloud) || 0;
                    const newCharge = prev * 0.95 + delta;
                    this._cloudCharge.set(cloud, newCharge);
                    this.applyChargeEffects(cloud);
                }
                // small leak to global lightning system
                let tot = 0;
                for (const c of this.cloudSystem.clouds) tot += Math.abs(this._cloudCharge.get(c) || 0);
                if (this.lightningSystem) this.lightningSystem.charge = Math.max(0, Math.min(1200, tot * 2.6));
            }
        }

        // New frontal & derecho systems
        class WarmFront {
            constructor(windField, cloudSystem) {
                this.windField = windField;
                this.cloudSystem = cloudSystem;
                this.fronts = []; // active warm fronts
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }
            spawn(x, z, length = 180, speed = 0.06, tilt = 0.15) {
                const f = {
                    x, z, length, speed, tilt, age: 0, maxAge: 3600,
                    group: new THREE.Group(),
                    linePoints: []
                };
                // visual ribbon -> create a clear linear line oriented east-west by default
                const seg = Math.max(8, Math.floor(length / 12));
                const geo = new THREE.BufferGeometry();
                const positions = new Float32Array((seg + 1) * 3);
                for (let i = 0; i <= seg; i++) {
                    const t = i / seg;
                    positions[i * 3] = (t - 0.5) * length;
                    positions[i * 3 + 1] = 12 + tilt * 6 * Math.sin(t * Math.PI);
                    positions[i * 3 + 2] = 0;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const mat = new THREE.LineBasicMaterial({ color: 0xffe3b8, transparent: true, opacity: 0.22 });
                const line = new THREE.Line(geo, mat);
                // orient and position the line so it behaves as a coherent frontal band
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 14, z);
                f.group.add(line);
                f.line = line;
                this.group.add(f.group);
                this.fronts.push(f);
                return f;
            }
            applyToWind(f) {
                // gentle lift ahead of warm front, steering low-level winds along the front axis
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const frontVec = new THREE.Vector3(1, 0, 0); // east-west axis for a coherent linear front
                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        // transform into front-local coords
                        const dx = wx - f.x;
                        const dz = wz - f.z;
                        const along = dx; // east-west alignment
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const influence = Math.max(0, 1 - dist / (f.length * 0.9));
                        if (influence > 0.01) {
                            for (let gy = 0; gy < Math.min(6, size); gy++) {
                                const cell = this.windField.field[gx][gy][gz];
                                // push along-front with slight lift ahead of front
                                cell.x += 0.025 * influence * (along * 0.0005 + 0.3);
                                cell.z += 0.012 * influence * (-(dz) * 0.0004 + 0.1);
                                cell.__updraft = (cell.__updraft || 0) + 0.0026 * influence * (1 + (6 - gy) * 0.08);
                            }
                        }
                    }
                }
            }
            update(t) {
                for (let i = this.fronts.length - 1; i >= 0; i--) {
                    const f = this.fronts[i];
                    f.age++;
                    // propagate the front forward using its speed (east-northeast)
                    f.x += f.speed * 12;
                    f.z += f.speed * 6 * 0.35;
                    // adjust visual vertical undulation to make a coherent shelf
                    if (f.line && f.line.geometry && f.line.geometry.attributes.position) {
                        const attr = f.line.geometry.attributes.position.array;
                        const seg = Math.floor(attr.length / 3) - 1;
                        for (let j = 0; j <= seg; j++) {
                            const t = j / seg;
                            attr[j * 3 + 1] = 10 + Math.sin((t + f.age * 0.002) * Math.PI * 2) * 0.6;
                        }
                        f.line.geometry.attributes.position.needsUpdate = true;
                        f.line.position.set(f.x, 12, f.z);
                    }
                    // apply to windfield to lift and encourage stratiform cloud formation ahead of front
                    this.applyToWind(f);
                    // spawn shelf-like cloud band: encourage the cloudSystem to create broad layered puffs along line
                    if (f.age % 40 === 0) {
                        const seg = Math.max(6, Math.floor(f.length / 30));
                        for (let s = 0; s < seg; s++) {
                            const tpos = (s / seg - 0.5) * f.length;
                            const cx = f.x + tpos + (Math.random() - 0.5) * 8;
                            const cz = f.z + (Math.random() - 0.5) * 6;
                            const c = this.cloudSystem.grow(cx, cz);
                            if (c) {
                                c.baseHeight = 10 + Math.random() * 6;
                                c.growthRate *= 0.6;
                                c.widthFactor *= 1.6;
                            }
                        }
                    }
                    if (f.age > f.maxAge) {
                        f.group.traverse(obj => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.group.remove(f.group);
                        this.fronts.splice(i, 1);
                    }
                }
            }
        }

        class ColdFront {
            constructor(windField, cloudSystem) {
                this.windField = windField;
                this.cloudSystem = cloudSystem;
                this.fronts = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
            }
            spawn(x, z, length = 140, speed = 0.18, steepness = 1.2) {
                const f = {
                    x, z, length, speed, steepness, age: 0, maxAge: 2400,
                    group: new THREE.Group()
                };
                // shelf cloud visualization (broad linear shelf)
                const seg = Math.max(6, Math.floor(length / 18));
                const planeGeo = new THREE.PlaneGeometry(length, 8, seg, 1);
                const verts = planeGeo.attributes.position.array;
                for (let i = 0; i < verts.length; i += 3) {
                    verts[i + 1] = 6 + Math.random() * 2 + Math.sin(i * 0.02) * 0.8;
                }
                planeGeo.attributes.position.needsUpdate = true;
                const mat = new THREE.MeshLambertMaterial({ color: 0xb5c7d6, transparent: true, opacity: 0.78, depthWrite: false });
                const mesh = new THREE.Mesh(planeGeo, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(x, 14, z);
                f.group.add(mesh);
                f.shelf = mesh;
                this.group.add(f.group);
                this.fronts.push(f);
                return f;
            }
            applyToWind(f) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        const dx = wx - f.x;
                        const dz = wz - f.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const influence = Math.max(0, 1 - dist / (f.length * 0.7));
                        if (influence > 0.02) {
                            for (let gy = 0; gy < Math.min(6, size); gy++) {
                                const cell = this.windField.field[gx][gy][gz];
                                const push = f.speed * 0.7 * influence;
                                // stronger organized push orthogonal to shelf to create narrow towering convection behind it
                                const dirx = dx / (dist + 0.0001);
                                const dirz = dz / (dist + 0.0001);
                                cell.x += -dirx * push * 0.6;
                                cell.z += -dirz * push * 0.6;
                                cell.__downburst = (cell.__downburst || 0) + 0.004 * influence * (1 + (6 - gy) * 0.08);
                            }
                        }
                    }
                }
            }
            update(t) {
                for (let i = this.fronts.length - 1; i >= 0; i--) {
                    const f = this.fronts[i];
                    f.age++;
                    // faster progression
                    f.x += f.speed * 20;
                    f.z += f.speed * 6;
                    // wobble shelf mesh and lower it slightly to convey gust
                    if (f.shelf && f.shelf.geometry) {
                        f.shelf.position.y = 12 + Math.sin(t * 0.0008 + f.age * 0.01) * 1.2;
                        f.shelf.rotation.z = Math.sin(f.age * 0.004) * 0.06;
                        f.shelf.position.set(f.x, f.shelf.position.y, f.z);
                    }
                    // apply to winds and encourage narrow towering convection immediately behind front
                    this.applyToWind(f);
                    if (f.age % 18 === 0) {
                        const bx = f.x - (10 + Math.random() * 12);
                        const bz = f.z + (Math.random() - 0.5) * 8;
                        const c = this.cloudSystem.grow(bx, bz);
                        if (c) {
                            c.baseHeight = 14 + Math.random() * 6;
                            c.growthRate *= 1.8;
                            c.widthFactor *= 0.6;
                            c.turbulence = Math.max(c.turbulence, 0.6);
                        }
                    }
                    if (f.age > f.maxAge) {
                        f.group.traverse(obj => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.group.remove(f.group);
                        this.fronts.splice(i, 1);
                    }
                }
            }
        }

        class DerechoSystem {
            constructor(windField, cloudSystem, rainSystem) {
                this.windField = windField;
                this.cloudSystem = cloudSystem;
                this.rainSystem = rainSystem;
                this.events = [];
                this.group = new THREE.Group();
                AppState.scene.add(this.group);
                this.cooldown = 0;
            }
            trySpawnFromClusters() {
                // occasionally organize a powerful linear convective system from mature clusters
                if (this.cooldown > 0) { this.cooldown--; return; }
                const mature = this.cloudSystem.getMature();
                if (mature.length < 3) return;
                // if several mature clouds line up roughly, spawn derecho
                if (Math.random() < 0.003) {
                    // choose a cluster of mature clouds and form a linear band roughly along their centroid
                    const sample = [];
                    const center = { x: 0, z: 0 };
                    for (let i = 0; i < Math.min(6, mature.length); i++) {
                        const c = mature[Math.floor(Math.random() * mature.length)];
                        sample.push(c);
                        center.x += c.x; center.z += c.z;
                    }
                    center.x /= sample.length; center.z /= sample.length;
                    // orient band along the major axis of the sampled clouds
                    let sx = -1e9, lx = 1e9;
                    sample.forEach(c => { sx = Math.min(sx, c.x); lx = Math.max(lx, c.x); });
                    const length = Math.max(200, Math.min(420, Math.abs(lx - sx) + 160));
                    this.spawn(center.x - length*0.5, center.z, length, 10 + Math.random() * 18);
                    this.cooldown = 2400 + Math.floor(Math.random() * 2000);
                }
            }
            spawn(x, z, length = 240, strength = 14) {
                const ev = {
                    x, z, length, strength, life: 900 + Math.floor(Math.random() * 800), maxLife: 900 + Math.floor(Math.random() * 800),
                    group: new THREE.Group()
                };
                // visual: long translucent band oriented east-west for coherence
                const geo = new THREE.PlaneGeometry(length, 18, Math.max(4, Math.floor(length/20)), 1);
                const attr = geo.attributes.position.array;
                for (let i = 0; i < attr.length; i += 3) {
                    attr[i + 1] = 6 + (Math.random() - 0.5) * 1.2;
                }
                geo.attributes.position.needsUpdate = true;
                const mat = new THREE.MeshBasicMaterial({ color: 0x9fbfdc, transparent: true, opacity: 0.24, side: THREE.DoubleSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2;
                // place and anchor the mesh so it appears as a linear east-west moving derecho core
                mesh.position.set(x + length * 0.5, 14, z);
                ev.group.add(mesh);
                this.group.add(ev.group);
                this.events.push(ev);
                // immediate strong wind perturbation and potential downburst line
                this.applyToWind(ev);
            }
            applyToWind(ev) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const r = ev.length * 0.6;
                for (let gx = 0; gx < size; gx++) {
                    for (let gz = 0; gz < size; gz++) {
                        const wx = (gx - size / 2) * spacing;
                        const wz = (gz - size / 2) * spacing;
                        const dx = wx - ev.x;
                        const dz = wz - ev.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const influence = Math.max(0, 1 - dist / r);
                        if (influence > 0.02) {
                            for (let gy = 0; gy < Math.min(6, size); gy++) {
                                const cell = this.windField.field[gx][gy][gz];
                                // push strongly along eastward axis to mimic derecho straight-line winds
                                cell.x += ev.strength * 0.025 * influence;
                                cell.z += ev.strength * 0.009 * influence;
                                cell.__downburst = (cell.__downburst || 0) + 0.018 * influence * (1 + (6 - gy) * 0.12);
                            }
                        }
                    }
                }
            }
            update(t) {
                // try to spawn occasionally based on clusters
                this.trySpawnFromClusters();
                for (let i = this.events.length - 1; i >= 0; i--) {
                    const ev = this.events[i];
                    ev.life--;
                    // progress movement to the east/south-east
                    ev.x += 0.28;
                    ev.z += 0.05;
                    // visual breathing
                    ev.group.children.forEach(c => {
                        if (c.geometry && c.geometry.attributes.position) {
                            const arr = c.geometry.attributes.position.array;
                            for (let j = 0; j < arr.length; j += 3) {
                                arr[j + 1] = 5 + Math.sin(t * 0.0012 + j) * 0.8;
                            }
                            c.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                    // apply to wind field continuously and spawn linear precipitation
                    this.applyToWind(ev);
                    // spawn concentrated precipitation along the core line to create derecho rain/wind effects
                    if (this.rainSystem && ev.life % 6 === 0) {
                        const steps = Math.max(6, Math.floor(ev.length / 30));
                        for (let s = 0; s < steps; s++) {
                            const px = ev.x + (s / steps - 0.5) * ev.length + (Math.random() - 0.5) * 6;
                            const pz = ev.z + (Math.random() - 0.5) * 8;
                            // create a brief, intense cloud to source rain if none near
                            const c = this.cloudSystem.grow(px, pz);
                            if (c) {
                                c.baseHeight = 16 + Math.random() * 6;
                                c.mass += 1.2 * (ev.strength / 12);
                                c.condensationLevel = Math.min(1, c.condensationLevel + 0.15);
                                // spawn multiple raindrops from this transient enhancement
                                for (let k = 0; k < 5; k++) this.rainSystem.spawn(c);
                            }
                        }
                    }
                    if (ev.life <= 0) {
                        ev.group.traverse(o => { if (o.geometry) o.geometry.dispose(); if (o.material) o.material.dispose(); });
                        this.group.remove(ev.group);
                        this.events.splice(i, 1);
                    }
                }
            }
        }

        function setupControls() {
            // Mouse controls
            // Use Pointer Events for consistent mouse & touch drag handling on the renderer canvas
            const canvas = AppState.renderer.domElement;
            canvas.style.touchAction = 'none'; // prevent browser gestures interfering

            canvas.addEventListener('pointerdown', (e) => {
                // only handle primary button
                if (e.pointerType === 'mouse' && e.button !== 0) return;
                canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
                AppState.cameraControls.isDrag = true;
                AppState.cameraControls.prevMouse = { x: e.clientX, y: e.clientY };
                // optional pointer lock suggestion when in FP mode
                if (AppState.firstPerson && document.body.requestPointerLock) {
                    try { document.body.requestPointerLock(); } catch (err) {}
                }
            });

            canvas.addEventListener('pointermove', (e) => {
                if (!AppState.cameraControls.isDrag) return;
                const dx = e.clientX - AppState.cameraControls.prevMouse.x;
                const dy = e.clientY - AppState.cameraControls.prevMouse.y;
                AppState.cameraControls.rotation.theta -= dx * 0.03;
                AppState.cameraControls.rotation.phi -= dy * 0.02;
                AppState.cameraControls.rotation.phi = Math.max(0.08, Math.min(Math.PI / 2.2, AppState.cameraControls.rotation.phi));
                AppState.cameraControls.prevMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('pointerup', (e) => {
                canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
                AppState.cameraControls.isDrag = false;
                if (document.exitPointerLock) try { document.exitPointerLock(); } catch (err) {}
            });
            canvas.addEventListener('pointercancel', (e) => {
                canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
                AppState.cameraControls.isDrag = false;
            });

            // Touch controls (orbit/look handled via joystick below)
            AppState.renderer.domElement.addEventListener('touchstart', e => {
                // prevent default handled per listeners when needed
            });

            // Keyboard controls for FPS movement and GUI
            // reuse the global keys object so animate() can access keyboard state
            const keys = window.keys;
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;

                // toggle GUI with H
                if (e.key === 'h' || e.key === 'H') {
                    AppState.showGui = !AppState.showGui;
                    document.body.classList.toggle('ui-collapsed', !AppState.showGui);
                    ['stats', 'controls', 'info', 'graphics'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.setAttribute('aria-hidden', String(!AppState.showGui));
                    });
                    document.getElementById('toggle-gui').textContent = AppState.showGui ? 'üëÅÔ∏è Hide UI' : 'üëÅÔ∏è Show UI';
                }
            });
            window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

            // WASD movement loop integrated into animation (values persisted) ‚Äî orbit only (no FP movement)
            function updateKeyboardMovement() {
                const ctrl = AppState.cameraControls;
                ctrl.move.forward = 0;
                ctrl.move.right = 0;
                let speed = ctrl.speed;
                if (keys['shift']) speed *= ctrl.runMultiplier;
                if (keys['w']) ctrl.move.forward += 1;
                if (keys['s']) ctrl.move.forward -= 1;
                if (keys['a']) ctrl.move.right -= 1;
                if (keys['d']) ctrl.move.right += 1;
                // No first-person movement ‚Äî WASD inert in orbit view (can be repurposed later)
                requestAnimationFrame(updateKeyboardMovement);
            }
            updateKeyboardMovement();

            // toggle GUI via button dispatch (keeps semantics)
            // direct GUI toggle so it's reliable across environments
            document.getElementById('toggle-gui').addEventListener('click', () => {
                AppState.showGui = !AppState.showGui;
                document.body.classList.toggle('ui-collapsed', !AppState.showGui);
                ['stats', 'controls', 'info', 'graphics'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.setAttribute('aria-hidden', String(!AppState.showGui));
                    if (el) el.classList.toggle('hidden', !AppState.showGui);
                });
                document.getElementById('toggle-gui').textContent = AppState.showGui ? 'üëÅÔ∏è Hide UI' : 'üëÅÔ∏è Show UI';
            });

            // Pause button
            const pauseBtn = document.getElementById('pause-btn');
            pauseBtn.addEventListener('click', () => {
                AppState.paused = !AppState.paused;
                pauseBtn.textContent = AppState.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
            });

            // make Controls panel closable: add close button to controls panel (kept but now only hides controls panel)
            (function addControlsClose() {
                const controlsEl = document.getElementById('controls');
                if (!controlsEl) return;
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.title = 'Close';
                closeBtn.style.position = 'absolute';
                closeBtn.style.top = '8px';
                closeBtn.style.right = '8px';
                closeBtn.style.width = '30px';
                closeBtn.style.height = '30px';
                closeBtn.style.borderRadius = '6px';
                closeBtn.style.border = '1px solid rgba(255,255,255,0.08)';
                closeBtn.style.background = 'rgba(0,0,0,0.5)';
                closeBtn.style.color = 'white';
                closeBtn.style.cursor = 'pointer';
                controlsEl.appendChild(closeBtn);

                // toggle via close button (hide) and add a small reopen button
                closeBtn.addEventListener('click', () => {
                    controlsEl.classList.add('hidden');
                    // create reopen button if not present
                    if (!document.getElementById('reopen-controls')) {
                        const btn = document.createElement('button');
                        btn.id = 'reopen-controls';
                        btn.textContent = 'Controls';
                        document.body.appendChild(btn);
                        btn.addEventListener('click', () => {
                            controlsEl.classList.remove('hidden');
                            btn.remove();
                        });
                    }
                });
            })();
        }

        // ATMOSPHERIC LAYERS SYSTEM: Models temperature, pressure, and environmental properties at different altitudes
        class AtmosphericLayers {
            constructor() {
                this.layers = [
                    { altitude: 0, name: 'surface', tempBase: 15, tempLapse: -6.5, humidityBase: 0.7, pressureKPa: 101.325 },
                    { altitude: 2, name: 'boundary', tempBase: 12, tempLapse: -5.8, humidityBase: 0.65, pressureKPa: 79.5 },
                    { altitude: 6, name: 'lower-tropos', tempBase: 3, tempLapse: -6.2, humidityBase: 0.55, pressureKPa: 48.2 },
                    { altitude: 12, name: 'mid-tropos', tempBase: -10, tempLapse: -6.5, humidityBase: 0.4, pressureKPa: 19.4 },
                    { altitude: 18, name: 'upper-tropos', tempBase: -30, tempLapse: -5.2, humidityBase: 0.25, pressureKPa: 7.6 }
                ];
                this.baseTime = performance.now();
                this.diurnalCycle = 0;
                this.precipCooling = new Map(); // track cooling per altitude layer
            }
            getSoundSpeed(altitude) {
                const temp = this.getTemperature(altitude);
                return Math.sqrt(331.3 + 0.606 * temp); // m/s
            }
            getTemperature(altitude) {
                let temp = 15 + (window.DayNight ? window.DayNight.tempOffset || 0 : 0);
                temp -= (altitude / 1000) * 6.5;
                // diurnal variation (stronger near surface)
                const diurnalAmp = Math.max(0, 1 - altitude / 40) * 4;
                temp += Math.sin(this.diurnalCycle * Math.PI * 2) * diurnalAmp;
                // NEW: precipitation cooling effect - colder where heavy rain falls
                const key = Math.floor(altitude);
                const cooling = this.precipCooling.get(key) || 0;
                temp -= cooling * 0.08; // cooling reduces temperature up to 0.8¬∞C per unit intensity
                return temp;
            }
            getPressure(altitude) {
                const sea = 101.325;
                const tempAvg = (this.getTemperature(0) + this.getTemperature(altitude)) / 2 + 273.15;
                return sea * Math.exp(-9.81 * altitude * 1000 / (287 * tempAvg));
            }
            getHumidity(altitude) {
                let h = 0.7 - (altitude / 40) * 0.65; // decrease with altitude
                h *= 0.8 + 0.2 * Math.sin(this.diurnalCycle * Math.PI * 2);
                return Math.max(0.05, Math.min(1, h));
            }
            // NEW: accumulate precipitation cooling effect
            addPrecipCooling(altitude, intensity) {
                const key = Math.floor(altitude);
                const prev = this.precipCooling.get(key) || 0;
                this.precipCooling.set(key, prev + intensity * 0.3);
            }
            update(deltaMs) {
                this.diurnalCycle = (this.diurnalCycle + deltaMs / 86400000) % 1;
                // decay cooling over time
                for (const [key, val] of this.precipCooling) {
                    this.precipCooling.set(key, val * 0.96);
                    if (val < 0.01) this.precipCooling.delete(key);
                }
            }
            // CAPE: Convective Available Potential Energy (proxy for updraft strength)
            computeCALE(cloudBase, cloudTop) {
                const temp_base = this.getTemperature(cloudBase) + 273.15;
                const temp_top = this.getTemperature(cloudTop) + 273.15;
                const envTemp_mid = (this.getTemperature(cloudBase) + this.getTemperature(cloudTop)) / 2 + 273.15;
                const lapseCond = 6.5; // moist adiabatic lapse rate
                const buoyancy = ((temp_base - envTemp_mid) / envTemp_mid) * 9.81;
                const depth = (cloudTop - cloudBase) * 1000; // convert to meters
                return Math.max(0, buoyancy * depth * 0.5); // proxy CAPE
            }
        }

        // WIND SHEAR & HELICITY SYSTEM
        class WindShearSystem {
            constructor(windFieldRef) {
                this.windField = windFieldRef;
                this.shearLayers = [];
            }
            // compute 0-6km wind shear (proxy)
            computeShear(x, z) {
                const w_low = this.windField.getAt(x, 1, z);
                const w_high = this.windField.getAt(x, 6, z);
                const shear = Math.sqrt((w_high.x - w_low.x)**2 + (w_high.z - w_low.z)**2);
                return shear * 0.25; // scale to meaningful units
            }
            // Storm-relative helicity (SRH) - measure of rotation potential
            computeSRH(cloudX, cloudZ, cloudBase, cloudTop) {
                let srh = 0;
                const steps = 6;
                for (let i = 0; i < steps; i++) {
                    const alt = cloudBase + (cloudTop - cloudBase) * i / steps;
                    const w = this.windField.getAt(cloudX, alt, cloudZ);
                    const perp_x = -w.z;
                    const perp_z = w.x;
                    // relative vorticity from wind shear (rough approximation)
                    const vorticityMagnitude = Math.sqrt(perp_x*perp_x + perp_z*perp_z) * 0.05;
                    srh += vorticityMagnitude;
                }
                return srh / steps;
            }
            // apply wind shear to cloud rotation/tilt
            applyShearToCloud(cloud, shearMagnitude) {
                if (!cloud) return;
                // stronger shear tilts cloud and can promote rotating updraft
                cloud.tilt = (cloud.tilt || 0) + shearMagnitude * 0.002;
                cloud.rotationRate = (cloud.rotationRate || 0) + shearMagnitude * 0.008;
            }
        }

        // HAIL/GRAUPEL GROWTH SYSTEM
        class HailGrowelSystem {
            constructor(precipSystemRef, atmosphereRef) {
                this.precipSystem = precipSystemRef;
                this.atmosphere = atmosphereRef;
                this.hailstones = []; // separate tracking for hail
                this.maxHail = 400;
                this.hailIndices = []; // indices into precipitation system that are hail
            }
            // promote a raindrop to graupel/hail if conditions allow (supercooled water + ice nuclei)
            promoteToHail(dropIndex, temperature, altitude, cloudTop) {
                // allow more aggressive promotion when strong deep convection present
                if (this.hailIndices.length >= this.maxHail) return false;
                // hail/graupel most likely in a broad mid-layer; relax altitude bounds slightly for simulation
                if (altitude < 4 || altitude > cloudTop + 6) return false;
                // require supercooled temps but widen acceptable range slightly
                if (temperature > -2 || temperature < -40) return false;
                // higher base probability when precipitation quality/size is favorable
                const baseProb = 0.06 + Math.min(0.42, (this.precipSystem.quality[dropIndex] || 0.9) * 0.12) + Math.min(0.35, (this.precipSystem.size[dropIndex] || 0.8) * 0.08);
                if (Math.random() > baseProb) return false;
                // tag as graupel/hail seed
                this.hailIndices.push(dropIndex);
                this.precipSystem.size[dropIndex] = Math.max(0.9, this.precipSystem.size[dropIndex] * (1.2 + Math.random() * 0.6));
                this.precipSystem.type[dropIndex] = 'graupel';
                this.precipSystem.quality[dropIndex] = Math.max(0.9, (this.precipSystem.quality[dropIndex] || 1.0) * (1 + Math.random() * 0.45));
                return true;
            }
            // grow hail through collision with supercooled droplets
            growHail(hailIdx) {
                if (hailIdx < 0 || hailIdx >= this.precipSystem.max) return;
                const hsize = this.precipSystem.size[hailIdx];
                if (hsize < 0.9) return; // not large enough yet
                const hx = this.precipSystem.pos[hailIdx*3];
                const hy = this.precipSystem.pos[hailIdx*3+1];
                const hz = this.precipSystem.pos[hailIdx*3+2];
                const temp = this.atmosphere.getTemperature(hy);
                if (temp > -8) return; // too warm, no accretion
                // scan nearby drops for collision
                for (let j = 0; j < this.precipSystem.max; j++) {
                    if (j === hailIdx || !this.precipSystem.drops[j].active) continue;
                    if (this.precipSystem.type[j] !== 'rain' && this.precipSystem.type[j] !== 'sleet') continue;
                    const dx = hx - this.precipSystem.pos[j*3];
                    const dy = hy - this.precipSystem.pos[j*3+1];
                    const dz = hz - this.precipSystem.pos[j*3+2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < hsize * 0.4 + this.precipSystem.size[j] * 0.2) {
                        // collision: accrete small amount
                        const accretionMass = this.precipSystem.size[j] * 0.08 * (1 + (Math.abs(temp) / 25));
                        this.precipSystem.size[hailIdx] += accretionMass;
                        this.precipSystem.size[j] *= 0.88;
                        // increase density slightly
                        this.precipSystem.quality[hailIdx] = Math.min(2.0, (this.precipSystem.quality[hailIdx] || 1.0) + 0.12);
                        // if hail is very large, it may evolve to true hail (denser)
                        if (this.precipSystem.size[hailIdx] > 2.8) this.precipSystem.type[hailIdx] = 'hail';
                    }
                }

                // If hail becomes large while falling into populated areas, apply building damage and ground impacts
                if (this.precipSystem.type[hailIdx] === 'hail' && this.precipSystem.pos[hailIdx*3+1] < 6) {
                    const impactX = this.precipSystem.pos[hailIdx*3];
                    const impactZ = this.precipSystem.pos[hailIdx*3+2];
                    const impactRadius = Math.min(18, 3 + this.precipSystem.size[hailIdx] * 2.6);
                    // spawn visual debris / small craters (lightweight)
                    try {
                        if (AppState.scene) {
                            const cnt = Math.min(40, 12 + Math.floor(this.precipSystem.size[hailIdx] * 8));
                            const g = new THREE.BufferGeometry();
                            const arr = new Float32Array(cnt * 3);
                            for (let i = 0; i < cnt; i++) {
                                arr[i*3] = impactX + (Math.random()-0.5) * impactRadius * 1.2;
                                arr[i*3+1] = 0.6 + Math.random() * 1.2;
                                arr[i*3+2] = impactZ + (Math.random()-0.5) * impactRadius * 1.2;
                            }
                            g.setAttribute('position', new THREE.BufferAttribute(arr, 3));
                            const mat = new THREE.PointsMaterial({ size: 0.18 + Math.random()*0.32, color: 0x9fb0c8, transparent:true, opacity:0.9, depthWrite:false, blending: THREE.NormalBlending });
                            const p = new THREE.Points(g, mat);
                            p.userData = { life: 0.28 + Math.random()*0.4 };
                            AppState.scene.add(p);
                            (this._impactPool = this._impactPool || []).push(p);
                        }
                    } catch(e){}

                    // damage urban buildings in radius
                    if (AppState.urbanSystem && AppState.urbanSystem.cities) {
                        for (const city of AppState.urbanSystem.cities) {
                            for (let bi = city.buildings.length - 1; bi >= 0; bi--) {
                                const bmesh = city.buildings[bi];
                                if (!bmesh) continue;
                                const bx = bmesh.position.x + city.x;
                                const bz = bmesh.position.z + city.z;
                                const d = Math.hypot(bx - impactX, bz - impactZ);
                                if (d < impactRadius * 1.2 && Math.random() < Math.min(0.6, 0.24 + (this.precipSystem.size[hailIdx] - 2.8) * 0.14)) {
                                    try {
                                        // smash windows (darken and reduce emissive), dent roof (scale)
                                        if (bmesh.material) {
                                            bmesh.material.color.lerp(new THREE.Color(0x4a4040), 0.35);
                                            if (bmesh.material.emissive) bmesh.material.emissive.lerp(new THREE.Color(0x000000), 0.5);
                                        }
                                        bmesh.scale.y *= 0.96;
                                        if (Math.random() < 0.06) {
                                            city.group.remove(bmesh);
                                            city.buildings.splice(bi,1);
                                        }
                                    } catch(err){}
                                }
                            }
                        }
                    }
                }
            }
            update() {
                // update all tracked hail/graupel
                for (let i = this.hailIndices.length - 1; i >= 0; i--) {
                    const idx = this.hailIndices[i];
                    if (!this.precipSystem.drops[idx] || !this.precipSystem.drops[idx].active) {
                        this.hailIndices.splice(i, 1);
                        continue;
                    }
                    const alt = this.precipSystem.pos[idx*3+1];
                    const temp = this.atmosphere.getTemperature(alt);
                    // grow hail in supercooled layer
                    this.growHail(idx);
                    // hail melts rapidly if temperature rises above -5
                    if (temp > -5 && alt < 6) {
                        if (Math.random() < 0.08) {
                            this.precipSystem.type[idx] = 'rain';
                            this.hailIndices.splice(i, 1);
                        }
                    }
                }
            }
        }

        // CORIOLIS-LIKE EFFECT & LARGE-SCALE ROTATION
        class CoriolisSystem {
            constructor(windFieldRef, latitude = 40) {
                this.windField = windFieldRef;
                this.latitude = latitude * Math.PI / 180; // convert to radians
                this.f = 2 * 7.27e-5 * Math.sin(this.latitude); // Coriolis parameter
            }
            // apply Coriolis deflection to wind field over time (slow, large-scale)
            applyCoriolisToWind(dt) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                dt = dt * 0.00001; // slow application to avoid instability
                for (let gx = 0; gx < size; gx++) {
                    for (let gy = 0; gy < size; gy++) {
                        for (let gz = 0; gz < size; gz++) {
                            const cell = this.windField.field[gx][gy][gz];
                            const vx = cell.x;
                            const vz = cell.z;
                            // simple Coriolis deflection: f-effect rotates wind vector
                            const deflect = this.f * dt;
                            cell.x += vz * deflect;
                            cell.z -= vx * deflect;
                            // damp slightly to prevent runaway
                            cell.x *= 0.9998;
                            cell.z *= 0.9998;
                        }
                    }
                }
            }
        }

        // TURBULENCE CASCADE SYSTEM: Model turbulent kinetic energy at multiple scales
        class TurbulenceCascade {
            constructor(windFieldRef) {
                this.windField = windFieldRef;
                this.energyLevels = []; // kinetic energy at different scales
                this.dissipationRate = 0.85; // cascade dissipation per level
            }
            // inject turbulence at large scales (e.g., from convection)
            injectEnergy(x, z, altitude, energyAmount) {
                const size = this.windField.size;
                const spacing = this.windField.spacing;
                const gx = Math.floor((x / spacing) + size / 2);
                const gy = Math.floor(altitude / spacing);
                const gz = Math.floor((z / spacing) + size / 2);
                if (gx < 0 || gx >= size || gy < 0 || gy >= size || gz < 0 || gz >= size) return;
                const cell = this.windField.field[gx][gy][gz];
                const angle = Math.random() * Math.PI * 2;
                const ampl = Math.sqrt(energyAmount);
                cell.x += Math.cos(angle) * ampl * 0.05;
                cell.z += Math.sin(angle) * ampl * 0.05;
            }
            // cascade energy down from large to small scales
            updateCascade(dt) {
                dt = Math.min(dt, 0.016); // clamp per-frame update
                const size = this.windField.size;
                // Apply dissipation: cascade energy to finer scales with damping
                for (let gx = 0; gx < size; gx++) {
                    for (let gy = 0; gy < size; gy++) {
                        for (let gz = 0; gz < size; gz++) {
                            const cell = this.windField.field[gx][gy][gz];
                            const mag = Math.sqrt(cell.x*cell.x + cell.z*cell.z);
                            // dissipation increases with gradient
                            cell.x *= (0.92 - mag * 0.01);
                            cell.z *= (0.92 - mag * 0.01);
                        }
                    }
                }
            }
        }

        // LAYER-BASED UPDRAFT SYSTEM with multiple vertical columns
        class LayeredUpdraftSystem {
            constructor(cloudSystemRef) {
                this.cloudSystem = cloudSystemRef;
                this.updraftColumns = []; // vertical updraft features
            }
            spawnColumn(x, z, strength, radius, baseAltitude) {
                const col = {
                    x, z, strength, radius,
                    baseAlt: baseAltitude,
                    topAlt: baseAltitude + 8 + Math.random() * 12,
                    age: 0, maxAge: 400 + Math.random() * 300,
                    rotation: Math.random() > 0.5 ? 1 : -1,
                    subColumns: [] // sub-vortices within main updraft
                };
                // create sub-vortex cores
                for (let s = 0; s < 2; s++) {
                    const angle = Math.random() * Math.PI * 2;
                    const offsetRadius = radius * (0.3 + Math.random() * 0.4);
                    col.subColumns.push({
                        x: x + Math.cos(angle) * offsetRadius,
                        z: z + Math.sin(angle) * offsetRadius,
                        strength: strength * (0.5 + Math.random() * 0.5),
                        radius: radius * 0.4,
                        rotation: col.rotation
                    });
                }
                this.updraftColumns.push(col);
            }
            applyUpdraftsToWind(windField) {
                for (const col of this.updraftColumns) {
                    const size = windField.size;
                    const spacing = windField.spacing;
                    for (let gx = 0; gx < size; gx++) {
                        for (let gy = 0; gy < size; gy++) {
                            for (let gz = 0; gz < size; gz++) {
                                const wx = (gx - size / 2) * spacing;
                                const wy = gy * spacing;
                                const wz = (gz - size / 2) * spacing;
                                // check distance to main column
                                const dist = Math.hypot(wx - col.x, wz - col.z);
                                if (dist < col.radius && wy >= col.baseAlt && wy <= col.topAlt) {
                                    const influence = Math.max(0, 1 - dist / col.radius);
                                    const cell = windField.field[gx][gy][gz];
                                    // vertical updraft
                                    cell.__updraft = (cell.__updraft || 0) + influence * col.strength * 0.08;
                                    // rotational component (cyclone-like)
                                    const ang = Math.atan2(wz - col.z, wx - col.x);
                                    cell.x += -Math.sin(ang) * influence * col.strength * col.rotation * 0.04;
                                    cell.z += Math.cos(ang) * influence * col.strength * col.rotation * 0.04;
                                }
                                // check sub-vortices
                                for (const subcol of col.subColumns) {
                                    const subdist = Math.hypot(wx - subcol.x, wz - subcol.z);
                                    if (subdist < subcol.radius && wy >= col.baseAlt && wy <= col.topAlt) {
                                        const subinfl = Math.max(0, 1 - subdist / subcol.radius);
                                        const cell = windField.field[gx][gy][gz];
                                        cell.__updraft = (cell.__updraft || 0) + subinfl * subcol.strength * 0.06;
                                        const sang = Math.atan2(wz - subcol.z, wx - subcol.x);
                                        cell.x += -Math.sin(sang) * subinfl * subcol.strength * subcol.rotation * 0.06;
                                        cell.z += Math.cos(sang) * subinfl * subcol.strength * subcol.rotation * 0.06;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            update(t) {
                for (let i = this.updraftColumns.length - 1; i >= 0; i--) {
                    const col = this.updraftColumns[i];
                    col.age++;
                    col.strength *= 0.98; // decay
                    if (col.age > col.maxAge || col.strength < 0.05) {
                        this.updraftColumns.splice(i, 1);
                    }
                }
                // occasionally spawn new columns under mature clouds
                const mature = this.cloudSystem.getMature();
                if (mature.length > 0 && Math.random() < 0.008) {
                    const c = mature[Math.floor(Math.random() * mature.length)];
                    this.spawnColumn(c.x, c.z, 3 + Math.random() * 4, 12 + Math.random() * 8, c.cloudBase || 8);
                }
            }
        }

        // NEW: Atmospheric Stability & CAPE Analysis System
        class EnvironmentalAnalysis {
            constructor() {
                this.capeLayers = new Map();
                this.stability = {};
                this.moistureConvergence = [];
            }

            // Lifted Condensation Level (LCL) computation
            computeLCL(surfaceTemp, surfaceHumidity, surfacePressure = 1013.25) {
                const dewpoint = surfaceTemp - ((100 - surfaceHumidity * 100) / 5.0);
                const lcl = 125 * (surfaceTemp - dewpoint);
                return Math.max(0.5, lcl / 1000); // convert to km equivalent
            }

            // Convective Available Potential Energy (full profile)
            computeFullCALE(cloudBase, cloudTop, temperature, humidity) {
                let cape = 0;
                const steps = 8;
                for (let i = 0; i < steps; i++) {
                    const alt = cloudBase + (cloudTop - cloudBase) * (i / steps);
                    const envTemp = temperature + 273.15;
                    const parcelTemp = temperature + 6.5; // moist adiabatic lapse
                    const buoyancy = (parcelTemp - envTemp) / envTemp * 9.81;
                    const dz = (cloudTop - cloudBase) * 1000 / steps;
                    cape += Math.max(0, buoyancy * dz);
                }
                return cape;
            }

            // Bulk Richardson Number (wind shear + CAPE interaction)
            computeBRN(cape, windShear, cloudDepth = 6) {
                const shearSq = windShear * windShear;
                if (shearSq < 0.0001) return 10000; // infinite if no shear
                const brn = cape / (shearSq * (cloudDepth * 1000));
                return Math.max(0, Math.min(100, brn));
            }

            // Lifted Index (stability measure)
            computeLiftedIndex(surfaceTemp, altitude, envTemp) {
                const adiabatic = -6.5;
                const parcelTemp = surfaceTemp + adiabatic * (altitude / 1000);
                return envTemp - parcelTemp; // negative = unstable
            }

            // Total Totals Index
            computeTotalTotals(surfaceTemp, dewpoint, temp700mb) {
                const tt = surfaceTemp + dewpoint - 2 * temp700mb;
                return tt;
            }

            // Moisture convergence field at position
            computeMoistureConvergence(x, z, windField, humidity) {
                let convergence = 0;
                const spacing = 12;
                const w1 = windField.getAt(x - spacing, 2, z);
                const w2 = windField.getAt(x + spacing, 2, z);
                const w3 = windField.getAt(x, 2, z - spacing);
                const w4 = windField.getAt(x, 2, z + spacing);
                // divergence of wind * humidity
                const divx = ((w2.x - w1.x) / (spacing * 2));
                const divz = ((w4.z - w3.z) / (spacing * 2));
                convergence = -(divx + divz) * humidity; // negative convergence = moisture inflow
                return Math.max(0, convergence);
            }

            update(cloudSystem, windField, atmosphericLayers) {
                // build stability map for current conditions
                for (const c of cloudSystem.clouds || []) {
                    if (!c) continue;
                    const temp = atmosphericLayers.getTemperature(c.height);
                    const cape = this.computeFullCALE(c.cloudBase || c.height - 2, c.height, temp, 0.5);
                    const shear = 0.1 + Math.random() * 0.3; // simplified wind shear
                    const brn = this.computeBRN(cape, shear, c.height - (c.cloudBase || c.height - 2));
                    this.capeLayers.set(c, { cape, brn, shear });
                }
                
                // compute moisture convergence along frontal boundaries and terrain
                for (let x = -200; x < 200; x += 40) {
                    for (let z = -200; z < 200; z += 40) {
                        const env = sampleEnvironment(x, z, 6);
                        const conv = this.computeMoistureConvergence(x, z, windField, env.humidity);
                        if (conv > 0.01) {
                            this.moistureConvergence.push({ x, z, strength: conv });
                        }
                    }
                }
                // prune old convergence zones
                this.moistureConvergence = this.moistureConvergence.filter(c => Math.random() > 0.05);
            }
        }

        // NEW: Orographic Lifting System (terrain-forced ascent)
        class OrographicSystem {
            constructor(windFieldRef) {
                this.windField = windFieldRef;
                this.liftingZones = [];
            }

            // Compute terrain-forced vertical motion at position
            computeOrographicLift(x, z, windField) {
                // stronger orographic lift in proximity to mountain ranges: sample nearest mountain and slope
                let lift = 0;
                try {
                    if (AppState.mountainRanges && AppState.mountainRanges.length) {
                        for (const m of AppState.mountainRanges) {
                            const dx = x - m.x;
                            const dz = z - m.z;
                            const dist = Math.hypot(dx, dz);
                            if (dist < m.r * 1.6) {
                                // slope approx from mountain geometry and roughness
                                const slope = Math.max(0, (m.height / Math.max(3, m.r)) * (1 + (m.roughness || 0.9) * 0.6));
                                // wind projection into mountain normal
                                const w = windField.getAt(x, 2, z);
                                const windMag = Math.hypot(w.x || 0, w.z || 0);
                                // lift scales strongly near crest and with incoming wind magnitude
                                const proximity = 1 - Math.min(1, dist / (m.r * 1.6));
                                lift += slope * windMag * proximity * 0.12 * (1 + (m.steepness || 1) * 0.25);
                            }
                        }
                    }
                    // fallback small-scale empirical lift if no mountains nearby
                    if (lift === 0) {
                        const dx = 12;
                        const z0 = Math.sin(x * 0.02) * Math.cos(z * 0.03) * 2;
                        const zx_pos = Math.sin((x + dx) * 0.02) * Math.cos(z * 0.03) * 2;
                        const zx_neg = Math.sin((x - dx) * 0.02) * Math.cos(z * 0.03) * 2;
                        const slopex = (zx_pos - zx_neg) / (dx * 2);
                        const wind = windField.getAt(x, 2, z);
                        lift = (slopex * wind.x) * 0.04;
                    }
                } catch (e) {
                    // safe fallback
                    const dx = 12;
                    const z0 = Math.sin(x * 0.02) * Math.cos(z * 0.03) * 2;
                    const zx_pos = Math.sin((x + dx) * 0.02) * Math.cos(z * 0.03) * 2;
                    const zx_neg = Math.sin((x - dx) * 0.02) * Math.cos(z * 0.03) * 2;
                    const slopex = (zx_pos - zx_neg) / (dx * 2);
                    const wind = windField.getAt(x, 2, z);
                    lift = (slopex * wind.x) * 0.04;
                }
                return lift;
            }

            // Apply orographic lifting to wind field
            applyOrographicLift(windField) {
                const size = windField.size;
                const spacing = windField.spacing;
                for (let gx = 1; gx < size - 1; gx++) {
                    for (let gy = 1; gy < Math.min(8, size - 1); gy++) {
                        for (let gz = 1; gz < size - 1; gz++) {
                            const wx = (gx - size / 2) * spacing;
                            const wy = gy * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const lift = this.computeOrographicLift(wx, wz, windField);
                            if (Math.abs(lift) > 0.001) {
                                windField.field[gx][gy][gz].__orographicLift = lift;
                            }
                        }
                    }
                }
            }

            update(windField) {
                this.applyOrographicLift(windField);
            }
        }

        // NEW: Cloud Microphysics Detailed Model
        class DetailedMicrophysics {
            constructor() {
                this.dropletSpectra = new Map(); // per-cloud droplet size distribution
                this.iceParticles = new Map();
                this.vapourDensity = new Map();
            }

            // Initialize droplet spectrum for a cloud (log-normal distribution)
            initializeSpectrum(cloud) {
                const spectrum = {
                    mode: 15e-6, // 15 micrometer mode
                    sigma: 1.6,  // geometric std dev
                    concentration: 300e6, // 300 cm^-3
                    liquid_water: 0.3,    // g m^-3
                    effective_radius: 10e-6,
                    bin_edges: this._createBins(50),
                    bin_counts: new Float32Array(50)
                };
                this.dropletSpectra.set(cloud, spectrum);
            }

            _createBins(nbins) {
                const bins = new Array(nbins + 1);
                for (let i = 0; i <= nbins; i++) {
                    // log-scale from 1 to 100 micrometers
                    bins[i] = 1e-6 * Math.pow(100, i / nbins);
                }
                return bins;
            }

            // Compute droplet growth via condensation with K√∂hler theory
            computeCondensationalGrowth(spectrum, supersaturation, temp, pressure) {
                if (supersaturation < 0.0005) return 0;
                // K√∂hler curve growth (Rogers & Yau approximation)
                const G = Math.sqrt(2 * 0.073 / (461 * (temp + 273.15))); // G factor
                const Ss = Math.sqrt(supersaturation * 100); // convert to percent
                const growthRate = (G * Ss) ** 2 * 1e-10; // cm/s
                spectrum.liquid_water += growthRate * 0.15;
                spectrum.liquid_water = Math.min(3.0, spectrum.liquid_water); // max LWC
                // shift effective radius slightly
                spectrum.effective_radius = Math.min(30e-6, spectrum.effective_radius + growthRate * 1e-10);
                return growthRate;
            }

            // Collision-coalescence with size-dependent kernel
            computeCollisionCoalescence(spectrum, temp) {
                if (spectrum.liquid_water < 0.1) return 0;
                // Marshall-Palmer collection efficiency + ventilation
                const r_eff = spectrum.effective_radius || 15e-6;
                const E_c = Math.min(1.0, (r_eff / 10e-6) ** 2 * 0.5); // collection efficiency rises with size
                const ventilationFactor = 1 + 0.2 * Math.pow(r_eff / 10e-6, 0.5); // ventilation enhancement
                // collision kernel depends on droplet concentration and terminal velocity difference
                const v_rel = 50 * Math.sqrt(r_eff / 10e-6); // relative velocity (cm/s)
                const kernelIntegral = 4 * Math.PI * r_eff * r_eff * E_c * v_rel * ventilationFactor;
                const collisionRate = kernelIntegral * spectrum.concentration * 1e-6; // normalized
                // coalescence: increase mass and reduce concentration slightly
                const coalesceAmount = Math.min(0.2, collisionRate * 0.01 * (1 - Math.exp(-spectrum.liquid_water)));
                spectrum.liquid_water += coalesceAmount;
                spectrum.concentration *= Math.exp(-coalesceAmount * 0.1);
                return coalesceAmount;
            }

            // Ice particle growth by riming (collision with supercooled water)
            computeRiming(spectrum, temp, altitude) {
                if (temp > -5) return 0; // no riming above -5¬∞C
                if (spectrum.liquid_water < 0.2) return 0;
                const rimingRate = spectrum.liquid_water * (1 - temp / -40) * 0.08; // stronger at -20¬∞C
                return Math.min(0.5, rimingRate);
            }

            // Aggregate ice crystals (ice multiplication, graupel formation)
            computeAggregation(spectrum, temp, ice_water_content) {
                if (temp > -10 || temp < -30) return 0;
                if (!ice_water_content || ice_water_content < 0.05) return 0;
                // Bergeron process: ice grows at expense of liquid
                const depWater = (spectrum.liquid_water || 0) * 0.3; // deposition enhancement
                spectrum.liquid_water = Math.max(0, (spectrum.liquid_water || 0) - depWater);
                return depWater;
            }

            // Compute supersaturation field
            computeSupersaturation(cloud, atmosphere) {
                const temp = atmosphere.getTemperature(cloud.height);
                const pressure = atmosphere.getPressure(cloud.height);
                const humidity = Math.min(1, cloud.condensationLevel || 0.5);
                // saturation vapor pressure (Magnus formula)
                const es = 6.112 * Math.exp((17.67 * temp) / (temp + 243.5));
                const e = es * humidity;
                const Ss = (e - es) / es;
                return Math.max(-0.02, Math.min(0.05, Ss));
            }

            update(cloudSystem, atmosphericLayers) {
                for (const c of cloudSystem.clouds || []) {
                    if (!c) continue;
                    if (!this.dropletSpectra.has(c)) {
                        this.initializeSpectrum(c);
                    }
                    const spec = this.dropletSpectra.get(c);
                    const temp = atmosphericLayers.getTemperature(c.height);
                    const pressure = atmosphericLayers.getPressure(c.height);
                    const ss = this.computeSupersaturation(c, atmosphericLayers);
                    
                    // condensational growth
                    this.computeCondensationalGrowth(spec, ss, temp, pressure);
                    // coalescence for warm clouds
                    if (temp > -5) {
                        this.computeCollisionCoalescence(spec, temp);
                    }
                    // ice processes
                    if (temp < -5) {
                        this.computeRiming(spec, temp, c.height);
                        this.computeAggregation(spec, temp, spec.liquid_water * 0.6);
                    }
                    
                    // update cloud properties based on microphysics
                    c.condensationLevel = Math.min(1, spec.liquid_water / 2.0);
                    c.mass = Math.max(0, c.mass * 0.98 + spec.liquid_water * 0.02);
                }
            }
        }

        // NEW: Cloud Entrainment System (mixing of environmental air)
        class CloudEntrainment {
            constructor() {
                this.entrainmentRates = new Map();
            }

            // Compute entrainment rate based on cloud properties and environment
            computeEntrainmentRate(cloud, windShear, ambientHumidity) {
                // higher shear promotes more entrainment
                // drier environment promotes evaporative cooling and more entrainment
                const shearFactor = windShear * 0.05;
                const dryFactor = Math.max(0, 0.6 - ambientHumidity) * 0.04;
                const baseRate = 0.02 + shearFactor + dryFactor;
                return Math.min(0.15, baseRate); // clamp max entrainment
            }

            // Apply entrainment: mix cloud with environment, reduces cloud
            applyEntrainment(cloud, envAnalysis, atmosphericLayers) {
                const cape = envAnalysis.capeLayers.get(cloud);
                if (!cape) return;
                const entrRate = this.computeEntrainmentRate(cloud, cape.shear, 0.4);
                // entrainment reduces condensation level and cloud mass slightly
                if (Math.random() < entrRate * 0.1) {
                    cloud.condensationLevel *= (1 - entrRate * 0.5);
                    cloud.mass *= (1 - entrRate * 0.08);
                }
            }

            update(cloudSystem, envAnalysis, atmosphericLayers) {
                for (const c of cloudSystem.clouds || []) {
                    if (!c) continue;
                    this.applyEntrainment(c, envAnalysis, atmosphericLayers);
                }
            }
        }

        // NEW: Collision-Coalescence & Rain Formation System
        class RainFormationModel {
            constructor() {
                this.collisionStats = new Map();
            }

            // Compute collision rates between droplets
            computeCollisionRate(liquidWaterContent, dropletConcentration, meanRadius) {
                // Marshall-Palmer type collision kernel
                const E = 0.75; // collection efficiency
                const kernel = 4 * Math.PI * (meanRadius * 1e-6) ** 2 * E * 1e9;
                const collisionRate = kernel * dropletConcentration * liquidWaterContent * 0.001;
                return Math.min(1.0, collisionRate);
            }

            // Determine if cloud will rain based on micro and macro properties
            willProdecipitate(cloud, microphysics) {
                if (!cloud) return false;
                const spec = microphysics.dropletSpectra.get(cloud);
                if (!spec) return false;
                // rain forms when liquid water content > ~0.5 g/m^3 AND mean droplet size > ~20 micrometers
                const lwcThreshold = 0.5;
                const radiusThreshold = 20e-6;
                return spec.liquid_water > lwcThreshold && spec.mode > radiusThreshold && cloud.height > 8;
            }

            update(cloudSystem, microphysics, precipSystem) {
                for (const c of cloudSystem.clouds || []) {
                    if (!c) continue;
                    if (this.willProdecipitate(c, microphysics) && Math.random() < 0.06) {
                        // spawn multiple precipitation drops from this cloud
                        for (let i = 0; i < 8; i++) {
                            precipSystem.spawnDropFromCloud(c);
                        }
                    }
                }
            }
        }

        function init() {
            AppState.scene = new THREE.Scene();
            AppState.scene.background = new THREE.Color(0x5a7a95);
            AppState.scene.fog = new THREE.Fog(0x5a7a95, 100, 350);

            AppState.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            AppState.camera.position.set(0, 25, 70);

            AppState.renderer = new THREE.WebGLRenderer({ antialias: true });
            AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            AppState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            AppState.renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(AppState.renderer.domElement);
            
            // NEW: rain dog sprite attached to camera (visual raindrop overlay whose opacity depends on precipitation intensity)
            (function createRainDog() {
                const size = 256;
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                // draw soft circular streak / droplet vignette
                const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                g.addColorStop(0, 'rgba(255,255,255,0.9)');
                g.addColorStop(0.35, 'rgba(210,230,245,0.55)');
                g.addColorStop(0.68, 'rgba(120,170,210,0.18)');
                g.addColorStop(1, 'rgba(90,140,190,0.0)');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,size,size);
                // subtle vertical streak to suggest water smear
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = 'rgba(255,255,255,0.06)';
                for (let i=0;i<8;i++){
                    ctx.fillRect(size*0.44 + (i-4)*1.6, size*0.08, size*0.06, size*0.84);
                }
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({
                    map: tex,
                    transparent: true,
                    opacity: 0.0,
                    depthWrite: false,
                    blending: THREE.NormalBlending
                });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(3.0, 3.0, 1.0); // reasonable size in view-space
                // attach to camera so it always stays in screen-space
                try {
                    AppState.camera.add(sprite);
                    sprite.position.set(0.0, -0.6, -1.25); // slightly lower center in view
                } catch(e) {}
                AppState.rainDog = sprite;
            })();

            const ambient = new THREE.AmbientLight(0x808fa0, 1.2);
            AppState.scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xfffae6, 1.5);
            sun.position.set(60, 50, 80);
            sun.castShadow = true;
            sun.shadow.camera.left = sun.shadow.camera.bottom = -70;
            sun.shadow.camera.right = sun.shadow.camera.top = 70;
            sun.shadow.mapSize.width = sun.shadow.mapSize.height = 1024;
            AppState.scene.add(sun);

            const back = new THREE.DirectionalLight(0xffd9a8, 0.8);
            back.position.set(-50, 40, -60);
            AppState.scene.add(back);

            // ensure emitter array exists before terrain creation (createTerrain may push emitters)
            AppState.emitters = AppState.emitters || [];
            createTerrain();
            
            // instantiate water plane (placed after terrain so it's below ground low points)
            AppState.waterSurface = new WaterSurface();

            // dynamic tree system (spawns trees across terrain excluding large water basins)
            AppState.treeSystem = new TreeSystem(140);
            
            AppState.windField = new WindField();
            AppState.evaporationSystem = new EvaporationSystem();
            AppState.cloudSystem = new CloudGrowth();
            AppState.rainSystem = new Precipitation(AppState.windField, AppState.cloudSystem);
            AppState.lightningSystem = new Lightning(AppState.cloudSystem);
            AppState.downburstSystem = new Downburst(AppState.windField, AppState.cloudSystem);

            // NEW: Urban system (cities/urban clusters)
            AppState.urbanSystem = new UrbanSystem(9);
            
            // Rainbow system (visualization dependent on sun & moisture)
            AppState.rainbowSystem = new RainbowSystem();
            AppState.updraftSystem = new (class UpdraftSystem {
                constructor(windFieldRef, cloudSystemRef) {
                    this.wind = windFieldRef;
                    this.clouds = cloudSystemRef;
                    this.events = []; // transient concentrated updraft pulses
                }
                // return net updraft lift at x,z (0..1 scale)
                getUpdraftAt(x, z) {
                    // base lift from cloud updraft objects (cloudSystem maintains updrafts)
                    let lift = 0;
                    if (this.clouds && this.clouds.updrafts) {
                        for (const u of this.clouds.updrafts) {
                            if (!u || !u.active) continue;
                            const dist = Math.hypot(x - u.x, z - u.z);
                            if (dist < u.radius) {
                                const f = 1 - dist / u.radius;
                                lift += u.strength * f * Math.min(1, u.age / Math.max(1, u.maxAge));
                            }
                        }
                    }
                    // transient event pulses (localized stronger updrafts)
                    for (let i = this.events.length - 1; i >= 0; i--) {
                        const ev = this.events[i];
                        const d = Math.hypot(x - ev.x, z - ev.z);
                        if (d < ev.radius) {
                            const f2 = 1 - d / ev.radius;
                            lift += ev.strength * f2 * (ev.life / ev.maxLife);
                        }
                        ev.life--;
                        if (ev.life <= 0) this.events.splice(i, 1);
                    }
                    return Math.min(2.0, lift); // allow >1 for strong updrafts but clamp
                }
                // spawn a transient pulse (used by cloud collapse or manual triggers)
                trigger(x, z, strength = 1.2, radius = 12, duration = 60) {
                    this.events.push({ x, z, strength, radius, life: duration, maxLife: duration });
                }
                update() {
                    // gently nudge low-level wind field to simulate organized updraft columns
                    // small inexpensive pass to add vertical hint into wind cells
                    if (!this.wind || !this.wind.field) return;
                    const now = performance.now();
                    const size = this.wind.size;
                    const spacing = this.wind.spacing;
                    for (let gx = 0; gx < size; gx++) {
                        for (let gz = 0; gz < size; gz++) {
                            // sample world position of cell center
                            const wx = (gx - size / 2) * spacing;
                            const wz = (gz - size / 2) * spacing;
                            const up = this.getUpdraftAt(wx, wz);
                            if (up > 0.001) {
                                // apply a small upward proxy stored on the cell for other systems to read
                                for (let gy = 0; gy < Math.min(6, size); gy++) {
                                    const cell = this.wind.field[gx][gy][gz];
                                    cell.__updraft = (cell.__updraft || 0) + up * 0.002 * (1 + (6 - gy) * 0.08);
                                }
                            }
                        }
                    }
                    // decay __updraft markers over time
                    for (let gx = 0; gx < this.wind.size; gx++) {
                        for (let gy = 0; gy < Math.min(6, this.wind.size); gy++) {
                            for (let gz = 0; gz < this.wind.size; gz++) {
                                const c = this.wind.field[gx][gy][gz];
                                if (c && c.__updraft) {
                                    c.__updraft *= 0.92;
                                }
                            }
                        }
                    }
                }
            })(AppState.windField, AppState.cloudSystem);
            
            AppState.tornadoSystem = new TornadoSystem(AppState.windField, AppState.cloudSystem);

            // Instantiate new frontal & derecho systems
            AppState.warmFrontSystem = new WarmFront(AppState.windField, AppState.cloudSystem);
            AppState.coldFrontSystem = new ColdFront(AppState.windField, AppState.cloudSystem);
            AppState.derechoSystem = new DerechoSystem(AppState.windField, AppState.cloudSystem, AppState.rainSystem);
            
            // SUN, GLARE & GODRAYS (toggleable)
            (function createSunAndGodrays() {
                // Sun directional light reference already added above as 'sun'
                // Create a lens-glare sprite positioned at sun direction for simple glare effect
                const glareCanvas = document.createElement('canvas');
                glareCanvas.width = glareCanvas.height = 256;
                const gctx = glareCanvas.getContext('2d');
                const ggrad = gctx.createRadialGradient(128,128,0,128,128,128);
                ggrad.addColorStop(0, 'rgba(255,255,220,0.95)');
                ggrad.addColorStop(0.2, 'rgba(255,235,190,0.55)');
                ggrad.addColorStop(0.5, 'rgba(255,200,150,0.18)');
                ggrad.addColorStop(1, 'rgba(255,200,150,0)');
                gctx.fillStyle = ggrad;
                gctx.fillRect(0,0,256,256);
                const glareTex = new THREE.CanvasTexture(glareCanvas);
                const glareMat = new THREE.SpriteMaterial({ map: glareTex, color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false, blending: THREE.AdditiveBlending });
                const sunGlare = new THREE.Sprite(glareMat);
                sunGlare.scale.set(80,80,1);
                sunGlare.userData = { enabled: true };
                AppState.scene.add(sunGlare);
                AppState._sunGlare = sunGlare;

                // Simple godrays approximation: a large, low-opacity cone aligned with sun direction, additive blended
                const coneGeo = new THREE.ConeGeometry(120, 260, 16, 1, true);
                coneGeo.translate(0, -130, 0); // pivot top at origin
                const coneMat = new THREE.MeshBasicMaterial({ color: 0xfff8d8, transparent: true, opacity: 0.0, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
                const godrays = new THREE.Mesh(coneGeo, coneMat);
                godrays.userData = { enabled: true, baseOpacity: 0.12 };
                AppState.scene.add(godrays);
                AppState._godrays = godrays;

                // update function to position glare/godrays each frame (attached to AppState for animate loop)
                AppState._updateSunEffects = function() {
                    // Find directional light (sun)
                    const sunLight = AppState.scene.children.find(o => o && o.isDirectionalLight);
                    if (!sunLight) return;
                    // position glare far in sun direction relative to camera so it appears at sun screen position
                    const camPos = AppState.camera.position.clone();
                    const sunDir = sunLight.position.clone().normalize();
                    const glarePos = camPos.clone().sub(sunDir.clone().multiplyScalar(180));
                    if (AppState._sunGlare) {
                        AppState._sunGlare.position.copy(glarePos);
                        // Fresnel-ish fade by angle between sunDir and camera forward
                        const camForward = new THREE.Vector3();
                        AppState.camera.getWorldDirection(camForward);
                        const facing = Math.max(0, -sunDir.dot(camForward));
                        AppState._sunGlare.material.opacity = Graphics.sun ? Math.min(0.98, 0.15 + facing * 1.2) : 0.0;
                    }
                    if (AppState._godrays) {
                        // Position cone so top points toward sun and top is above the scene
                        const target = camPos.clone().sub(sunDir.clone().multiplyScalar(220));
                        AppState._godrays.position.copy(target);
                        // orient cone along sun direction: cone's local -Y points toward world -Y, rotate to face opposite sunDir
                        AppState._godrays.lookAt(camPos);
                        AppState._godrays.material.opacity = Graphics.godrays ? Math.min(0.45, AppState._godrays.userData.baseOpacity * (0.6 + Math.max(0, -sunDir.y) * 1.2)) : 0.0;
                    }
                };
            })();

            // NEW: Initialize atmospheric layers system
            AppState.atmosphericLayers = new AtmosphericLayers();
            
            // NEW: Initialize wind shear system
            AppState.windShearSystem = new WindShearSystem(AppState.windField);
            
            // NEW: Initialize hail/graupel system
            AppState.hailSystem = new HailGrowelSystem(AppState.rainSystem, AppState.atmosphericLayers);
            
            // NEW: Initialize electrostatic system with feedback
            AppState.electrostaticSystem = new ElectrostaticSystem(AppState.cloudSystem, AppState.lightningSystem, AppState.atmosphericLayers);
            
            // NEW: Initialize Coriolis system
            AppState.coriolisSystem = new CoriolisSystem(AppState.windField, 40); // 40¬∞ N latitude
            
            // NEW: Initialize turbulence cascade
            AppState.turbulenceCascade = new TurbulenceCascade(AppState.windField);
            
            // NEW: Initialize layered updraft system
            AppState.layeredUpdraftSystem = new LayeredUpdraftSystem(AppState.cloudSystem);

            // NEW: Birds
            AppState.birds = new Birds(34);

            setupControls();
            // detect CPU & GPU and display
            (function detectHardware() {
                try {
                    const cpuEl = document.getElementById('cpu');
                    const gpuEl = document.getElementById('gpu');
                    // CPU cores
                    const cores = navigator.hardwareConcurrency || '‚Äî';
                    if (cpuEl) cpuEl.textContent = cores;
                    // GPU via WebGL debug renderer info
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    let renderer = 'Unknown';
                    if (gl) {
                        const dbg = gl.getExtension('WEBGL_debug_renderer_info');
                        if (dbg) {
                            renderer = gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) || renderer;
                        } else {
                            renderer = gl.getParameter(gl.RENDERER) || renderer;
                        }
                    }
                    if (gpuEl) gpuEl.textContent = renderer;
                } catch (e) {
                    console.warn('Hardware detect failed', e);
                }
            })();

            // Prevent UI panels (especially the top-left stats) from forwarding pointer events to the canvas,
            // so touching/dragging UI won't rotate/move the camera.
            (function blockUIPointerPropagation() {
                try {
                    // specifically guard the stats panel and other ui panels
                    const blockIds = ['stats', 'controls', 'graphics', 'info'];
                    blockIds.forEach(id => {
                        const el = document.getElementById(id);
                        if (!el) return;
                        // ensure the panel consumes pointer interactions and doesn't let them bubble to canvas
                        el.style.touchAction = 'manipulation';
                        el.style.pointerEvents = 'auto';
                        ['pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend'].forEach(evt => {
                            el.addEventListener(evt, (e) => {
                                e.stopPropagation();
                            }, { passive: false });
                        });
                    });
                } catch (e) {
                    console.warn('blockUIPointerPropagation failed', e);
                }
            })();
        }

        let frames = 0;
        let lastFps = performance.now();

        // animate wrapper: the function used both by RAF and renderer.setAnimationLoop - ensure it schedules next RAF only when vsync is false
        // modify animate to accept a timestamp arg and avoid scheduling requestAnimationFrame when setAnimationLoop is active
        function animate(ts) {
            // if using RAF driver, store raf id for potential cancellation
            if (!Graphics.vsync) {
                AppState._rafId = requestAnimationFrame(animate);
            }
            const t = performance.now();

            // compute delta time robustly to avoid TDZ / "Cannot access 'deltaMs' before initialization"
            // ensure AppState._lastTime exists, then compute deltaMs (ms) and dt (s)
            let deltaMs = 0;
            if (!AppState._lastTime) {
                // first frame: assume ~16.67ms (60fps) to avoid large first-step jumps
                deltaMs = 16.6667;
            } else {
                deltaMs = t - AppState._lastTime;
            }
            // apply simulation speed multiplier from UI
            deltaMs *= (Number(Graphics.simSpeed) || 1.0);
            const dt = (deltaMs / 1000) || 0;
            AppState._lastTime = t;

            // Performance: update smoothed FPS and warn if low
            try {
                const fpsInstant = deltaMs > 0 ? (1000 / deltaMs) : 60;
                // initialize smoothing
                if (typeof AppState._smoothedFPS === 'undefined') AppState._smoothedFPS = fpsInstant;
                // exponential smoothing
                AppState._smoothedFPS = AppState._smoothedFPS * 0.92 + fpsInstant * 0.08;
                // warn if smoothed FPS falls below threshold for sustained period
                const fpsThreshold = 30;
                if (AppState._smoothedFPS < fpsThreshold) {
                    // only show once until recovery
                    if (!AppState._fpsWarnShown) {
                        AppState._fpsWarnShown = true;
                        showPerfWarning('Performance: frame rate dropped below 30 FPS ‚Äî consider lowering graphics settings.', 'fps-warning', 5000);
                    } else {
                        // ensure the overlay persists while poor
                        showPerfWarning('Performance: frame rate below 30 FPS ‚Äî consider lowering graphics settings.', 'fps-warning', 0);
                    }
                } else {
                    if (AppState._fpsWarnShown) {
                        AppState._fpsWarnShown = false;
                        // remove fps warning overlay when recovered
                        hidePerfWarning();
                    }
                }
                // write an approximate FPS into UI (smoothed)
                if (document.getElementById('fps')) {
                    document.getElementById('fps').textContent = Math.max(0, Math.round(AppState._smoothedFPS));
                }
            } catch (e) { console.warn('FPS smoothing failed', e); }

            // performance warning: if ray tracing requested on weak device, show warning overlay once
            try {
                if (Graphics.rayTracing && !Graphics.performanceWarningSeen) {
                    const cores = navigator.hardwareConcurrency || 1;
                    if (cores < 4 || (window.devicePixelRatio || 1) < 1.1) {
                        Graphics.performanceWarningSeen = true;
                        showPerfWarning('Warning: Ray Tracing enabled on a low-power device ‚Äî performance may be poor. Toggle Ray Tracing off in Graphics.', 'raytrace-hw-warning', 5000);
                    }
                }
            } catch(e){}
            if (AppState.paused) {
                // Still render the current scene so camera can be moved while paused
                AppState.renderer.render(AppState.scene, AppState.camera);
                return;
            }

            // Safely update wind field (guard in case it's not yet initialized)
            let ws = { x: 0, z: 0 };
            try {
                if (AppState.windField && typeof AppState.windField.update === 'function') {
                    ws = AppState.windField.update(t) || ws;
                }
            } catch (e) {
                console.warn('WindField.update error:', e);
                ws = { x: 0, z: 0 };
            }

            // NEW: Update atmospheric layers
            try {
                if (AppState.atmosphericLayers && typeof AppState.atmosphericLayers.update === 'function') {
                    AppState.atmosphericLayers.update(deltaMs);
                }
            } catch (e) {
                console.warn('AtmosphericLayers.update error:', e);
            }
            
            // NEW: Apply Coriolis effects (slow, large-scale)
            try {
                if (AppState.coriolisSystem && typeof AppState.coriolisSystem.applyCoriolisToWind === 'function') {
                    AppState.coriolisSystem.applyCoriolisToWind(deltaMs);
                }
            } catch (e) {
                console.warn('Coriolis.apply error:', e);
            }
            
            // NEW: Update turbulence cascade
            try {
                if (AppState.turbulenceCascade && typeof AppState.turbulenceCascade.updateCascade === 'function') {
                    AppState.turbulenceCascade.updateCascade(deltaMs);
                }
            } catch (e) {
                console.warn('TurbulenceCascade.updateCascade error:', e);
            }
            
            // NEW: Apply layered updrafts
            try {
                if (AppState.layeredUpdraftSystem) {
                    if (typeof AppState.layeredUpdraftSystem.applyUpdraftsToWind === 'function') {
                        AppState.layeredUpdraftSystem.applyUpdraftsToWind(AppState.windField);
                    }
                    if (typeof AppState.layeredUpdraftSystem.update === 'function') {
                        AppState.layeredUpdraftSystem.update(t);
                    }
                }
            } catch (e) {
                console.warn('LayeredUpdraftSystem error:', e);
            }

            // New systems should be updated after the core wind update so they can perturb the field
            try { if (AppState.warmFrontSystem && typeof AppState.warmFrontSystem.update === 'function') AppState.warmFrontSystem.update(t); } catch (e) { console.warn('WarmFront.update error:', e); }
            try { if (AppState.coldFrontSystem && typeof AppState.coldFrontSystem.update === 'function') AppState.coldFrontSystem.update(t); } catch (e) { console.warn('ColdFront.update error:', e); }
            try { if (AppState.derechoSystem && typeof AppState.derechoSystem.update === 'function') AppState.derechoSystem.update(t); } catch (e) { console.warn('Derecho.update error:', e); }

            // mountain wave updates (apply orographic standing wave perturbations)
            try { if (AppState.mountainWaveSystem && typeof AppState.mountainWaveSystem.update === 'function') AppState.mountainWaveSystem.update(t); } catch (e) { console.warn('MountainWave.update error:', e); }

            // Apply downburst effects after base wind update so perturbations persist for this frame
            try { if (AppState.downburstSystem && typeof AppState.downburstSystem.update === 'function') AppState.downburstSystem.update(t); } catch (e) { console.warn('Downburst.update error:', e); }
            try { if (AppState.tornadoSystem && typeof AppState.tornadoSystem.update === 'function') AppState.tornadoSystem.update(t); } catch (e) { console.warn('TornadoSystem.update error:', e); }
            const windSpeed = Math.sqrt(ws.x * ws.x + ws.z * ws.z);
            // amplify camera shake if large cloud-driven gusts exist (sustained high wind)
            try {
                // derive a gust metric from windField cloud gust markers
                let gustMetric = 0;
                if (AppState.windField && AppState.windField.field) {
                    const size = AppState.windField.size;
                    const spacing = AppState.windField.spacing;
                    for (let gx = 0; gx < size; gx++) {
                        for (let gz = 0; gz < size; gz++) {
                            const cell = AppState.windField.field[gx][2] && AppState.windField.field[gx][2][gz];
                            if (cell && cell.__cloudGust) gustMetric = Math.max(gustMetric, Math.abs(cell.__cloudGust));
                        }
                    }
                }
                const gustStrength = Math.min(3.2, (gustMetric * 8) + windSpeed * 0.45);
                if (gustStrength > 0.9) {
                    AppState.cameraControls.shake.intensity = Math.max(AppState.cameraControls.shake.intensity, 0.6 + gustStrength * 0.9);
                    AppState.cameraControls.shake.duration = Math.max(AppState.cameraControls.shake.duration, 600);
                }
            } catch (e) {}

            // update water surface and trees (lightweight)
            try { if (AppState.waterSurface && typeof AppState.waterSurface.update === 'function') AppState.waterSurface.update(deltaMs); } catch (e) { console.warn('WaterSurface.update error:', e); }
            try { if (AppState.treeSystem && typeof AppState.treeSystem.update === 'function') AppState.treeSystem.update(deltaMs); } catch (e) { console.warn('TreeSystem.update error:', e); }

            // birds update (lightweight)
            try { if (AppState.birds && typeof AppState.birds.update === 'function') AppState.birds.update(Math.max(0.001, deltaMs / 16.6)); } catch(e){}

            try { if (AppState.evaporationSystem && typeof AppState.evaporationSystem.update === 'function') AppState.evaporationSystem.update(); } catch (e) { console.warn('EvaporationSystem.update error:', e); }
            try { if (AppState.cloudSystem && typeof AppState.cloudSystem.update === 'function') AppState.cloudSystem.update(t); } catch (e) { console.warn('CloudGrowth.update error:', e); }
            // apply diurnal infrared/temperature update (DayNight)
            try { if (window.DayNight && typeof window.DayNight.update === 'function') window.DayNight.update(deltaMs); } catch (e) { console.warn('DayNight.update error:', e); }
            try { applyDayNightToScene(); } catch (e) { console.warn('applyDayNightToScene error:', e); }

            // precipitation update: guard against missing/partially-initialized system
            let activePart = 0;
            try {
                if (AppState.rainSystem && typeof AppState.rainSystem.update === 'function') {
                    activePart = AppState.rainSystem.update() || 0;
                } else {
                    activePart = 0;
                }
            } catch (e) {
                console.warn('Precipitation.update error:', e);
                activePart = 0;
            }

            // NEW: update rain dog opacity (opacity scales with precipitation intensity, max 0.9)
            try {
                if (AppState.rainDog && AppState.rainDog.material) {
                    const maxDrops = (AppState.rainSystem && AppState.rainSystem.max) ? AppState.rainSystem.max : 2500;
                    // compute normalized intensity (0..1) and apply rain intensity global multiplier
                    let intensityNorm = Math.min(1, (activePart / Math.max(1, maxDrops)) * (Graphics.rainIntensity || 1));
                    // soften response and cap at 0.9
                    const opacity = Math.min(0.9, intensityNorm * 0.9);
                    AppState.rainDog.material.opacity = opacity;
                    AppState.rainDog.visible = opacity > 0.01;
                }
            } catch(e) { console.warn('RainDog update failed', e); }

            try { if (AppState.lightningSystem && typeof AppState.lightningSystem.update === 'function') AppState.lightningSystem.update(t); } catch (e) { console.warn('Lightning.update error:', e); }
            try { if (AppState.rainbowSystem && typeof AppState.rainbowSystem.update === 'function') AppState.rainbowSystem.update(t); } catch (e) { console.warn('RainbowSystem.update error:', e); }

            // NEW: Update hail system
            try { if (AppState.hailSystem && typeof AppState.hailSystem.update === 'function') AppState.hailSystem.update(); } catch (e) { console.warn('HailSystem.update error:', e); }
            
            // Count graupel for charging system
            let graupelCount = 0;
            try {
                if (AppState.rainSystem) {
                    for (let i = 0; i < (AppState.rainSystem.max || 0); i++) {
                        if (AppState.rainSystem.drops && AppState.rainSystem.drops[i] && AppState.rainSystem.type && AppState.rainSystem.type[i] === 'graupel') {
                            graupelCount++;
                        }
                    }
                }
            } catch (e) {
                console.warn('graupel counting error:', e);
                graupelCount = 0;
            }
            
            // NEW: Update electrostatic system
            try { if (AppState.electrostaticSystem && typeof AppState.electrostaticSystem.update === 'function') AppState.electrostaticSystem.update(t, AppState.rainSystem, graupelCount); } catch (e) { console.warn('Electrostatic.update error:', e); }

            // NEW: update urban/night lights
            try { if (AppState.urbanSystem && typeof AppState.urbanSystem.update === 'function') AppState.urbanSystem.update(t); } catch (e) { console.warn('UrbanSystem.update error:', e); }

            // update sun effects (glare & godrays) per-frame
            try { if (AppState._updateSunEffects) AppState._updateSunEffects(); } catch (e) { console.warn('SunEffects update error:', e); }
            try { applySunScattering(); } catch(e){}

            // Apply first-person movement based on joystick / forward button inputs
            if (AppState.firstPerson) {
                // movement speed (units per second)
                const baseSpeed = AppState.cameraControls.speed * (AppState.cameraControls.move.forward ? 1 : 1) * (keys && keys['shift'] ? AppState.cameraControls.runMultiplier : 1) || AppState.cameraControls.speed;
                // compute forward/right basis from yaw
                const yaw = AppState.cameraControls.rotation.yaw || 0;
                const forwardVec = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
                const rightVec = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).normalize();
                // apply movement scaled by dt so button hold speed is consistent
                const moveForward = (AppState.cameraControls.move.forward || 0);
                const moveRight = (AppState.cameraControls.move.right || 0);
                AppState.camera.position.addScaledVector(forwardVec, moveForward * baseSpeed * dt * 3.0);
                AppState.camera.position.addScaledVector(rightVec, moveRight * baseSpeed * dt * 3.0);
            }

            // Positional camera shake handling (shake applied to lookAt target)
            const shake = AppState.cameraControls.shake;
            const ctrl = AppState.cameraControls;

            // base camera placement (spherical around center) or FP
            if (!AppState.firstPerson) {
                AppState.camera.position.x = ctrl.distance * Math.sin(ctrl.rotation.theta) * Math.cos(ctrl.rotation.phi);
                AppState.camera.position.y = ctrl.distance * Math.sin(ctrl.rotation.phi);
                AppState.camera.position.z = ctrl.distance * Math.cos(ctrl.rotation.theta) * Math.cos(ctrl.rotation.phi);

                // final lookAt with positional offset (positional shake)
                const baseTarget = { x: 0, y: 20, z: 0 };
                let targetOffset = { x: 0, y: 0, z: 0 };
                if (shake.intensity > 0.001 && (shake.duration > 0 || shake.time < shake.duration)) {
                    shake.time += Math.min(1000 / 60, 16.66);
                    const progress = Math.min(1, shake.time / Math.max(1, shake.duration));
                    const decay = 1 - progress;
                    const freq = shake.frequency || 18;
                    targetOffset.x = (Math.sin(t * 0.001 * freq) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.12 * decay;
                    targetOffset.y = (Math.cos(t * 0.001 * freq * 0.6) * 0.4 + (Math.random() - 0.5) * 0.6) * shake.intensity * 0.06 * decay;
                    targetOffset.z = (Math.cos(t * 0.001 * freq * 1.1) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.12 * decay;
                    shake.intensity *= 0.94;
                    if (shake.time >= shake.duration || shake.intensity < 0.03) {
                        shake.intensity = 0;
                        shake.duration = 0;
                        shake.time = 0;
                    }
                }
                AppState.camera.lookAt(baseTarget.x + targetOffset.x, baseTarget.y + targetOffset.y, baseTarget.z + targetOffset.z);
            } else {
                // First-person view: yaw/pitch applied directly
                // Keep camera at its current position (moved by movement joystick / WASD). Rotate target based on yaw/pitch for look vector.
                const yaw = ctrl.rotation.yaw || 0;
                const pitch = ctrl.rotation.pitch || 0;
                // compute forward target
                const look = new THREE.Vector3(Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), Math.cos(yaw) * Math.cos(pitch));
                const targetPos = new THREE.Vector3().copy(AppState.camera.position).add(look);
                // apply small positional shake to camera position if present
                if (shake.intensity > 0.001 && (shake.duration > 0 || shake.time < shake.duration)) {
                    shake.time += Math.min(1000 / 60, 16.66);
                    const progress = Math.min(1, shake.time / Math.max(1, shake.duration));
                    const decay = 1 - progress;
                    const freq = shake.frequency || 18;
                    const offset = new THREE.Vector3(
                        (Math.sin(t * 0.001 * freq) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.06 * decay,
                        (Math.cos(t * 0.001 * freq * 0.6) * 0.4 + (Math.random() - 0.5) * 0.6) * shake.intensity * 0.03 * decay,
                        (Math.cos(t * 0.001 * freq * 1.1) * 0.6 + (Math.random() - 0.5) * 1.0) * shake.intensity * 0.06 * decay
                    );
                    AppState.camera.position.add(offset);
                    targetPos.add(offset);
                    shake.intensity *= 0.94;
                    if (shake.time >= shake.duration || shake.intensity < 0.03) {
                        shake.intensity = 0;
                        shake.duration = 0;
                        shake.time = 0;
                    }
                }
                AppState.camera.lookAt(targetPos);
            }

            AppState.renderer.render(AppState.scene, AppState.camera);

            frames++;
            if (t - lastFps > 1000) {
                document.getElementById('fps').textContent = frames;
                document.getElementById('frame-time').textContent = (1000 / (frames || 1)).toFixed(1);
                document.getElementById('particles').textContent = activePart;
                document.getElementById('clouds').textContent = AppState.cloudSystem && AppState.cloudSystem.clouds ? AppState.cloudSystem.clouds.length : 0;
                // display lightning charge as a percentage relative to the Lightning.threshold (if available)
                const chargeDisplay = AppState.lightningSystem ? (typeof AppState.lightningSystem.chargePercent === 'number' ? Math.floor(AppState.lightningSystem.chargePercent) : Math.floor(AppState.lightningSystem.charge || 0)) : 0;
                document.getElementById('charge').textContent = chargeDisplay;
                document.getElementById('strikes').textContent = AppState.lightningSystem ? (AppState.lightningSystem.count || 0) : 0;
                document.getElementById('wind').textContent = windSpeed.toFixed(1);
                
                // Update Time Display
                if (window.DayNight) {
                    const phase = window.DayNight.phase; // 0=midnight, 0.5=noon
                    // Convert phase (0-1) to hours (0-24)
                    const hoursTotal = phase * 24;
                    const hours = Math.floor(hoursTotal);
                    const minutes = Math.floor((hoursTotal - hours) * 60);
                    const timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    document.getElementById('time-display').textContent = timeStr;
                }
                
                // update hardware readout occasionally
                try {
                    const cpuEl = document.getElementById('cpu');
                    const gpuEl = document.getElementById('gpu');
                    if (cpuEl && cpuEl.textContent === '‚Äî') cpuEl.textContent = (navigator.hardwareConcurrency || '‚Äî');
                    // GPU is set at init; no frequent update needed
                } catch (e) {}
                frames = 0;
                lastFps = t;
            }
        }

        function applyGraphicsSettings() {
            // shadows
            AppState.renderer.shadowMap.enabled = Graphics.shadows;
            // wind multiplier applied immediately to wind sampling; ensure it's clamped to safe range
            // allow user to set very large wind multipliers (no low hard cap), but enforce a tiny floor to avoid zero
            Graphics.windMultiplier = Math.max(0.01, Number(Graphics.windMultiplier || 1.0));
            // also try to set castShadow on directional lights if present
            AppState.scene.traverse(obj => {
                if (obj.isDirectionalLight || obj.isSpotLight || obj.isPointLight) {
                    if (obj.castShadow !== undefined) obj.castShadow = !!Graphics.shadows;
                }
            });
            // Fog toggle: preserve original fog if toggled off/on
            try {
                if (Graphics.fog) {
                    if (AppState._savedFog) {
                        AppState.scene.fog = AppState._savedFog;
                        AppState._savedFog = null;
                    } else if (!AppState.scene.fog) {
                        AppState.scene.fog = new THREE.Fog(AppState.scene.background ? AppState.scene.background.getHex() : 0x5a7a95, 100, Math.max(250, Graphics.renderDistance || 260));
                    }
                } else {
                    if (AppState.scene.fog) {
                        AppState._savedFog = AppState.scene.fog;
                        AppState.scene.fog = null;
                    }
                }
            } catch (e) { console.warn('Fog toggle failed', e); }
            // particle count adjustment (rain)
            if (AppState.rainSystem) {
                const newMax = Math.max(200, Math.min(3000, Math.floor(Graphics.particleDetail)));
                if (newMax !== AppState.rainSystem.max && typeof AppState.rainSystem.resize === 'function') {
                    AppState.rainSystem.resize(newMax);
                } else {
                    AppState.rainSystem.max = newMax;
                }
                AppState.rainSystem.enableShafts = !!Graphics.rainshafts;
                // control visual shaft visibility
                if (AppState.rainSystem.rainshaftGroup) {
                    AppState.rainSystem.rainshaftGroup.visible = !!Graphics.rainshafts;
                }
            }
            // Building lights: ensure UrbanSystem respects toggle by forcing window opacities
            try {
                if (AppState.urbanSystem && AppState.urbanSystem.cities) {
                    for (const city of AppState.urbanSystem.cities) {
                        for (const l of city.lights || []) {
                            if (!l || !l.material) continue;
                            // when buildingLights is true, allow night-based opacities; when false, hide them
                            if (Graphics.buildingLights) {
                                // if night use baseOpacity else small daytime tint
                                const night = window.DayNight ? (window.DayNight.dayStrength < 0.15) : false;
                                l.material.opacity = night ? (l.userData && l.userData.baseOpacity ? l.userData.baseOpacity : 0.9) : 0.06;
                            } else {
                                l.material.opacity = 0.0;
                            }
                        }
                    }
                }
            } catch (e) { console.warn('apply buildingLights failed', e); }
            // render distance affects cloud spawning and camera far plane
            Graphics.renderDistance = Math.max(60, Math.min(1000, Number(Graphics.renderDistance || 260)));
            if (AppState.camera) {
                AppState.camera.far = Math.max(120, Graphics.renderDistance * 4); // keep far clipping sufficiently beyond renderDistance
                AppState.camera.updateProjectionMatrix && AppState.camera.updateProjectionMatrix();
            }
            // lightning
            if (AppState.lightningSystem) AppState.lightningSystem.enabled = !!Graphics.lightning;
            // rainbow
            if (AppState.rainbowSystem) AppState.rainbowSystem.enabled = !!Graphics.rainbow;
            // radar overlay visibility
            if (AppState.radarOverlay) AppState.radarOverlay.enabled = !!Graphics.radar;
            // velocity arrows toggle
            if (AppState.velocityArrows) {
                AppState.velocityArrows.enabled = !!Graphics.windVectors;
                AppState.velocityArrows.group.visible = !!Graphics.windVectors;
            }
            // rain fog visibility control: fade/hide group when disabled
            if (AppState.rainFog) {
                AppState.rainFog.group.visible = !!Graphics.rainFog;
            }
            // cloud detail - control max clouds
            if (AppState.cloudSystem) {
                const newMaxClouds = Math.max(10, Math.min(200, Math.floor(Graphics.cloudDetail)));
                AppState.cloudSystem.max = newMaxClouds;
                // expose volumetric settings to cloud system for immediate effect
                AppState.cloudSystem.volumetricEnabled = !!Graphics.volumetric;
                AppState.cloudSystem.volumetricDensity = Number(Graphics.volumetricDensity);
                AppState.cloudSystem.volumetricResolution = Number(Graphics.volumetricResolution);
                // if there are too many clouds right now, prune oldest/dying ones
                if (AppState.cloudSystem.clouds.length > newMaxClouds) {
                    const excess = AppState.cloudSystem.clouds.length - newMaxClouds;
                    // remove oldest (largest age) or dying clouds first
                    AppState.cloudSystem.clouds.sort((a,b) => (b.dying?1:0) - (a.dying?1:0) || b.age - a.age);
                    for (let i = 0; i < excess; i++) {
                        const c = AppState.cloudSystem.clouds.pop();
                        if (c && c.grp) {
                            // dispose meshes inside group
                            c.puffs.forEach(p => {
                                if (!p) return;
                                if (p.geometry) p.geometry.dispose();
                                if (p.material) p.material.dispose();
                            });
                            AppState.cloudSystem.group.remove(c.grp);
                        }
                    }
                }
            }
            // VSync handling: if vsync on use renderer.setAnimationLoop to sync to display; otherwise use requestAnimationFrame loop
            try {
                if (Graphics.vsync) {
                    // prefer WebGLRenderer.setAnimationLoop for vsync-stepped rendering
                    if (AppState.renderer && typeof AppState.renderer.setAnimationLoop === 'function') {
                        AppState.renderer.setAnimationLoop(animate);
                        // cancel any RAF we've created
                        if (AppState._rafId) { cancelAnimationFrame(AppState._rafId); AppState._rafId = null; }
                    }
                } else {
                    // turn off setAnimationLoop to allow custom RAF driven loop
                    if (AppState.renderer && typeof AppState.renderer.setAnimationLoop === 'function') {
                        AppState.renderer.setAnimationLoop(null);
                    }
                    // ensure our RAF-driven loop is running
                    if (!AppState._rafId) {
                        AppState._rafId = requestAnimationFrame(animate);
                    }
                }
            } catch (e) { console.warn('VSync apply failed', e); }
            // ensure cloud system is aware of render mode and volumetric toggles
            if (AppState.cloudSystem) {
                AppState.cloudSystem.renderMode = Graphics.cloudRenderMode;
                AppState.cloudSystem.volumetricEnabled = !!Graphics.volumetric;
                AppState.cloudSystem.volumetricDensity = Number(Graphics.volumetricDensity);
                AppState.cloudSystem.volumetricResolution = Number(Graphics.volumetricResolution);

                // rebuild existing cloud puffs to apply new render mode immediately
                AppState.cloudSystem.clouds.forEach(c => {
                    if (!c || !c.grp || !c.puffs) return;
                    c.puffs.forEach(p => {
                        if (!p) return;
                        c.grp.remove(p);
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                    });
                    c.puffs = [];
                });
            }
            // evaporation multiplier
            if (AppState.evaporationSystem) {
                // evaporationSystem.multiplier used by evaporation update; keep synced to UI slider
                AppState.evaporationSystem.multiplier = Number(Graphics.evapMultiplier || Graphics.evapMultiplier) || 1;
            }
            // Sun glare & godrays toggles: set material opacities from Graphics flags immediately
            if (AppState._sunGlare && AppState._sunGlare.material) {
                AppState._sunGlare.material.opacity = Graphics.sun ? AppState._sunGlare.material.opacity || 0.35 : 0.0;
            }
            if (AppState._godrays && AppState._godrays.material) {
                AppState._godrays.material.opacity = Graphics.godrays ? AppState._godrays.userData.baseOpacity : 0.0;
            }
            // pixel ratio
            if (AppState.renderer) {
                const pr = Math.max(0.5, Math.min(2, Number(Graphics.pixelRatio)));
                AppState.renderer.setPixelRatio(pr);
                AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            // Ray tracing toggle: if enabled attempt lightweight path-like settings (real ray tracing requires WebGL2 + special libs)
            try {
                if (Graphics.rayTracing) {
                    // non-invasive approximation: increase exposure, enable ToneMapping to emulate stronger light interaction
                    AppState.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    AppState.renderer.toneMappingExposure = 1.1;
                    // approximate "better" shadows by using PCF soft shadows and increase shadow map resolution
                    try {
                        AppState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        AppState.scene.traverse(obj => {
                            if (obj.isDirectionalLight && obj.shadow && obj.shadow.mapSize) {
                                obj.shadow.mapSize.width = obj.shadow.mapSize.height = 2048;
                            }
                        });
                    } catch(e) {}
                    // immediate user-visible warning about heavy shader/settings
                    if (!AppState._rayWarnShown) {
                        AppState._rayWarnShown = true;
                        showPerfWarning('Heavy graphics enabled: Ray Tracing approximations may reduce frame rate. Consider disabling for better performance.', 'raytrace-toggle-warning', 6000);
                    } else {
                        // keep lightweight persistent message for a short time
                        showPerfWarning('Heavy graphics enabled: Ray Tracing approximations may reduce frame rate.', 'raytrace-toggle-warning', 3000);
                    }
                } else {
                    AppState.renderer.toneMapping = THREE.ReinhardToneMapping;
                    AppState.renderer.toneMappingExposure = 1.0;
                    try {
                        AppState.renderer.shadowMap.type = THREE.PCFShadowMap;
                        AppState.scene.traverse(obj => {
                            if (obj.isDirectionalLight && obj.shadow && obj.shadow.mapSize) {
                                obj.shadow.mapSize.width = obj.shadow.mapSize.height = 1024;
                            }
                        });
                    } catch(e) {}
                    // hide ray warning if present
                    AppState._rayWarnShown = false;
                    try { const el = document.getElementById('raytrace-toggle-warning'); if (el) el.style.display = 'none'; } catch(e){}
                }
            } catch(e){}
            // greenhouse slider effect: store value and DayNight will use Graphics.greenhouse in its update
            // pixel ratio already applied above
        }

        init();
        // create radar overlay & emitters after init
        AppState.radarOverlay = new RadarOverlay();
        AppState.emitters = [];
        // spawn an industrial park and a volcano
        AppState.emitters.push(new SourceEmitter('factory', -90, 60));
        AppState.emitters.push(new SourceEmitter('factory', 140, -10));
        // create a large standalone volcano scaled to look mountain-sized
        AppState.emitters.push(new SourceEmitter('volcano', 40, -160, 48, 24));

        // NEW: RainFog instance
        AppState.rainFog = new RainFog();

        // start the render loop according to current VSync setting
        if (Graphics.vsync && AppState.renderer && typeof AppState.renderer.setAnimationLoop === 'function') {
            AppState.renderer.setAnimationLoop(animate);
        } else {
            AppState._rafId = requestAnimationFrame(animate);
        }

        // wire graphics UI controls to Graphics object and apply settings
        (function setupGraphicsUI() {
            // Insert Simulation Speed slider
            const simRow = document.createElement('div');
            simRow.className = 'gfx-row';
            simRow.style.marginTop = '6px';
            const simLabel = document.createElement('label');
            simLabel.className = 'gfx-label';
            simLabel.textContent = 'Sim √ó';
            const simRange = document.createElement('input');
            simRange.type = 'range';
            simRange.min = 0.1; simRange.max = 4.0; simRange.step = 0.05; simRange.value = Graphics.simSpeed || 1.0;
            simRow.appendChild(simLabel);
            simRow.appendChild(simRange);
            const gfxPanel = document.getElementById('graphics');
            if (gfxPanel) gfxPanel.appendChild(simRow);
            simRange.addEventListener('input', () => {
                Graphics.simSpeed = Number(simRange.value);
            });

            const irRange = document.getElementById('ir-range');
            const shadowToggle = document.getElementById('shadow-toggle');
            const lightningToggle = document.getElementById('lightning-toggle');
            const particleRange = document.getElementById('particle-range');
            const cloudRange = document.getElementById('cloud-range');
            const pxRange = document.getElementById('px-range');
            const cloudModeSelect = document.getElementById('cloud-mode');
            const evapRange = document.getElementById('evap-range');
            const rainIntensityRange = document.getElementById('rain-intensity-range');
            const evapMultRange = document.getElementById('evap-mult-range');
            // add Sun & Godrays toggles
            const sunContainer = document.createElement('div');
            sunContainer.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
            const sunLabel = document.createElement('div'); sunLabel.textContent = 'Sun Glare';
            const sunChk = document.createElement('input'); sunChk.type = 'checkbox'; sunChk.id = 'sun-toggle'; sunChk.checked = true;
            sunContainer.appendChild(sunLabel); sunContainer.appendChild(sunChk);
            const gfxBox = document.getElementById('graphics') || document.querySelector('.ui-panel#graphics');
            if (gfxBox) gfxBox.insertBefore(sunContainer, gfxBox.firstChild.nextSibling);

            const godContainer = document.createElement('div');
            godContainer.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
            const godLabel = document.createElement('div'); godLabel.textContent = 'Godrays';
            const godChk = document.createElement('input'); godChk.type = 'checkbox'; godChk.id = 'godray-toggle'; godChk.checked = true;
            godContainer.appendChild(godLabel); godContainer.appendChild(godChk);
            if (gfxBox) gfxBox.insertBefore(godContainer, sunContainer.nextSibling);

            const rainbowToggle = document.createElement('input');
            rainbowToggle.type = 'checkbox';
            rainbowToggle.id = 'rainbow-toggle';
            // insert rainbow toggle into graphics panel near lightning toggle if that exists
            const lightningRow = document.getElementById('lightning-toggle');
            if (lightningRow && lightningRow.parentElement) {
                const container = document.createElement('div');
                container.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
                const label = document.createElement('div');
                label.textContent = 'Rainbows';
                container.appendChild(label);
                container.appendChild(rainbowToggle);
                lightningRow.parentElement.insertBefore(container, lightningRow.parentElement.children[lightningRow.parentElement.children.length - 1] || null);
            } else {
                // fallback: append to graphics group
                const gbox = document.getElementById('graphics');
                if (gbox) {
                    const container = document.createElement('div');
                    container.style.cssText = 'font-size:12px; color:#ddd; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
                    const label = document.createElement('div');
                    label.textContent = 'Rainbows';
                    container.appendChild(label);
                    container.appendChild(rainbowToggle);
                    gbox.appendChild(container);
                }
            }

            if (shadowToggle) {
                shadowToggle.addEventListener('change', () => {
                    Graphics.shadows = shadowToggle.checked;
                    applyGraphicsSettings();
                });
            }
            if (lightningToggle) {
                lightningToggle.addEventListener('change', () => {
                    Graphics.lightning = lightningToggle.checked;
                    applyGraphicsSettings();
                });
            }
            if (particleRange) {
                particleRange.addEventListener('input', () => {
                    Graphics.particleDetail = Number(particleRange.value);
                    applyGraphicsSettings();
                });
            }
            if (cloudRange) {
                cloudRange.addEventListener('input', () => {
                    Graphics.cloudDetail = Number(cloudRange.value);
                    applyGraphicsSettings();
                });
            }
            if (pxRange) {
                pxRange.addEventListener('input', () => {
                    Graphics.pixelRatio = Number(pxRange.value);
                    applyGraphicsSettings();
                });
            }
            if (cloudModeSelect) {
                cloudModeSelect.addEventListener('change', () => {
                    Graphics.cloudRenderMode = cloudModeSelect.value === 'particles' ? 'particles' : 'volumetric';
                    applyGraphicsSettings();
                });
            }
            if (evapRange) {
                evapRange.addEventListener('input', () => {
                    Graphics.evapMultiplier = Number(evapRange.value);
                    applyGraphicsSettings();
                });
            }
            if (rainIntensityRange) {
                rainIntensityRange.addEventListener('input', () => {
                    Graphics.rainIntensity = Number(rainIntensityRange.value);
                    applyGraphicsSettings();
                });
            }
            if (evapMultRange) {
                evapMultRange.addEventListener('input', () => {
                    Graphics.evapMultiplier = Number(evapMultRange.value);
                    // propagate to evaporation system
                    if (AppState.evaporationSystem) AppState.evaporationSystem.multiplier = Graphics.evapMultiplier;
                    applyGraphicsSettings();
                });
            }
            if (irRange) {
                irRange.addEventListener('input', () => {
                    Graphics.irMultiplier = Number(irRange.value);
                    applyGraphicsSettings();
                });
            }
            if (document.getElementById('sun-toggle')) {
                document.getElementById('sun-toggle').addEventListener('change', (e) => {
                    Graphics.sun = e.target.checked;
                    applyGraphicsSettings();
                });
            }
            if (document.getElementById('godray-toggle')) {
                document.getElementById('godray-toggle').addEventListener('change', (e) => {
                    Graphics.godrays = e.target.checked;
                    applyGraphicsSettings();
                });
            }
            if (rainbowToggle) {
                rainbowToggle.addEventListener('change', () => {
                    Graphics.rainbow = rainbowToggle.checked;
                    applyGraphicsSettings();
                });
            }

            // initialize from current UI values
            if (shadowToggle) Graphics.shadows = shadowToggle.checked;
            // rainshafts no longer exposed via UI; remain off
            if (lightningToggle) Graphics.lightning = lightningToggle.checked;
            if (rainbowToggle) Graphics.rainbow = rainbowToggle.checked !== undefined ? rainbowToggle.checked : true;
            if (particleRange) Graphics.particleDetail = Number(particleRange.value);
            if (cloudRange) Graphics.cloudDetail = Number(cloudRange.value);
            if (pxRange) Graphics.pixelRatio = Number(pxRange.value);
            if (cloudModeSelect) Graphics.cloudRenderMode = cloudModeSelect.value === 'particles' ? 'particles' : 'volumetric';
            if (evapRange) Graphics.evapMultiplier = Number(evapRange.value);
            if (rainIntensityRange) Graphics.rainIntensity = Number(rainIntensityRange.value);
            if (evapMultRange) Graphics.evapMultiplier = Number(evapMultRange.value);
            if (irRange) Graphics.irMultiplier = Number(irRange.value);
            Graphics.sun = document.getElementById('sun-toggle') ? document.getElementById('sun-toggle').checked : true;
            Graphics.godrays = document.getElementById('godray-toggle') ? document.getElementById('godray-toggle').checked : true;

            // Insert wind multiplier control into graphics panel
            const windRow = document.createElement('div');
            windRow.className = 'gfx-row';
            windRow.style.marginTop = '6px';
            const windLabel = document.createElement('label');
            windLabel.className = 'gfx-label';
            windLabel.textContent = 'Wind √ó';
            const windRange = document.createElement('input');
            windRange.type = 'range';
            windRange.min = 0.1; windRange.max = 3.0; windRange.step = 0.05; windRange.value = Graphics.windMultiplier;
            windRow.appendChild(windLabel);
            windRow.appendChild(windRange);
            if (gfxPanel) gfxPanel.appendChild(windRow);
            windRange.addEventListener('input', () => {
                Graphics.windMultiplier = Number(windRange.value);
                applyGraphicsSettings();
            });

            // Add Wind Vectors toggle
            const vecRow = document.createElement('div');
            vecRow.className = 'gfx-row';
            vecRow.style.marginTop = '6px';
            const vecLabel = document.createElement('label');
            vecLabel.className = 'gfx-label';
            vecLabel.textContent = 'Wind Vectors';
            const vecChk = document.createElement('input');
            vecChk.type = 'checkbox';
            vecChk.id = 'windvectors-toggle';
            vecChk.checked = false;
            vecRow.appendChild(vecLabel);
            vecRow.appendChild(vecChk);
            if (gfxPanel) gfxPanel.appendChild(vecRow);
            vecChk.addEventListener('change', (e) => {
                Graphics.windVectors = !!e.target.checked;
                applyGraphicsSettings();
            });

            // initialize wind multiplier UI state
            Graphics.windMultiplier = Graphics.windMultiplier || 1.0;

            // initialize wind vectors flag
            Graphics.windVectors = Graphics.windVectors || false;

            // Insert Ray Tracing toggle
            const rtRow = document.createElement('div');
            rtRow.className = 'gfx-row';
            rtRow.style.marginTop = '6px';
            const rtLabel = document.createElement('label'); rtLabel.className = 'gfx-label'; rtLabel.textContent = 'Ray Tracing (heavy)';
            const rtChk = document.createElement('input'); rtChk.type = 'checkbox'; rtChk.id = 'raytrace-toggle'; rtChk.checked = Graphics.rayTracing;
            rtRow.appendChild(rtLabel); rtRow.appendChild(rtChk);
            if (gfxPanel) gfxPanel.appendChild(rtRow);
            rtChk.addEventListener('change', (e) => {
                Graphics.rayTracing = !!e.target.checked;
                // performance warning handled in animate first use
                applyGraphicsSettings();
            });

            // Insert Greenhouse slider
            const ghRow = document.createElement('div');
            ghRow.className = 'gfx-row';
            ghRow.style.marginTop = '6px';
            const ghLabel = document.createElement('label'); ghLabel.className = 'gfx-label'; ghLabel.textContent = 'Greenhouse ¬∞C';
            const ghRange = document.createElement('input'); ghRange.type = 'range'; ghRange.min = 0.0; ghRange.max = 6.0; ghRange.step = 0.1; ghRange.value = Graphics.greenhouse || 0.0;
            ghRow.appendChild(ghLabel); ghRow.appendChild(ghRange);
            if (gfxPanel) gfxPanel.appendChild(ghRow);
            ghRange.addEventListener('input', () => {
                Graphics.greenhouse = Number(ghRange.value);
                // DayNight.update will use Graphics.greenhouse
            });

            // Insert Charge Multiplier slider
            const chRow = document.createElement('div');
            chRow.className = 'gfx-row';
            chRow.style.marginTop = '6px';
            const chLabel = document.createElement('label'); chLabel.className = 'gfx-label'; chLabel.textContent = 'Charge √ó';
            const chRange = document.createElement('input'); chRange.type = 'range'; chRange.min = 0.2; chRange.max = 4.0; chRange.step = 0.05; chRange.value = Graphics.chargeMultiplier || 1.0;
            chRow.appendChild(chLabel); chRow.appendChild(chRange);
            if (gfxPanel) gfxPanel.appendChild(chRow);
            chRange.addEventListener('input', () => {
                Graphics.chargeMultiplier = Number(chRange.value);
            });
            // show initial charge multiplier label (optional tiny indicator)
            Graphics.chargeMultiplier = Number(chRange.value || 1.0);

            // initialize raytrace and greenhouse UI state
            Graphics.rayTracing = !!(document.getElementById('raytrace-toggle') && document.getElementById('raytrace-toggle').checked);
            Graphics.greenhouse = Number(ghRange.value || 0.0);
            // ensure UI-driven chargeMultiplier is loaded
            Graphics.chargeMultiplier = Number(window.Graphics && window.Graphics.chargeMultiplier ? window.Graphics.chargeMultiplier : (chRange && chRange.value ? chRange.value : 1.0));

            // insert radar toggle
            const radRow = document.createElement('div');
            radRow.className = 'gfx-row';
            radRow.style.marginTop = '6px';
            const radLabel = document.createElement('label'); radLabel.className = 'gfx-label'; radLabel.textContent = 'Radar';
            const radChk = document.createElement('input'); radChk.type = 'checkbox'; radChk.id = 'radar-toggle'; radChk.checked = true;
            radRow.appendChild(radLabel); radRow.appendChild(radChk);
            if (gfxPanel) gfxPanel.appendChild(radRow);
            radChk.addEventListener('change', (e)=>{ Graphics.radar = !!e.target.checked; if (AppState.radarOverlay) AppState.radarOverlay.enabled = Graphics.radar; });
            Graphics.radar = !!document.getElementById('radar-toggle') && document.getElementById('radar-toggle').checked;

            // Fog toggle UI
            const fogRow = document.createElement('div');
            fogRow.className = 'gfx-row';
            fogRow.style.marginTop = '6px';
            const fogLbl = document.createElement('label'); fogLbl.className = 'gfx-label'; fogLbl.textContent = 'Fog';
            const fogChk = document.createElement('input'); fogChk.type = 'checkbox'; fogChk.id = 'scene-fog-toggle'; fogChk.checked = Graphics.fog;
            fogRow.appendChild(fogLbl); fogRow.appendChild(fogChk);
            if (gfxPanel) gfxPanel.appendChild(fogRow);
            fogChk.addEventListener('change', (e) => { Graphics.fog = !!e.target.checked; applyGraphicsSettings(); });
            Graphics.fog = !!fogChk.checked;

            // Building lights toggle UI
            const blRow = document.createElement('div');
            blRow.className = 'gfx-row';
            blRow.style.marginTop = '6px';
            const blLbl = document.createElement('label'); blLbl.className = 'gfx-label'; blLbl.textContent = 'Building Lights';
            const blChk = document.createElement('input'); blChk.type = 'checkbox'; blChk.id = 'building-lights-toggle'; blChk.checked = Graphics.buildingLights;
            blRow.appendChild(blLbl); blRow.appendChild(blChk);
            if (gfxPanel) gfxPanel.appendChild(blRow);
            blChk.addEventListener('change', (e) => { Graphics.buildingLights = !!e.target.checked; applyGraphicsSettings(); });
            Graphics.buildingLights = !!blChk.checked;

            // Insert Rain Fog toggle
            const rainFogRow = document.createElement('div');
            rainFogRow.className = 'gfx-row';
            rainFogRow.style.marginTop = '6px';
            const rainFogLabel = document.createElement('label'); rainFogLabel.className = 'gfx-label'; rainFogLabel.textContent = 'Rain Fog';
            const rainFogChk = document.createElement('input'); rainFogChk.type = 'checkbox'; rainFogChk.id = 'rainfog-toggle'; rainFogChk.checked = !!Graphics.rainFog;
            rainFogRow.appendChild(rainFogLabel); rainFogRow.appendChild(rainFogChk);
            if (gfxPanel) gfxPanel.appendChild(rainFogRow);
            rainFogChk.addEventListener('change', (e)=>{ Graphics.rainFog = !!e.target.checked; if (AppState.rainFog) AppState.rainFog.group.visible = Graphics.rainFog; });
            Graphics.rainFog = !!(document.getElementById('rainfog-toggle') && document.getElementById('rainfog-toggle').checked);

            applyGraphicsSettings();

            // ---------- Render Distance slider ----------
            const rdRow = document.createElement('div');
            rdRow.className = 'gfx-row';
            rdRow.style.marginTop = '6px';
            const rdLabel = document.createElement('label');
            rdLabel.className = 'gfx-label';
            rdLabel.textContent = 'Render Dist.';
            const rdRange = document.createElement('input');
            rdRange.type = 'range';
            rdRange.min = 60; rdRange.max = 1000; rdRange.step = 10; rdRange.value = Graphics.renderDistance || 260;
            rdRow.appendChild(rdLabel);
            rdRow.appendChild(rdRange);
            if (gfxPanel) gfxPanel.appendChild(rdRow);
            rdRange.addEventListener('input', () => {
                Graphics.renderDistance = Number(rdRange.value);
                applyGraphicsSettings();
            });

            // ---------- V-Sync toggle ----------
            const vsRow = document.createElement('div');
            vsRow.className = 'gfx-row';
            vsRow.style.marginTop = '6px';
            const vsLabel = document.createElement('label');
            vsLabel.className = 'gfx-label';
            vsLabel.textContent = 'V-Sync';
            const vsChk = document.createElement('input');
            vsChk.type = 'checkbox';
            vsChk.id = 'vsync-toggle';
            vsChk.checked = !!Graphics.vsync;
            vsRow.appendChild(vsLabel);
            vsRow.appendChild(vsChk);
            if (gfxPanel) gfxPanel.appendChild(vsRow);
            vsChk.addEventListener('change', (e) => {
                Graphics.vsync = !!e.target.checked;
                applyGraphicsSettings();
            });
            // initialize UI state
            if (document.getElementById('vsync-toggle')) Graphics.vsync = document.getElementById('vsync-toggle').checked;
        })();

        // Mobile joystick using nipplejs (esm.sh) - left = movement, right = look
        (async () => {
            try {
                const { default: nipplejs } = await import('https://esm.sh/nipplejs@0.9.0');
                // create invisible zones for two joysticks
                const moveZone = document.createElement('div');
                moveZone.id = 'joy-move';
                moveZone.className = 'joy-zone';
                document.body.appendChild(moveZone);

                const lookZone = document.createElement('div');
                lookZone.id = 'joy-look';
                lookZone.className = 'joy-zone';
                document.body.appendChild(lookZone);

                const mgrMove = nipplejs.create({ zone: moveZone, mode: 'static', position: { left: '60px', top: '60px' }, color: '#6cf' });
                const mgrLook = nipplejs.create({ zone: lookZone, mode: 'static', position: { right: '60px', top: '60px' }, color: '#6cf' });

                // Movement joystick: controls forward/back and strafing
                let moveActive = false;
                mgrMove.on('start', () => moveActive = true);
                mgrMove.on('end', () => {
                    moveActive = false;
                    AppState.cameraControls.move.forward = 0;
                    AppState.cameraControls.move.right = 0;
                });
                mgrMove.on('move', (evt, data) => {
                    if (!moveActive || !data) return;
                    const force = data.force || 0;
                    const angle = data.angle && data.angle.radian !== undefined ? data.angle.radian : 0;
                    // project joystick vector to forward/right in FP orientation
                    const vx = Math.cos(angle) * force;
                    const vy = Math.sin(angle) * force;
                    // map to forward and right axes (invert y so up = forward)
                    AppState.cameraControls.move.forward = -vy * 1.4;
                    AppState.cameraControls.move.right = vx * 1.4;
                });

                // Look joystick: controls yaw/pitch when in FP or orbit rotation otherwise
                let lookActive = false;
                mgrLook.on('start', () => lookActive = true);
                mgrLook.on('end', () => lookActive = false);
                mgrLook.on('move', (evt, data) => {
                    if (!lookActive || !data) return;
                    const vx = data.vector.x || 0;
                    const vy = data.vector.y || 0;
                    if (AppState.firstPerson) {
                        AppState.cameraControls.rotation.yaw -= vx * 0.06;
                        AppState.cameraControls.rotation.pitch -= vy * 0.05;
                        AppState.cameraControls.rotation.pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, AppState.cameraControls.rotation.pitch));
                    } else {
                        AppState.cameraControls.rotation.theta -= vx * 0.03;
                        AppState.cameraControls.rotation.phi -= vy * 0.02;
                        AppState.cameraControls.rotation.phi = Math.max(0.08, Math.min(Math.PI / 2.2, AppState.cameraControls.rotation.phi));
                    }
                    // optional zoom with pushing look joystick forward/back
                    if (data.distance) {
                        AppState.cameraControls.distance = Math.max(20, Math.min(AppState.cameraControls.maxDistance || 300, AppState.cameraControls.distance + vy * 0.8));
                    }
                });
            } catch (err) {
                console.warn('Joystick failed to load:', err);
            }
        })();

        // FP toggle wiring
        (function setupFPToggle() {
            const btn = document.getElementById('fp-toggle');
            function setFP(enabled) {
                AppState.firstPerson = !!enabled;
                btn.classList.toggle('active', AppState.firstPerson);
                btn.textContent = AppState.firstPerson ? 'FP Mode: ON' : 'FP Mode';
                // when switching to FP, position camera to a reasonable height if far out
                if (AppState.firstPerson) {
                    // move camera to ground-level viewpoint preserving current orbit focus direction
                    const theta = AppState.cameraControls.rotation.theta || 0;
                    const phi = AppState.cameraControls.rotation.phi || 0;
                    AppState.cameraControls.rotation.yaw = theta;
                    AppState.cameraControls.rotation.pitch = (phi - Math.PI/2) * -1 * 0.9; // convert orbit pitch to FP pitch approx
                    // place camera near terrain height 1.6 * scale
                    AppState.camera.position.set(0, 2.0, 0);
                } else {
                    // move back to orbit camera default distance
                    AppState.cameraControls.rotation.theta = AppState.cameraControls.rotation.yaw || 0;
                    AppState.cameraControls.rotation.phi = Math.max(0.12, Math.min(Math.PI / 2.2, Math.PI/2 - (AppState.cameraControls.rotation.pitch || 0)));
                    AppState.camera.position.set(
                        AppState.cameraControls.distance * Math.sin(AppState.cameraControls.rotation.theta) * Math.cos(AppState.cameraControls.rotation.phi),
                        AppState.cameraControls.distance * Math.sin(AppState.cameraControls.rotation.phi),
                        AppState.cameraControls.distance * Math.cos(AppState.cameraControls.rotation.theta) * Math.cos(AppState.cameraControls.rotation.phi)
                    );
                }
            }
            btn.addEventListener('click', () => setFP(!AppState.firstPerson));
            // initialize state
            setFP(false);
        })();

        // Reset simulation: clear clouds, rain, lightning, downbursts and reset counters
        function resetSimulation() {
            // clear clouds
            if (AppState.cloudSystem) {
                AppState.cloudSystem.clouds.forEach(c => {
                    if (!c) return;
                    c.puffs.forEach(p => {
                        if (!p) return;
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                    });
                    if (c.grp) AppState.cloudSystem.group.remove(c.grp);
                });
                AppState.cloudSystem.clouds = [];
                AppState.cloudSystem.clusterCenters = [];
                AppState.cloudSystem.updrafts = [];
            }

            // clear precipitation
            if (AppState.rainSystem) {
                for (let i = 0; i < AppState.rainSystem.max; i++) {
                    AppState.rainSystem.drops[i] = { active: false };
                    AppState.rainSystem.pos[i * 3] = 0;
                    AppState.rainSystem.pos[i * 3 + 1] = -1000;
                    AppState.rainSystem.pos[i * 3 + 2] = 0;
                }
                AppState.rainSystem.rain.geometry.attributes.position.needsUpdate = true;
            }

            // clear lightning
            if (AppState.lightningSystem) {
                AppState.lightningSystem.bolts.forEach(b => {
                    if (b.geometry) b.geometry.dispose();
                    if (b.material) b.material.dispose();
                    AppState.scene.remove(b);
                });
                AppState.lightningSystem.bolts = [];
                AppState.lightningSystem.charge = 0;
                AppState.lightningSystem.count = 0;
            }

            // clear downbursts
            if (AppState.downburstSystem) AppState.downburstSystem.events = [];

            // clear urban
            if (AppState.urbanSystem) {
                AppState.urbanSystem.dispose();
                AppState.urbanSystem = new UrbanSystem(9);
            }

            // reset camera to safe orbit
            AppState.firstPerson = false;
            document.getElementById('fp-toggle').classList.remove('active');
            document.getElementById('fp-toggle').textContent = 'FP Mode';
            AppState.camera.position.set(0, 25, 70);
            AppState.cameraControls.distance = 70;
            AppState.cameraControls.rotation.theta = 0;
            AppState.cameraControls.rotation.phi = Math.PI / 5.5;
        }

        document.getElementById('reset-btn').addEventListener('click', () => {
            resetSimulation();
        });

        // Forward button wiring (touch / hold)
        (function setupForwardButton() {
            const fbtn = document.getElementById('forward-btn');
            if (!fbtn) return;
            let pointerActive = false;
            const setForward = (v) => { AppState.cameraControls.move.forward = v ? 1 : 0; };
            fbtn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                pointerActive = true;
                setForward(true);
            });
            window.addEventListener('pointerup', (e) => {
                if (!pointerActive) return;
                pointerActive = false;
                setForward(false);
            });
            // also support touchend/cancel
            fbtn.addEventListener('pointercancel', () => { pointerActive = false; setForward(false); });
            // keyboard 'w' already sets move.forward via updateKeyboardMovement; ensure releasing W stops movement
        })();
    </script>
</body>
</html>
